<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="baidu-site-verification" content="codeva-6wmKWl5hmx" />
<meta name="bytedance-verification-code" content="GcOf/MpQ8shZ5Hh/2hvr" />
<meta name="google-site-verification" content="wivqPhuFdISMEKkFZjOWHPYJGSvd716d9R7Bwy2Jj-A" />
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.vvbuys.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="We have seen…  propositions: factual claims equality propositions (e1 &#x3D; e2) implications (P → Q) quantified propositions (∀ x, P)   proofs: ways of presenting evidence for the truth of a proposition">
<meta property="og:type" content="article">
<meta property="og:title" content="「SF-LC」6 Logic">
<meta property="og:url" content="https://www.vvbuys.com/read_sf_lf/2019-01-06-sf-lf-06-logic/index.html">
<meta property="og:site_name" content="VVbugs Blog">
<meta property="og:description" content="We have seen…  propositions: factual claims equality propositions (e1 &#x3D; e2) implications (P → Q) quantified propositions (∀ x, P)   proofs: ways of presenting evidence for the truth of a proposition">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-02-02T01:05:07.544Z">
<meta property="article:modified_time" content="2024-02-02T01:05:07.544Z">
<meta property="article:author" content="vvbuys">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="LF (逻辑基础)">
<meta property="article:tag" content="SF (软件基础)">
<meta property="article:tag" content="Coq">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.vvbuys.com/read_sf_lf/2019-01-06-sf-lf-06-logic/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.vvbuys.com/read_sf_lf/2019-01-06-sf-lf-06-logic/","path":"read_sf_lf/2019-01-06-sf-lf-06-logic/","title":"「SF-LC」6 Logic"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>「SF-LC」6 Logic | VVbugs Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">VVbugs Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">standalone Linux lover</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Prop-type"><span class="nav-number">1.</span> <span class="nav-text">Prop type</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Properties"><span class="nav-number">1.1.</span> <span class="nav-text">Properties</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slide-Q-A-1"><span class="nav-number">2.</span> <span class="nav-text">Slide Q&amp;A - 1.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Logical-Connectives"><span class="nav-number">3.</span> <span class="nav-text">Logical Connectives</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Conjuction-logical-and"><span class="nav-number">3.1.</span> <span class="nav-text">Conjuction (logical and)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#and-introduction"><span class="nav-number">3.1.1.</span> <span class="nav-text">and introduction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#and-elimination"><span class="nav-number">3.1.2.</span> <span class="nav-text">and elimination</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Disjunction-locial-or"><span class="nav-number">3.2.</span> <span class="nav-text">Disjunction (locial or)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#or-elimination"><span class="nav-number">3.2.1.</span> <span class="nav-text">or elimination</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#or-introduction"><span class="nav-number">3.2.2.</span> <span class="nav-text">or introduction</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Falsehood-and-negation"><span class="nav-number">3.3.</span> <span class="nav-text">Falsehood and negation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#False"><span class="nav-number">3.3.1.</span> <span class="nav-text">False?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inequality"><span class="nav-number">3.3.2.</span> <span class="nav-text">Inequality</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Proving-of-negation-or-how-to-prove-%C2%ACP"><span class="nav-number">3.3.3.</span> <span class="nav-text">Proving of negation (or how to prove ¬P)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tactic-exfalso"><span class="nav-number">3.3.4.</span> <span class="nav-text">Tactic exfalso.</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slide-Q-A-2"><span class="nav-number">4.</span> <span class="nav-text">Slide Q&amp;A - 2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Truth"><span class="nav-number">4.1.</span> <span class="nav-text">Truth</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Logical-Equivalence"><span class="nav-number">4.2.</span> <span class="nav-text">Logical Equivalence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Existential-Quantification"><span class="nav-number">4.3.</span> <span class="nav-text">Existential Quantification</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Intro"><span class="nav-number">4.3.1.</span> <span class="nav-text">Intro</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Elim"><span class="nav-number">4.3.2.</span> <span class="nav-text">Elim</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Programming-with-Propositions"><span class="nav-number">5.</span> <span class="nav-text">Programming with Propositions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#In-map"><span class="nav-number">5.1.</span> <span class="nav-text">In_map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Drawbacks"><span class="nav-number">5.2.</span> <span class="nav-text">Drawbacks</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Applying-Theorems-to-Arguments"><span class="nav-number">6.</span> <span class="nav-text">Applying Theorems to Arguments.</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Check-some-theorem-print-the-statement"><span class="nav-number">6.1.</span> <span class="nav-text">Check some_theorem print the statement!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proof-Object"><span class="nav-number">6.2.</span> <span class="nav-text">Proof Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Apply-theorem-as-function"><span class="nav-number">6.3.</span> <span class="nav-text">Apply theorem as function</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Coq-vs-Set-Theory"><span class="nav-number">7.</span> <span class="nav-text">Coq vs. Set Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Functional-Extensionality"><span class="nav-number">7.1.</span> <span class="nav-text">Functional Extensionality</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adding-Axioms"><span class="nav-number">7.2.</span> <span class="nav-text">Adding Axioms</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-Proving-Reverse-with-app-and-with-cons-are-fn-exensionally-equivalent"><span class="nav-number">7.3.</span> <span class="nav-text">Exercise - Proving Reverse with app and with cons are fn-exensionally equivalent.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Propositions-and-Booleans"><span class="nav-number">7.4.</span> <span class="nav-text">Propositions and Booleans</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Notes-on-Computability"><span class="nav-number">7.4.1.</span> <span class="nav-text">Notes on Computability.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Proof-by-Reflection"><span class="nav-number">7.4.2.</span> <span class="nav-text">Proof by Reflection!</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Classical-vs-Constructive-Logic"><span class="nav-number">7.5.</span> <span class="nav-text">Classical vs. Constructive Logic</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Future-Schedule"><span class="nav-number">8.</span> <span class="nav-text">Future Schedule</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">vvbuys</p>
  <div class="site-description" itemprop="description">Share some post and some issue for linux program</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">265</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_lf/2019-01-06-sf-lf-06-logic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="「SF-LC」6 Logic | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          「SF-LC」6 Logic
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>We have seen…</p>
<ul>
<li><em>propositions</em>: factual claims<ul>
<li>equality propositions (<code>e1 = e2</code>)</li>
<li>implications (<code>P → Q</code>)</li>
<li>quantified propositions (<code>∀ x, P</code>)</li>
</ul>
</li>
<li><em>proofs</em>: ways of presenting <strong>evidence</strong> for the truth of a proposition</li>
</ul>
<h2 id="Prop-type"><a href="#Prop-type" class="headerlink" title="Prop type"></a><code>Prop</code> type</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> <span class="number">3</span> = <span class="number">3.</span>  <span class="comment">(* ===&gt; Prop. A provable prop *)</span></span><br><span class="line"><span class="keyword">Check</span> <span class="number">3</span> = <span class="number">4.</span>  <span class="comment">(* ===&gt; Prop. A unprovable prop *)</span></span><br></pre></td></tr></table></figure>

<p><code>Prop</code> is <em>first-class entity</em> we can </p>
<ul>
<li>name it</li>
<li><em>parametrized</em>!</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> is_three (n : nat) : <span class="keyword">Prop</span> :=</span><br><span class="line">  n = <span class="number">3.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> is_three. <span class="comment">(* ===&gt; nat -&gt; Prop *)</span></span><br></pre></td></tr></table></figure>

<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><blockquote>
<p>In Coq, <em>functions that return propositions</em> are said to define <em>properties</em> of their arguments.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> injective &#123;A B&#125; (f : A → B) :=</span><br><span class="line">  ∀x y : A, f x = f y → x = y.</span><br><span class="line"><span class="keyword">Lemma</span> succ_inj : injective S. <span class="comment">(* can be read off as &quot;injectivity is a property of S&quot; *)</span></span><br><span class="line"><span class="keyword">Proof</span>. </span><br><span class="line">  <span class="built_in">intros</span> n m H. <span class="built_in">injection</span> H <span class="built_in">as</span> H1. <span class="built_in">apply</span> H1. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>The equality operator <code>=</code> is also a function that returns a <code>Prop</code>. (property: <em>equality</em>)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> @eq. <span class="comment">(* ===&gt; forall A : Type, A -&gt; A -&gt; Prop *)</span></span><br></pre></td></tr></table></figure>

<p>Theroems are types, and proofs are existentials.</p>
<h2 id="Slide-Q-A-1"><a href="#Slide-Q-A-1" class="headerlink" title="Slide Q&amp;A - 1."></a>Slide Q&amp;A - 1.</h2><ol>
<li><code>Prop</code></li>
<li><code>Prop</code></li>
<li><code>Prop</code></li>
<li>Not typeable</li>
<li><code>nat -&gt; nat</code></li>
<li><code>nat -&gt; Prop</code></li>
<li>(3)</li>
</ol>
<p>think that Big Lambda (the type abstraction) works at type level, accepts type var, substitute and reture a type.<br><code>forall</code> in Coq is same (the concrete syntax) and only typecheck with <code>Type</code> or its subtype <code>Set</code> &amp; <code>Prop</code>.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> (∀n:nat, S (pred n)).  <span class="comment">(* not typeable *)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Definition</span> foo : (<span class="keyword">forall</span> n:nat, bool) <span class="comment">(* foo: nat -&gt; bool *)</span></span><br><span class="line">  := <span class="keyword">fun</span> x =&gt; true.</span><br></pre></td></tr></table></figure>


<h2 id="Logical-Connectives"><a href="#Logical-Connectives" class="headerlink" title="Logical Connectives"></a>Logical Connectives</h2><blockquote>
<p>noticed that connectives symbols are “unicodize” in book and spacemacs.</p>
</blockquote>
<h3 id="Conjuction-logical-and"><a href="#Conjuction-logical-and" class="headerlink" title="Conjuction (logical and)"></a>Conjuction (logical and)</h3><p><code>and</code> is just binary <code>Prop -&gt; Prop -&gt; Prop</code> and associative. </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Print</span> <span class="string">&quot;/\&quot;.</span></span><br><span class="line"><span class="string">Inductive and (A B : Prop) : Prop :=  conj : A -&gt; B -&gt; A /\ B</span></span><br><span class="line"><span class="string">Check and. (* ===&gt; and : Prop -&gt; Prop -&gt; Prop *)</span></span><br></pre></td></tr></table></figure>

<h4 id="and-introduction"><a href="#and-introduction" class="headerlink" title="and introduction"></a>and introduction</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> and_intro : <span class="keyword">forall</span> A B : <span class="keyword">Prop</span>, A -&gt; B -&gt; A /\ B.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> A B HA HB. <span class="built_in">split</span>.</span><br><span class="line">  - <span class="built_in">apply</span> HA.</span><br><span class="line">  - <span class="built_in">apply</span> HB.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>To prove a conjunction, </p>
<ul>
<li>use the <code>split</code> tactic. It will generate two subgoals,</li>
<li>or use <code>apply and_intro.</code>, which match the conclusion and give its two premises as your subgoals.</li>
</ul>
</blockquote>
<h4 id="and-elimination"><a href="#and-elimination" class="headerlink" title="and elimination"></a>and elimination</h4><p>if we already have a proof of <code>and</code>, <code>destruct</code> can give us both.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> and_example2&#x27; :</span><br><span class="line">  ∀n m : nat, n = <span class="number">0</span> ∧ m = <span class="number">0</span> → n + m = <span class="number">0.</span></span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n m [Hn Hm]. <span class="comment">(* = intro H. destruct H. *)</span></span><br><span class="line">  <span class="built_in">rewrite</span> Hn. <span class="built_in">rewrite</span> Hm. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.  <span class="comment">(* you could use only one *)</span></span><br></pre></td></tr></table></figure>

<p>Instead of packing into conjunction <code>∀n m : nat, n = 0 ∧ m = 0 → n + m = 0.</code><br>why not two separate premises?      <code>∀n m : nat, n = 0 -&gt; m = 0 → n + m = 0.</code><br>Both are fine in this case but conjunction are useful as intermediate step etc.</p>
<blockquote>
<p>Coq Intensive Q: why <code>destruct</code> can work on <code>and</code>? is <code>and</code> inductively defined?<br>A: Yes.</p>
</blockquote>
<h3 id="Disjunction-locial-or"><a href="#Disjunction-locial-or" class="headerlink" title="Disjunction (locial or)"></a>Disjunction (locial or)</h3><h4 id="or-elimination"><a href="#or-elimination" class="headerlink" title="or elimination"></a>or elimination</h4><p>We need do case analysis (either <code>P</code> or <code>Q</code> should be able to prove the theroem separately!)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> or_example :</span><br><span class="line">  <span class="keyword">forall</span> n m : nat, n = <span class="number">0</span> \/ m = <span class="number">0</span> -&gt; n * m = <span class="number">0.</span></span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="comment">(* This pattern implicitly does case analysis on [n = 0 \/ m = 0] *)</span></span><br><span class="line">  <span class="built_in">intros</span> n m [Hn | <span class="type">Hm</span>]. <span class="comment">(* = intro H. destruct H. *)</span></span><br><span class="line">  - <span class="comment">(* Here, [n = 0] *)</span> <span class="built_in">rewrite</span> Hn. <span class="built_in">reflexivity</span>.</span><br><span class="line">  - <span class="comment">(* Here, [m = 0] *)</span> <span class="built_in">rewrite</span> Hm. <span class="built_in">rewrite</span> &lt;- mult_n_O. <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<h4 id="or-introduction"><a href="#or-introduction" class="headerlink" title="or introduction"></a>or introduction</h4><p>When trying to establish (intro into conclusion) an <code>or</code>, using <code>left</code> or <code>right</code> to pick one side to prove is sufficient.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> or_intro : <span class="keyword">forall</span> A B : <span class="keyword">Prop</span>, A -&gt; A \/ B.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> A B HA.</span><br><span class="line">  <span class="built_in">left</span>.  <span class="comment">(* tactics *)</span></span><br><span class="line">  <span class="built_in">apply</span> HA.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>



<h3 id="Falsehood-and-negation"><a href="#Falsehood-and-negation" class="headerlink" title="Falsehood and negation"></a>Falsehood and negation</h3><h4 id="False"><a href="#False" class="headerlink" title="False?"></a>False?</h4><p>Recall the <em>princple of explosion</em>: it asserts that, if we assume a <em>contradiction</em>, then any other proposition can be derived.<br>we could define <code>¬ P</code> (“not P”) as <code>∀ Q, P → Q.</code>. </p>
<blockquote>
<p>Coq actually makes a slightly different (but equivalent) choice, defining <code>¬ P as P → False</code>, where <code>False</code> is a specific <em>contradictory proposition</em> defined in the standard library. </p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> not (P:<span class="keyword">Prop</span>) := P → False.</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;¬x&quot;</span> := (not x) : type_scope.</span><br></pre></td></tr></table></figure>

<p>Prove the <em>princple of explosion</em>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> ex_falso_quodlibet : <span class="keyword">forall</span> (P:<span class="keyword">Prop</span>),</span><br><span class="line">  False -&gt; P.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> P contra.</span><br><span class="line">  <span class="built_in">destruct</span> contra.  <span class="keyword">Qed</span>.  <span class="comment">(* 0 cases to prove since ⊥ is not provable. [inversion] also works *)</span></span><br></pre></td></tr></table></figure>


<h4 id="Inequality"><a href="#Inequality" class="headerlink" title="Inequality"></a>Inequality</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;x &lt;&gt; y&quot;</span> := (~(x = y)).</span><br></pre></td></tr></table></figure>

<p>Same as SML and OCaml (for structural equality, OCaml uses <code>!=</code> for physical equality.)</p>
<h4 id="Proving-of-negation-or-how-to-prove-¬P"><a href="#Proving-of-negation-or-how-to-prove-¬P" class="headerlink" title="Proving of negation (or how to prove ¬P)"></a>Proving of negation (or how to prove <code>¬P</code>)</h4><p>thinking about as <code>unfold not</code>, i.e. <code>P -&gt; False</code>.<br>so you have an assumptions <code>P</code> that could be <code>intros HP.</code> and the residual goal would be simply <code>False</code>.<br>which is usually proved by some kind of contradiction in hypotheses with tactics <code>discriminate.</code> or <code>contradiction.</code></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> contradiction_implies_anything : <span class="keyword">forall</span> P Q : <span class="keyword">Prop</span>,</span><br><span class="line">  (P /\ ~P) -&gt; Q.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> P Q [HP HNA].                 <span class="comment">(* we could [contradiction.] to end the proof here`*)</span></span><br><span class="line">  <span class="built_in">unfold</span> not <span class="built_in">in</span> HNA. <span class="built_in">apply</span> HNA <span class="built_in">in</span> HP.  <span class="comment">(* HP : False, HNA : P -&gt; False  ⊢  HP: False  *)</span></span><br><span class="line">  <span class="built_in">destruct</span> HP.  <span class="keyword">Qed</span>.                   <span class="comment">(* destruct False.  *)</span></span><br></pre></td></tr></table></figure>

<h4 id="Tactic-exfalso"><a href="#Tactic-exfalso" class="headerlink" title="Tactic exfalso."></a>Tactic <code>exfalso.</code></h4><blockquote>
<p>If you are trying to prove a goal that is nonsensical (e.g., the goal state is <code>false = true</code>), apply <code>ex_falso_quodlibet</code> to change the goal to <code>False</code>. This makes it easier to use assumptions of the form <code>¬P</code> that may be available in the context — in particular, assumptions of the form <code>x≠y</code>.</p>
</blockquote>
<blockquote>
<p>Since reasoning with <code>ex_falso_quodlibet</code> is quite common, Coq provides a built-in tactic, <code>exfalso</code>, for applying it.</p>
</blockquote>
<h2 id="Slide-Q-A-2"><a href="#Slide-Q-A-2" class="headerlink" title="Slide Q&amp;A - 2"></a>Slide Q&amp;A - 2</h2><blockquote>
<p>?<code>unfold</code> is implicit</p>
</blockquote>
<ol>
<li>only <code>destruct</code> (if we consider <code>intros</code> destruct is also <code>destruct</code>.), ?<code>unfold</code></li>
<li>none (?<code>unfold</code>)</li>
<li><code>left.</code></li>
<li><code>destruct</code>, <code>unfold</code>, <code>left</code> and <code>right</code></li>
<li><code>discrinminate</code> (or <code>inversion</code>)</li>
</ol>
<h3 id="Truth"><a href="#Truth" class="headerlink" title="Truth"></a>Truth</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> True_is_true : True.</span><br><span class="line"><span class="keyword">Proof</span>. <span class="built_in">apply</span> I. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p><code>I : True</code> is a predefined Prop…</p>
<h3 id="Logical-Equivalence"><a href="#Logical-Equivalence" class="headerlink" title="Logical Equivalence"></a>Logical Equivalence</h3><p><em>if and only if</em> is just the conjunction of two implications. (so we need <code>split</code> to get 2 subgoals)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> iff (P Q : <span class="keyword">Prop</span>) := (P → Q) ∧ (Q → P).</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;P ↔ Q&quot;</span> := (iff P Q)</span><br><span class="line">                    (<span class="built_in">at</span> level <span class="number">95</span>, no associativity) : type_scope.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>rewrite</code> and <code>reflexivity</code> can be used with iff statements, not just equalities.</p>
</blockquote>
<h3 id="Existential-Quantification"><a href="#Existential-Quantification" class="headerlink" title="Existential Quantification"></a>Existential Quantification</h3><p>To prove a statement of the form <code>∃x, P</code>, we must show that <code>P</code> holds for some specific choice of value for <code>x</code>,<br>known as the <strong>witness</strong> of the existential.</p>
<p>So we explicitly tell Coq which witness <code>t</code> we have in mind by invoking <code>exists t</code>.<br>then all occurences of that “type variable” would be replaced.</p>
<h4 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> four_is_even : <span class="built_in">exists</span> n : nat, <span class="number">4</span> = n + n.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">exists</span> <span class="number">2.</span> <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<h4 id="Elim"><a href="#Elim" class="headerlink" title="Elim"></a>Elim</h4><p>Below is an interesting question…by intros and destruct we can have equation <code>n = 4 + m</code> in hypotheses.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> exists_example_2 : <span class="keyword">forall</span> n,</span><br><span class="line">  (<span class="built_in">exists</span> m, n = <span class="number">4</span> + m) -&gt;</span><br><span class="line">  (<span class="built_in">exists</span> o, n = <span class="number">2</span> + o).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n [m Hm]. <span class="comment">(* note implicit [destruct] here *)</span></span><br><span class="line">  <span class="built_in">exists</span> (<span class="number">2</span> + m).</span><br><span class="line">  <span class="built_in">apply</span> Hm.  <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>



<h2 id="Programming-with-Propositions"><a href="#Programming-with-Propositions" class="headerlink" title="Programming with Propositions"></a>Programming with Propositions</h2><p>Considering writing a common recursive <code>is_in</code> for polymorphic lists.<br>(Though we dont have a polymorphic <code>=?</code> (<code>eqb</code>) defined yet) </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> is_in &#123;A : <span class="keyword">Type</span>&#125; (x : A) (l : list A) : bool :=</span><br><span class="line">  <span class="keyword">match</span> l <span class="built_in">with</span></span><br><span class="line">  | <span class="type">[] =&gt; false</span></span><br><span class="line">  | <span class="type">x</span>&#x27; :: l&#x27; =&gt; <span class="keyword">if</span> (x&#x27; =? x) <span class="keyword">then</span> true <span class="keyword">else</span> is_in x l&#x27;</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>Similarly, we can write this function but with disjunction and return a <code>Prop</code>!<br><em>so we can write function to generate&#x2F;create statements&#x2F;propositions!</em> (thx for the idea Prop is first-class)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> In &#123;A : <span class="keyword">Type</span>&#125; (x : A) (l : list A) : <span class="keyword">Prop</span> :=</span><br><span class="line">  <span class="keyword">match</span> l <span class="built_in">with</span></span><br><span class="line">  | <span class="type">[] =&gt; False</span></span><br><span class="line">  | <span class="type">x</span>&#x27; :: l&#x27; =&gt; x&#x27; = x ∨ In x l&#x27;</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>The whole thing I understood as a <em>type operator</em> (function in type level) and it’s <em>recursive</em>!</p>
<p>Coq dare to do that becuz its <em>total</em>, which is guarded by its <em>termination checker</em>.<br>un-total PL, if having this, would make its type system <em>Turing Complete</em> (thus having <em>Halting Problem</em>).<br>(Recursive Type like ADT&#x2F;GADT in ML&#x2F;Haskell is a limited form of recursion allowing no arbitray recursion.)</p>
<h3 id="In-map"><a href="#In-map" class="headerlink" title="In_map"></a>In_map</h3><p>I took this one since it’s like a formal version of <em>Property-based Tests</em>!.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> In_map :</span><br><span class="line">  <span class="keyword">forall</span> (A B : <span class="keyword">Type</span>) (f : A -&gt; B) (l : list A) (x : A),</span><br><span class="line">    In x l -&gt;</span><br><span class="line">    In (f x) (map f l).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> A B f l x.</span><br><span class="line">  <span class="built_in">induction</span> l <span class="built_in">as</span> [|<span class="type">x</span>&#x27; l&#x27; IHl&#x27;].</span><br><span class="line">  - <span class="comment">(* l = nil, contradiction *)</span></span><br><span class="line">    <span class="built_in">simpl</span>. <span class="built_in">intros</span> [].</span><br><span class="line">  - <span class="comment">(* l = x&#x27; :: l&#x27; *)</span></span><br><span class="line">    <span class="built_in">simpl</span>. <span class="built_in">intros</span> [H | <span class="type">H</span>].           <span class="comment">(* evaluating [In] gives us 2 cases:  *)</span></span><br><span class="line">    + <span class="built_in">rewrite</span> H. <span class="built_in">left</span>. <span class="built_in">reflexivity</span>.  <span class="comment">(* in head of l *)</span></span><br><span class="line">    + <span class="built_in">right</span>. <span class="built_in">apply</span> IHl&#x27;. <span class="built_in">apply</span> H.    <span class="comment">(* in tail of l*)</span></span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Q &amp; A: </p>
<ol>
<li><code>eq</code> is just another inductively defined and doesn’t have any computational content. (satisfication)</li>
<li>Why use <code>Prop</code> instead of <code>bool</code>? See <em>reflection</em> below.</li>
</ol>
</blockquote>
<h3 id="Drawbacks"><a href="#Drawbacks" class="headerlink" title="Drawbacks"></a>Drawbacks</h3><blockquote>
<p>In particular, it is subject to Coq’s usual restrictions regarding the definition of recursive functions,<br>e.g., the requirement that they be “obviously terminating.”</p>
</blockquote>
<blockquote>
<p>In the next chapter, we will see how to define propositions <em>inductively</em>,<br>a different technique with its own set of strengths and limitations.</p>
</blockquote>
<h2 id="Applying-Theorems-to-Arguments"><a href="#Applying-Theorems-to-Arguments" class="headerlink" title="Applying Theorems to Arguments."></a>Applying Theorems to Arguments.</h2><h3 id="Check-some-theorem-print-the-statement"><a href="#Check-some-theorem-print-the-statement" class="headerlink" title="Check some_theorem print the statement!"></a><code>Check some_theorem</code> print the statement!</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> plus_comm.</span><br><span class="line"><span class="comment">(* ===&gt; forall n m : nat, n + m = m + n *)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Coq prints the <em>statement</em> of the <code>plus_comm</code> theorem in the same way that it prints the <em>type</em> of any term that we ask it to Check. Why?</p>
</blockquote>
<p>Hmm…I just noticed that!!<br>But I should notice because <strong>Propositions are Types! (and terms are proof)</strong></p>
<h3 id="Proof-Object"><a href="#Proof-Object" class="headerlink" title="Proof Object"></a>Proof Object</h3><blockquote>
<p><em>proofs</em> as first-class objects.</p>
</blockquote>
<p>After <code>Qed.</code>, Coq defined they as <em>Proof Object</em> and the <em>type of this obj</em> is the statement of the theorem.</p>
<blockquote>
<p>Provable: some type is inhabited by some thing (having terms).</p>
</blockquote>
<p>So I guess when we apply theorems, Coq implicitly use the type of the Proof Object. (it’s already type abstraction)<br>…we will get to there later at ProofObject chapter.</p>
<h3 id="Apply-theorem-as-function"><a href="#Apply-theorem-as-function" class="headerlink" title="Apply theorem as function"></a>Apply theorem as function</h3><blockquote>
<p><code>rewrite</code> select variables greedily by default</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> plus_comm3_take3 :</span><br><span class="line">  ∀x y z, x + (y + z) = (z + y) + x.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> x y z.</span><br><span class="line">  <span class="built_in">rewrite</span> plus_comm.</span><br><span class="line">  <span class="built_in">rewrite</span> (plus_comm y z).     <span class="comment">(* we can explicitly provide type var! *)</span></span><br><span class="line">  <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p><code>x y z</code> were some type var and <em>instantiated to values</em> by <code>intros</code>, e.g. <code>x, y, z:nat</code><br>but we can explicilty pass in to <code>plus_comm</code>, which is a forall type abstraction! (<code>Δ n m. (eq (n + m) (m + n))</code>) </p>
<blockquote>
<p>there must be something there in Proof Object so we can apply <em>values</em> to a <em>type-level function</em></p>
</blockquote>
<h2 id="Coq-vs-Set-Theory"><a href="#Coq-vs-Set-Theory" class="headerlink" title="Coq vs. Set Theory"></a>Coq vs. Set Theory</h2><p>Coq’s logical core, <em>the Calculus of Inductive Constructions</em>, is a <em>metalanguage for math</em>, but differs from other foundations of math e.g. ZFC Set Theory</p>
<h3 id="Functional-Extensionality"><a href="#Functional-Extensionality" class="headerlink" title="Functional Extensionality"></a>Functional Extensionality</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(∀x, f x = g x) → f = g</span><br><span class="line"></span><br><span class="line">∃f g, (∀x, f x = g x) → f = g</span><br><span class="line"></span><br><span class="line">∃f g, (∀x, f x = g x) ∧ f != g    <span class="comment">(* negation, consistent but not interesting... *)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>In common math practice, two functions <code>f</code> and <code>g</code> are considered equal if they produce the same outputs.<br>This is known as the principle of <em>functional extensionality</em>.</p>
</blockquote>
<blockquote>
<p>Informally speaking, an “extensional property” is one that pertains to an object’s observable behavior.<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Extensionality">https://en.wikipedia.org/wiki/Extensionality</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Extensional_and_intensional_definitions">https://en.wikipedia.org/wiki/Extensional_and_intensional_definitions</a>?</p>
</blockquote>
<p>This is not built-in Coq, but we can add them as Axioms.<br>Why not add everything?</p>
<blockquote>
<ol>
<li>One or multiple axioms combined might render <em>inconsistency</em>.</li>
<li>Code extraction might be problematic</li>
</ol>
</blockquote>
<blockquote>
<p>Fortunately, it is known that adding functional extensionality, in particular, is consistent.<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consistency">consistency</a>:<br>   a consistent theory is one that does not contain a contradiction.</p>
</blockquote>
<h3 id="Adding-Axioms"><a href="#Adding-Axioms" class="headerlink" title="Adding Axioms"></a>Adding Axioms</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Axiom</span> functional_extensionality : <span class="keyword">forall</span> &#123;X Y: <span class="keyword">Type</span>&#125;</span><br><span class="line">                                    &#123;f g : X -&gt; Y&#125;,</span><br><span class="line">  (<span class="keyword">forall</span> (x:X), f x = g x) -&gt; f = g.</span><br></pre></td></tr></table></figure>

<p>It’s like <code>Admitted.</code> but alerts we’re not going to fill in later. </p>
<h3 id="Exercise-Proving-Reverse-with-app-and-with-cons-are-fn-exensionally-equivalent"><a href="#Exercise-Proving-Reverse-with-app-and-with-cons-are-fn-exensionally-equivalent" class="headerlink" title="Exercise - Proving Reverse with app and with cons are fn-exensionally equivalent."></a>Exercise - Proving Reverse with <code>app</code> and with <code>cons</code> are fn-exensionally equivalent.</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> rev_append &#123;X&#125; (l1 l2 : list X) : list X :=</span><br><span class="line">  <span class="keyword">match</span> l1 <span class="built_in">with</span></span><br><span class="line">  | <span class="type">[] =&gt; l2</span></span><br><span class="line">  | <span class="type">x</span> :: l1&#x27; =&gt; rev_append l1&#x27; (x :: l2)</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Definition</span> tr_rev &#123;X&#125; (l : list X) : list X :=</span><br><span class="line">  rev_append l [].</span><br></pre></td></tr></table></figure>

<p>BTW, this version is <code>tail recursive</code> becuz the recursive call is the last operation needs to performed.<br>(In <code>rev</code> i.e. <code>rev t ++ [h]</code>, recursive call is a argument of function <code>++</code> and we are CBV.)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> tr_rev_correct : <span class="keyword">forall</span> X, @tr_rev X = @rev X.</span><br></pre></td></tr></table></figure>



<h3 id="Propositions-and-Booleans"><a href="#Propositions-and-Booleans" class="headerlink" title="Propositions and Booleans"></a>Propositions and Booleans</h3><blockquote>
<p>We’ve seen two different ways of expressing logical claims in Coq: </p>
<ol>
<li>with booleans     (of type <code>bool</code>),  ; computational way</li>
<li>with propositions (of type <code>Prop</code>).  ; logical way</li>
</ol>
</blockquote>
<p>There’re two ways to define 42 is even:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> even_42_bool : evenb <span class="number">42</span> = true.</span><br><span class="line"><span class="keyword">Example</span> even_42_prop : ∃k, <span class="number">42</span> = <span class="built_in">double</span> k.</span><br></pre></td></tr></table></figure>

<p>We wanna show there are <em>interchangable</em>.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> even_bool_prop : ∀n,</span><br><span class="line">  evenb n = true ↔ ∃k, n = <span class="built_in">double</span> k.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>In view of this theorem, we say that the<br>boolean computation <code>evenb n</code> <em>reflects</em> the truth of the proposition <code>∃ k, n = double k</code>.</p>
</blockquote>
<p>We can futhur general this to any equations representing as <code>bool</code> or <code>Prop</code>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> eqb_eq : ∀n1 n2 : nat,</span><br><span class="line">  n1 =? n2 = true ↔ n1 = n2.</span><br></pre></td></tr></table></figure>

<h4 id="Notes-on-Computability"><a href="#Notes-on-Computability" class="headerlink" title="Notes on Computability."></a>Notes on Computability.</h4><blockquote>
<p>However, even they are equivalent from a purely logical perspective,<br>they may not be equivalent <code>operationally</code>.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fail <span class="keyword">Definition</span> is_even_prime n :=</span><br><span class="line">  <span class="keyword">if</span> n = <span class="number">2</span> <span class="keyword">then</span> true</span><br><span class="line">  <span class="keyword">else</span> false.</span><br><span class="line"></span><br><span class="line">Error: The term <span class="string">&quot;n = 2&quot;</span> has type <span class="string">&quot;Prop&quot;</span> which is not a (co-)inductive type.</span><br></pre></td></tr></table></figure>

<p><code>=</code>, or <code>eq</code>, as any function in Coq, need to be computable and total. And we have no way to tell <em>whether any given proposition is true or false</em>. (…We can only naturally deduce things are inductively defined)</p>
<blockquote>
<p>As a consequence, Prop in Coq does not have a universal case analysis operation telling whether any given proposition is true or false, since such an operation would allow us to write non-computable functions.</p>
</blockquote>
<blockquote>
<p>Although general non-computable properties cannot be phrased as boolean computations, it is worth noting that even many computable properties are easier to express using Prop than bool, since recursive function definitions are subject to significant restrictions in Coq.</p>
</blockquote>
<p>E.g. Verifying Regular Expr in next chapter. </p>
<blockquote>
<p>Doing the same with <code>bool</code> would amount to writing a <em>full regular expression matcher</em> (so we can execute the regex).</p>
</blockquote>
<h4 id="Proof-by-Reflection"><a href="#Proof-by-Reflection" class="headerlink" title="Proof by Reflection!"></a>Proof by Reflection!</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(* Logically *)</span></span><br><span class="line"><span class="keyword">Example</span> even_1000 : ∃k, <span class="number">1000</span> = <span class="built_in">double</span> k.</span><br><span class="line"><span class="keyword">Proof</span>. ∃<span class="number">500.</span> <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">(* Computationally *)</span></span><br><span class="line"><span class="keyword">Example</span> even_1000&#x27; : evenb <span class="number">1000</span> = true.</span><br><span class="line"><span class="keyword">Proof</span>. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">(* Prove logical version by reflecting in computational version *)</span></span><br><span class="line"><span class="keyword">Example</span> even_1000&#x27;&#x27; : ∃k, <span class="number">1000</span> = <span class="built_in">double</span> k.</span><br><span class="line"><span class="keyword">Proof</span>. <span class="built_in">apply</span> even_bool_prop. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>As an extreme example, the Coq proof of the famous <em>4-color theorem</em> uses reflection to reduce the analysis of hundreds of different cases to a boolean computation.</p>
</blockquote>
<h3 id="Classical-vs-Constructive-Logic"><a href="#Classical-vs-Constructive-Logic" class="headerlink" title="Classical vs. Constructive Logic"></a>Classical vs. Constructive Logic</h3><p>…</p>
<h2 id="Future-Schedule"><a href="#Future-Schedule" class="headerlink" title="Future Schedule"></a>Future Schedule</h2><blockquote>
<p>Proof got messier!<br>Lean on your past PLT experience</p>
</blockquote>
<p>As discussion leader</p>
<ul>
<li>having many materials now</li>
<li>selected troublesome and interesting ones</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
              <a href="/tags/LF-%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80/" rel="tag"># LF (逻辑基础)</a>
              <a href="/tags/SF-%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/" rel="tag"># SF (软件基础)</a>
              <a href="/tags/Coq/" rel="tag"># Coq</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/read_sf_lf/2019-01-07-sf-lf-07-indprop/" rel="prev" title="「SF-LC」7 Ind Prop">
                  <i class="fa fa-angle-left"></i> 「SF-LC」7 Ind Prop
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/read_sf_lf/2019-01-05-sf-lf-05-tactics/" rel="next" title="「SF-LC」5 Tactics">
                  「SF-LC」5 Tactics <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">vvbuys</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
