<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="baidu-site-verification" content="codeva-6wmKWl5hmx" />
<meta name="bytedance-verification-code" content="GcOf/MpQ8shZ5Hh/2hvr" />
<meta name="google-site-verification" content="wivqPhuFdISMEKkFZjOWHPYJGSvd716d9R7Bwy2Jj-A" />
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4636539228226058"
     crossorigin="anonymous"></script>
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.vvbuys.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="LeetCode题目 相关题目类型 相关链接    455 分发饼干（简单难度） 383. 赎金信 - 力扣（LeetCode） (leetcode-cn.com)   为了了满足更多的小孩，就不要造成饼干尺寸的浪费。 大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。 这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能">
<meta property="og:type" content="article">
<meta property="og:title" content="「算法刷题」贪心算法的相关经典题目">
<meta property="og:url" content="https://www.vvbuys.com/2021-10-29-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/index.html">
<meta property="og:site_name" content="VVbuys Blog">
<meta property="og:description" content="LeetCode题目 相关题目类型 相关链接    455 分发饼干（简单难度） 383. 赎金信 - 力扣（LeetCode） (leetcode-cn.com)   为了了满足更多的小孩，就不要造成饼干尺寸的浪费。 大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。 这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211029212703299.png">
<meta property="article:published_time" content="2021-10-29T00:00:00.000Z">
<meta property="article:modified_time" content="2024-02-02T01:00:55.431Z">
<meta property="article:author" content="vvbuys">
<meta property="article:tag" content="算法刷题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211029212703299.png">


<link rel="canonical" href="https://www.vvbuys.com/2021-10-29-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.vvbuys.com/2021-10-29-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/","path":"2021-10-29-【算法刷题】贪心算法的相关经典题目/","title":"「算法刷题」贪心算法的相关经典题目"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>「算法刷题」贪心算法的相关经典题目 | VVbuys Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">VVbuys Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">standalone Linux lover</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">vvbuys</p>
  <div class="site-description" itemprop="description">Share some post and some issue for linux program</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">265</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2021-10-29-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbuys Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="「算法刷题」贪心算法的相关经典题目 | VVbuys Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          「算法刷题」贪心算法的相关经典题目
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-29T00:00:00+00:00">2021-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-02 01:00:55" itemprop="dateModified" datetime="2024-02-02T01:00:55+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>455</td>
<td>分发饼干（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ransom-note/">383. 赎金信 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>为了了满足更多的小孩，就不要造成饼干尺寸的浪费。</p>
<p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p>
<p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p>
<p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p>
<p>然后从后向前遍历小孩数组，用大饼干优先满足 </p>
<p><img src="C:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211029212703299.png" alt="image-20211029212703299"></p>
<p>这个例子可以看出饼干9只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 饼干数组的下标</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出我用了一个index来控制饼干数组的遍历，遍历饼干并没有再起一个for循环，而是采用自减的方式，这也是常用的技巧。</p>
<p>有的同学看到要遍历两个数组，就想到用两个for循环，那样逻辑其实就复杂了。</p>
<p><strong>也可以换一个思路，小饼干先喂饱小胃口</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; g.<span class="built_in">size</span>() &amp;&amp; g[index] &lt;= s[i])&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1005</td>
<td>K次取反后最大化的数组和（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>本题思路其实比较好想了，如何可以让数组和最大呢？</p>
<p>贪心的思路，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。</p>
<p>局部最优可以推出全局最优。</p>
<p>那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。</p>
<p>那么又是一个贪心：局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），全局最优：整个 数组和 达到最大。</p>
<p>虽然这道题目大家做的时候，可能都不会去想什么贪心算法，一鼓作气，就AC了。</p>
<p><strong>我这里其实是为了给大家展现出来 经常被大家忽略的贪心思路，这么一道简单题，就用了两次贪心！</strong></p>
<p>那么本题的解题步骤为：</p>
<ul>
<li>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li>
<li>第二步：从前向后遍历，遇到负数将其变为正数，同时K–</li>
<li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li>
<li>第四步：求和</li>
</ul>
<p>对应C++代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">static bool cmp(int a,int b)&#123;</span><br><span class="line">    return abs(a)&gt;abs(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int largestSumAfterKNegations(vector&lt;int&gt;&amp; A, int K) &#123;</span><br><span class="line">        //将数组按照绝对值大小，从大到小排列</span><br><span class="line">        sort(A.begin(),A.end(),cmp);</span><br><span class="line">        //如果数组中有负数，转为正数，同时k--</span><br><span class="line">        for(int i=0;i&lt;A.size()-1;i++)&#123;</span><br><span class="line">            if(A[i]&lt;0&amp;&amp;K&gt;0)&#123;</span><br><span class="line">                A[i]*=-1;</span><br><span class="line">                K--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果k不为0，把数组中最小的数反复乘以-1，直到k用完</span><br><span class="line">        //K%2==0的话，数组中的数还是原数</span><br><span class="line">        if(K%2==1)&#123;</span><br><span class="line">            A[A.size()-1]*=-1;</span><br><span class="line">        &#125;</span><br><span class="line">        //求和</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int a:A)&#123;</span><br><span class="line">            res+=a;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>860</td>
<td>柠檬水找零（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lemonade-change/">860. 柠檬水找零 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>本题只需维护三种金额的数量：5,10,20，</p>
<p>情况一：账单是5，直接收下。</p>
<p>情况二：账单是10，消耗一个5，增加一个10</p>
<p>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</p>
<p>（收款20时，局部最优：优先消耗10和5，完成本次找零。少消耗5，因为5可以给10和20找零。全局最优：完成全部账单的找零。</p>
<p>局部最优可以推出全局最优，且找不到反例，就可以尝试贪心算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five=<span class="number">0</span>,ten=<span class="number">0</span>,twenty=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> bill:bills)&#123;</span><br><span class="line">            <span class="comment">//收到5</span></span><br><span class="line">            <span class="keyword">if</span>(bill==<span class="number">5</span>)&#123;</span><br><span class="line">                five++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//收到10</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bill==<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(five&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ten++;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//收到20</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bill==<span class="number">20</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(five&gt;=<span class="number">1</span>&amp;&amp;ten&gt;=<span class="number">1</span>)&#123;<span class="comment">//优先用10来找零</span></span><br><span class="line">                    five--;</span><br><span class="line">                    ten--;</span><br><span class="line">                    twenty++;<span class="comment">//可以不记录20块钱的个数，不用20找零</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(five&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                    five-=<span class="number">3</span>;</span><br><span class="line">                    twenty++;<span class="comment">//可以不记录20块钱的个数，不用20找零</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>53</td>
<td>最大子序和（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p>
<p>全局最优：选取最大“连续和”</p>
<p>遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。</p>
<p>中间的最大和由result记录下来了。</p>
<p>题目中的答案有个示例【-2，-1】</p>
<p>if(result&lt;count)和if(count&lt;&#x3D;0)，写的时候我颠倒了，会改变了count的值，res就记录不到正确的最大值了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MIN;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            count+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(result&lt;count)&#123;</span><br><span class="line">                result=count;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(count&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>452</td>
<td>用最少数量的箭引爆气球（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少</p>
<p>试一下举反例，发现没有这种情况。</p>
<p>那么就试一试贪心吧！</p>
<p>局部最优：当气球出现重叠，一起射，所用弓箭最少。</p>
<p>全局最优：把所有气球射爆所用弓箭最少。</p>
<p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。用到sort函数</p>
<p>这里的排序不是简单的对整数排序，是按照数组的第一元素从小到大排序，不能简单地用sort(nums.begin(),nums.end()),</p>
<p>而是用sort(nums.begin(),nums.end(),cmp),cmp函数必须加上static，返回值是bool类型。例如：</p>
<p>static bool cmp(vector<int>&amp; a,vector<int>&amp; b){</p>
<p>​    return a[0]&lt;b[0];</p>
<p>  }</p>
<p>传入参数时，如果是数组，用引用&amp;不会另外开辟内存，而是直接用原数组的数进行运算。不用引用&amp;，会为参数另外开辟内存，每次用cmp函数都要花时间开辟内存，可能会运行超出时间限制。</p>
<p><strong>按照气球的起始位置排序，从前向后遍历气球数组</strong>，尽可能让气球重复，前两个区间：比较第一个的右边界&gt;&#x3D;第二个的左边界，则气球重叠。有两个已经重叠，再比较第三个时，要比较前两个区间的最小右边界和第三个区间的左边界。因为如果想三个都重叠，必须满足最小的右边界（画图可以看出）。</p>
<p>前两个重叠时，不用弓箭加一，因为刚开始默认弓箭为1（因为数组数&gt;&#x3D;1）.不重叠，那肯定需要再有一个弓箭射后面的气球，这时弓箭数加一。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*输入一个二维数组，输出一个整数*/</span></span><br><span class="line">        <span class="keyword">if</span>(points.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先将二维数组排序</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> result=<span class="number">1</span>;<span class="comment">// 需要几只箭</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;points.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 会发生重叠</span></span><br><span class="line">            <span class="keyword">if</span>(points[i<span class="number">-1</span>][<span class="number">1</span>]&gt;=points[i][<span class="number">0</span>])&#123;</span><br><span class="line">                points[i][<span class="number">1</span>]=<span class="built_in">min</span>(points[i][<span class="number">1</span>],points[i<span class="number">-1</span>][<span class="number">1</span>]);<span class="comment">// 更新当前气球的右边界</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有重叠</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>435</td>
<td>无重叠区间（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>本题与i452的区别：</p>
<p>移除重叠区间，按照右边界从小到大排序，如果前一个的右边界大于下一个的左边界，则算是重叠，然后保留重叠两个区间的右边界最小值（较大的可能会重叠更多区间，题目要求是移除区间的最小数量）</p>
<p>cmp两种都可以，第二种，考虑了如果两个元素相等，再怎么判断。但a[0]&lt;b[0];应该会对相等情况给一个结果应该。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<pre><code> static bool cmp(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;
    if(a[0]==b[0])&#123;
         return a[1]&lt;b[1];
    &#125;
    return a[0]&lt;b[0];
&#125;
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*输入一个二维数组，输出一个整数*/</span></span><br><span class="line">        <span class="keyword">if</span>(points.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先将二维数组排序</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> result=<span class="number">1</span>;<span class="comment">// 需要几只箭</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;points.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 会发生重叠</span></span><br><span class="line">            <span class="keyword">if</span>(points[i<span class="number">-1</span>][<span class="number">1</span>]&gt;=points[i][<span class="number">0</span>])&#123;</span><br><span class="line">                points[i][<span class="number">1</span>]=<span class="built_in">min</span>(points[i][<span class="number">1</span>],points[i<span class="number">-1</span>][<span class="number">1</span>]);<span class="comment">// 更新当前气球的右边界</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有重叠</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>56</td>
<td>合并区间（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="comment">/*输入一个二维数组，输出一个二维数组*/</span></span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对数组进行排序</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">// 标记最后一个区间有没有合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 当相邻区间重叠时，合并，当前区间i就是合并后的区间</span></span><br><span class="line">            <span class="type">int</span> start=intervals[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> end = intervals[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(i&lt;intervals.<span class="built_in">size</span>()&amp;&amp;end&gt;=intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                end = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>],end);</span><br><span class="line">                <span class="keyword">if</span> (i == intervals.<span class="built_in">size</span>() - <span class="number">1</span>) flag = <span class="literal">true</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123;start,end&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后一个区间没有和前一个区间重叠，将需单独加入result</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123;intervals[intervals.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>], intervals[intervals.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><em>LeetCode题目</em>*</th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>55</td>
<td>跳跃游戏（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/submissions/">55. 跳跃游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>该题判断是否能跳到终点。</p>
<p>刚看到本题一开始可能想：当前位置元素如果是3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？</p>
<p>其实跳几步无所谓，关键在于可跳的覆盖范围！不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。</p>
<p>这个范围内，别管是怎么跳的，反正一定可以跳过来。</p>
<p><strong>那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！</strong></p>
<p>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p>
<p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 只有一个元素，就是能达到</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cover; i++) &#123; <span class="comment">// 注意这里是小于等于cover</span></span><br><span class="line">            cover = <span class="built_in">max</span>(i + nums[i], cover);</span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 说明可以覆盖到终点了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>题目</th>
<th>相关链接</th>
</tr>
</thead>
<tbody><tr>
<td>763划分字母区间（中等难度）</td>
<td></td>
</tr>
</tbody></table>
<p>记录每个字符在数组中出现的最远距离，找到之前遍历过的所有字母的最远边界，这个边界点就是分割点。前面出现的所有字母最远就到这个边界。</p>
<p>分为两步：</p>
<p>1 统计每个字符出现的最远位置</p>
<p>2 从头遍历字符，更新字符出现的最远下表，如果找到字符最远出现位置下表和当前下标相等，则找到了分割点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 记录每个字符出现的最远下标</span></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">27</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hash[s[i]-<span class="string">&#x27;a&#x27;</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            right=<span class="built_in">max</span>(right,hash[s[i]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(i==right)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(right-left+<span class="number">1</span>);</span><br><span class="line">                left=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><em>LeetCode题目</em>*</th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>135</td>
<td>（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/submissions/">55. 跳跃游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼。</strong></p>
<p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p>
<p>此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p>
<p>2.再确定左孩子大于右孩子的情况（从后向前遍历）</p>
<p>遍历顺序这里有同学可能会有疑问，为什么不能从前向后遍历呢？</p>
<p>因为如果从前向后遍历，根据 ratings[i + 1] 来确定 ratings[i] 对应的糖果，那么每次都不能利用上前一次的比较结果了。</p>
<p>如果 ratings[i] &gt; ratings[i + 1]，此时candyVec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量），一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量）。</p>
<p>那么又要贪心了，局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量即大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p>
<p>整体代码：     </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyVec</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从前向后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从后向前</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) &#123;</span><br><span class="line">                candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计结果</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candyVec.<span class="built_in">size</span>(); i++) result += candyVec[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/" rel="tag"># 算法刷题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021-10-29-%E3%80%90%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB%E3%80%91%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/" rel="prev" title="「论文分享」自适应神经树">
                  <i class="fa fa-angle-left"></i> 「论文分享」自适应神经树
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021-10-29-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/" rel="next" title="「算法刷题」哈希表的相关经典题目">
                  「算法刷题」哈希表的相关经典题目 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">vvbuys</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
