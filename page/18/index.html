<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="baidu-site-verification" content="codeva-6wmKWl5hmx" />
<meta name="bytedance-verification-code" content="GcOf/MpQ8shZ5Hh/2hvr" />
<meta name="google-site-verification" content="wivqPhuFdISMEKkFZjOWHPYJGSvd716d9R7Bwy2Jj-A" />
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4636539228226058"
     crossorigin="anonymous"></script>
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.vvbuys.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Share some post and some issue for linux program">
<meta property="og:type" content="website">
<meta property="og:title" content="VVbugs Blog">
<meta property="og:url" content="https://www.vvbuys.com/page/18/index.html">
<meta property="og:site_name" content="VVbugs Blog">
<meta property="og:description" content="Share some post and some issue for linux program">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="vvbuys">
<meta property="article:tag" content="Linux hyprland Python Rust Golang javascript">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.vvbuys.com/page/18/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/18/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>VVbugs Blog - standalone Linux lover</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">VVbugs Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">standalone Linux lover</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">vvbuys</p>
  <div class="site-description" itemprop="description">Share some post and some issue for linux program</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">265</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_lf/2019-01-02-sf-lf-02-induction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_lf/2019-01-02-sf-lf-02-induction/" class="post-title-link" itemprop="url">「SF-LC」2 Induction</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Review-only-in-slide"><a href="#Review-only-in-slide" class="headerlink" title="Review (only in slide)"></a>Review (only in slide)</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> review2: ∀b, (orb true b) = true.</span><br><span class="line"><span class="keyword">Theorem</span> review3: ∀b, (orb b true) = true.</span><br></pre></td></tr></table></figure>

<p>Whether or not it can be just <code>simpl.</code> depending on the definition of <code>orb</code>.</p>
<p>In <em>Proof Engineering</em>, we probably won’t need to include <code>review2</code> but need to include <code>review3</code> in library.</p>
<blockquote>
<p>Why we have <code>simpl.</code> but not <code>refl.</code> ?</p>
</blockquote>
<h2 id="Proving-0-is-a-“neutral-element”-for-additive-identity"><a href="#Proving-0-is-a-“neutral-element”-for-additive-identity" class="headerlink" title="Proving 0 is a “neutral element” for + (additive identity)"></a>Proving <code>0</code> is a “neutral element” for <code>+</code> (additive identity)</h2><h3 id="Proving-0-n-n"><a href="#Proving-0-n-n" class="headerlink" title="Proving 0 + n = n"></a>Proving <code>0 + n = n</code></h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> plus_O_n : <span class="keyword">forall</span> n : nat, <span class="number">0</span> + n = n.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n. <span class="built_in">simpl</span>. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>This can be simply proved by <em>simplication</em> bcuz the definition of <code>+</code> is defined by pattern matching against 1st operand:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> plus (n : nat) (m : nat) : nat :=</span><br><span class="line">  <span class="keyword">match</span> n <span class="built_in">with</span></span><br><span class="line">    | <span class="type">O</span> ⇒ m</span><br><span class="line">    | <span class="type">S</span> n&#x27; ⇒ S (plus n&#x27; m)</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>We can observe that if <code>n</code> is <code>0</code>(<code>O</code>), no matter <code>m</code> is, it returns <code>m</code> as is.</p>
<h3 id="Proving-n-0-n"><a href="#Proving-n-0-n" class="headerlink" title="Proving n + 0 = n"></a>Proving <code>n + 0 = n</code></h3><h4 id="1st-try-Simplication"><a href="#1st-try-Simplication" class="headerlink" title="1st try: Simplication"></a>1st try: Simplication</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> plus_O_n_1 : <span class="keyword">forall</span> n : nat,  n + <span class="number">0</span> = n.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n.</span><br><span class="line">  <span class="built_in">simpl</span>. <span class="comment">(* Does nothing! *)</span></span><br><span class="line"><span class="keyword">Abort</span>.</span><br></pre></td></tr></table></figure>

<p>This cannot be proved by <em>simplication</em> bcuz <code>n</code> is unknown so <em>unfold</em> the definition <code>+</code> won’t be able to simplify anything.</p>
<h4 id="2nd-try-Case-Analysis"><a href="#2nd-try-Case-Analysis" class="headerlink" title="2nd try: Case Analysis"></a>2nd try: Case Analysis</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> plus_n_O_2 : ∀n:nat,</span><br><span class="line">  n = n + <span class="number">0.</span></span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n. <span class="built_in">destruct</span> n <span class="built_in">as</span> [| <span class="type">n</span>&#x27;] eqn:E.</span><br><span class="line">  - <span class="comment">(* n = 0 *)</span></span><br><span class="line">    <span class="built_in">reflexivity</span>. <span class="comment">(* so far so good... *)</span></span><br><span class="line">  - <span class="comment">(* n = S n&#x27; *)</span></span><br><span class="line">    <span class="built_in">simpl</span>. <span class="comment">(* ...but here we are stuck again *)</span></span><br><span class="line"><span class="keyword">Abort</span>.</span><br></pre></td></tr></table></figure>

<p>Our 2nd try is to use <em>case analysis</em> (<code>destruct</code>), but the proof stucks in <em>inductive case</em> since <code>n</code> can be infinitely large (destructed)</p>
<h4 id="Induction-to-the-resucue"><a href="#Induction-to-the-resucue" class="headerlink" title="Induction to the resucue"></a>Induction to the resucue</h4><blockquote>
<p>To prove interesting facts about numbers, lists, and other inductively defined sets, we usually need a more powerful reasoning principle: induction.</p>
</blockquote>
<p>Princeple of induction over natural numbers (i.e. <em>mathematical induction</em>)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(<span class="number">0</span>); ∀n&#x27; P(n&#x27;) → P(S n&#x27;)  ====&gt;  P(n)</span><br></pre></td></tr></table></figure>

<p>In Coq, like <code>destruct</code>, <code>induction</code> break <code>P(n)</code> into 2 subgoals:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> plus_n_O : ∀n:nat, n = n + <span class="number">0.</span></span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n. <span class="built_in">induction</span> n <span class="built_in">as</span> [| <span class="type">n</span>&#x27; IHn&#x27;].</span><br><span class="line">  - <span class="comment">(* n = 0 *)</span> <span class="built_in">reflexivity</span>.</span><br><span class="line">  - <span class="comment">(* n = S n&#x27; *)</span> <span class="built_in">simpl</span>. <span class="built_in">rewrite</span> &lt;- IHn&#x27;. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>


<h2 id="Proving-n-n-0"><a href="#Proving-n-n-0" class="headerlink" title="Proving n - n = 0"></a>Proving <code>n - n = 0</code></h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> minus_diag : ∀n,</span><br><span class="line">  minus n n = <span class="number">0.</span></span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="comment">(* WORKED IN CLASS *)</span></span><br><span class="line">  <span class="built_in">intros</span> n. <span class="built_in">induction</span> n <span class="built_in">as</span> [| <span class="type">n</span>&#x27; IHn&#x27;].</span><br><span class="line">  - <span class="comment">(* n = 0 *)</span></span><br><span class="line">    <span class="built_in">simpl</span>. <span class="built_in">reflexivity</span>.</span><br><span class="line">  - <span class="comment">(* n = S n&#x27; *)</span></span><br><span class="line">    <span class="built_in">simpl</span>. <span class="built_in">rewrite</span> → IHn&#x27;. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span></span><br></pre></td></tr></table></figure>

<p>Noticed that the definition of <code>minus</code>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> minus (n m:nat) : nat :=</span><br><span class="line">  <span class="keyword">match</span> n, m <span class="built_in">with</span></span><br><span class="line">  | <span class="type">O</span>   , <span class="keyword">_</span>    =&gt; O</span><br><span class="line">  | <span class="type">S</span> <span class="keyword">_</span> , O    =&gt; n</span><br><span class="line">  | <span class="type">S</span> n&#x27;, S m&#x27; =&gt; minus n&#x27; m&#x27;</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a><code>rewrite</code></h2><p><code>rewrite</code> would do a (DFS) preorder traversal in the syntax tree.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_lf/2019-01-03-sf-lf-03-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_lf/2019-01-03-sf-lf-03-list/" class="post-title-link" itemprop="url">「SF-LC」3 List</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Pair-of-Numbers"><a href="#Pair-of-Numbers" class="headerlink" title="Pair of Numbers"></a>Pair of Numbers</h2><p>Q: Why name <code>inductive</code>?<br>A: Inductive means <em>building things bottom-up</em>, it doesn’t have to self-referencial (recursive)<br>(see below <code>induction on lists</code> as well.)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> natprod : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">pair</span> (n1 n2 : nat).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;( x , y )&quot;</span> := (pair x y).</span><br></pre></td></tr></table></figure>

<p>Proof on pair cannot simply <code>simpl.</code></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> surjective_pairing_stuck : ∀(p : natprod),</span><br><span class="line">  p = (fst p, snd p).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">simpl</span>. <span class="comment">(* Doesn&#x27;t reduce anything! *)</span></span><br><span class="line"><span class="keyword">Abort</span>.</span><br></pre></td></tr></table></figure>

<p>We have to <em>expose the structure</em>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> surjective_pairing : ∀(p : natprod),</span><br><span class="line">  p = (fst p, snd p).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> p. <span class="built_in">destruct</span> p <span class="built_in">as</span> [n m**. <span class="built_in">simpl</span>. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>It only generate <strong>one subgoal</strong>, becasue</p>
<blockquote>
<p>That’s because natprods can only be constructed in one way.</p>
</blockquote>
<h3 id="My-take-on-destruct"><a href="#My-take-on-destruct" class="headerlink" title="My take on destruct"></a>My take on <code>destruct</code></h3><p><code>destruct</code> </p>
<ul>
<li>destruct <code>bool</code> to <code>true</code> and <code>false</code></li>
<li>destruct <code>nat</code>  to <code>O</code> and <code>S n&#39;</code> (inductively defined)</li>
<li>destruct <code>pair</code> to <code>(n, m)</code></li>
</ul>
<p>The <strong>prove by case analysis (exhaustive)</strong> is just an application of the idea of <em>destruction</em>! </p>
<p>the idea simply <em>destruct</em> the data type into its data constructors (representing ways of constructing this data)</p>
<ul>
<li>Java class has only 1 way to construct (via its constructor)</li>
<li>Scala case class then have multiple way to construct</li>
</ul>
<h2 id="Lists-of-Numbers"><a href="#Lists-of-Numbers" class="headerlink" title="Lists of Numbers"></a>Lists of Numbers</h2><blockquote>
<p>Generalizing the definition of pairs</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> natlist : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">nil</span></span><br><span class="line">  | <span class="type">cons</span> (n : nat) (l : natlist).</span><br></pre></td></tr></table></figure>

<p>The ability of quosiquotation using <code>Notation</code> is awesome:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;x :: l&quot;</span> := (cons x l) (<span class="built_in">at</span> level <span class="number">60</span>, <span class="built_in">right</span> associativity).</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;[ ]&quot;</span> := nil.</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;[ x ; .. ; y ]&quot;</span> := (cons x .. (cons y nil) ..).</span><br></pre></td></tr></table></figure>

<p>It’s exactly like OCaml, even for <code>;</code>, <code>at level 60</code> means it’s tightly than <code>+ at level 50</code> .</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;x ++ y&quot;</span> := (app x y) (<span class="built_in">right</span> associativity, <span class="built_in">at</span> level <span class="number">60</span>).</span><br></pre></td></tr></table></figure>
<p>Instead of SML&#x2F;OCaml’s <code>@</code>, Coq chooses Haskell’s <code>++</code>.</p>
<h3 id="hd-with-default"><a href="#hd-with-default" class="headerlink" title="hd with default"></a><code>hd</code> with default</h3><p>Coq function (for some reason) has to be <strong>total</strong>, so <code>hd</code> require a <code>default</code> value as 1st argument:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> hd (default:nat) (l:natlist) : nat :=</span><br><span class="line">  <span class="keyword">match</span> l <span class="built_in">with</span></span><br><span class="line">  | <span class="type">nil</span> ⇒ default</span><br><span class="line">  | <span class="type">h</span> :: t ⇒ h</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>


<h2 id="Induction-on-Lists"><a href="#Induction-on-Lists" class="headerlink" title="Induction on Lists."></a>Induction on Lists.</h2><p>The definition of <em>inductive defined set</em></p>
<blockquote>
<p>Each Inductive declaration defines a set of data values that can be <strong>built up</strong> using the declared constructors:</p>
<ul>
<li>a boolean can be either true or false;</li>
<li>a number can be either O or S applied to another number; </li>
<li>a list can be either nil or cons applied to a number and a list.</li>
</ul>
</blockquote>
<p>The reverse: reasoning <em>inductive defined sets</em></p>
<blockquote>
<p>Moreover, applications of the declared constructors to one another are the<br><strong>only</strong> possible shapes that elements of an inductively defined set can have,<br>and this fact directly gives rise to a way of reasoning about inductively defined sets: </p>
<ul>
<li>a number is either O or else it is S applied to some smaller number; </li>
<li>a list is either nil or else it is cons applied to some number and some smaller list;</li>
</ul>
</blockquote>
<p>Reasoning lists</p>
<blockquote>
<p>if we have in mind some proposition <code>P</code> that mentions a list <code>l</code> and we want to argue that <code>P</code> holds for <em>all</em> lists,<br>we can reason as follows</p>
<ol>
<li>First, show that <code>P</code> is <code>true</code> of <code>l</code> when <code>l</code> is <code>nil</code>.</li>
<li>Then show that <code>P</code> is true of <code>l</code> when <code>l</code> is <code>cons n l&#39;</code> for some number <code>n</code> and some smaller list <code>l&#39;</code>, assuming that <code>P</code> is <code>true</code> for <code>l&#39;</code>.</li>
</ol>
</blockquote>
<h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Search</span> rev  <span class="comment">(* list all theorems of [rev] *)</span></span><br></pre></td></tr></table></figure>


<h2 id="Coq-Conditionals-if-then-else"><a href="#Coq-Conditionals-if-then-else" class="headerlink" title="Coq Conditionals (if then else)"></a>Coq Conditionals (<code>if then else</code>)</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> nth_error&#x27; (l:natlist) (n:nat) : natoption :=</span><br><span class="line">  <span class="keyword">match</span> l <span class="built_in">with</span></span><br><span class="line">  | <span class="type">nil</span> ⇒ None</span><br><span class="line">  | <span class="type">a</span> :: l&#x27; ⇒ <span class="keyword">if</span> n =? O <span class="keyword">then</span> Some a</span><br><span class="line">                        <span class="keyword">else</span> nth_error&#x27; l&#x27; (pred n)</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>One small generalization: since the boolean type in Coq is not built-in. Coq actually supports conditional expr <strong>over any</strong> <em>inductive defined typewith two constructors</em>. First constructor is considered true and false for second.</p>
<h2 id="Stuck-in-Proof"><a href="#Stuck-in-Proof" class="headerlink" title="Stuck in Proof"></a>Stuck in Proof</h2><p>could be many cases</p>
<ul>
<li>wrong tactics</li>
<li>wrong theroem!! (might derive to counterexample)</li>
<li>wrong step (most hard to figure out)<ul>
<li>induction on wrong things</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_lf/2019-01-04-sf-lf-04-poly/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_lf/2019-01-04-sf-lf-04-poly/" class="post-title-link" itemprop="url">「SF-LC」4 Poly</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>The critical new ideas are<br>polymorphism (abstracting functions over the types of the data they manipulate) and<br>higher-order functions (treating functions as data). </p>
</blockquote>
<h2 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h2><p>Until today, We were living in the monomorphic world of Coq.<br>So if we want a list, we have to define it for each type:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> boollist : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">bool_nil</span></span><br><span class="line">  | <span class="type">bool_cons</span> (b : bool) (l : boollist).</span><br></pre></td></tr></table></figure>


<h2 id="Polymorphic-Type-and-Constructors"><a href="#Polymorphic-Type-and-Constructors" class="headerlink" title="Polymorphic Type and Constructors"></a>Polymorphic Type and Constructors</h2><p>But of course Coq supports polymorphic type.<br>So we can <em>abstract things over type</em></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> list (X:<span class="keyword">Type</span>) : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">nil</span></span><br><span class="line">  | <span class="type">cons</span> (x : X) (l : list X).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> list.</span><br><span class="line"><span class="comment">(* ===&gt; list : Type -&gt; Type *)</span></span><br></pre></td></tr></table></figure>

<p>Recall from PLT course, this is exacly <strong>Parametric Polymorphism</strong><br>and it’s <strong>SystemFω</strong>. the <code>list</code> here is a type-level small lambda, or <strong>type operators</strong></p>
<p>Another things I’d love to mention is the concrete syntax of <code>list X</code>,<br>it didn’t choose the SML&#x2F;OCaml order but the Haskell order. </p>
<h3 id="Q1-What’s-the-type-of-nil-and-cons"><a href="#Q1-What’s-the-type-of-nil-and-cons" class="headerlink" title="Q1. What’s the type of nil and cons?"></a>Q1. What’s the type of <code>nil</code> and <code>cons</code>?</h3><p>Both having <code>forall</code> type</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> nil.</span><br><span class="line"><span class="comment">(* ===&gt; nil : forall X : Type, list X *)</span></span><br><span class="line"><span class="keyword">Check</span> cons.</span><br><span class="line"><span class="comment">(* ===&gt; nil : forall X : Type, X -&gt; list X -&gt; list X *)</span></span><br></pre></td></tr></table></figure>


<h3 id="Q2-What’s-the-type-of-list-nat-Why-not-Type-but-weird-Set"><a href="#Q2-What’s-the-type-of-list-nat-Why-not-Type-but-weird-Set" class="headerlink" title="Q2. What’s the type of list nat? Why not Type but weird Set?"></a>Q2. What’s the type of <code>list nat</code>? Why not <code>Type</code> but weird <code>Set</code>?</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> nat.</span><br><span class="line"><span class="comment">(* ===&gt; nat : Set *)</span></span><br><span class="line"><span class="keyword">Check</span> list nat.</span><br><span class="line"><span class="comment">(* ===&gt; list nat : Set *)</span></span><br><span class="line"><span class="keyword">Check</span> <span class="keyword">Set</span>.</span><br><span class="line"><span class="comment">(* ===&gt; Set: Type *)</span></span><br><span class="line"><span class="keyword">Check</span> <span class="keyword">Type</span>.</span><br><span class="line"><span class="comment">(* ===&gt; Type: Type *)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> (cons nat <span class="number">2</span> (cons nat <span class="number">1</span> (nil nat))).</span><br></pre></td></tr></table></figure>


<h2 id="Polymorphic-Functions"><a href="#Polymorphic-Functions" class="headerlink" title="Polymorphic Functions"></a>Polymorphic Functions</h2><p>we can make polymorphic versions of list-processing function:</p>
<p>Btw, Pierce follows the TAPL convention where type is written in capital letter but not greek letter,<br>less clear in first look but better for typing in real programming.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> <span class="built_in">repeat</span> (X : <span class="keyword">Type</span>) (x : X) (count : nat) : list X :=</span><br><span class="line">  <span class="keyword">match</span> count <span class="built_in">with</span></span><br><span class="line">  | <span class="type">0</span> ⇒ nil X</span><br><span class="line">  | <span class="type">S</span> count&#x27; ⇒ cons X x (<span class="built_in">repeat</span> X x count&#x27;)</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>This is <em>SystemF</em>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Check repeat.</span><br><span class="line">(* ===&gt; repeat : forall X : Type, X -&gt; nat -&gt; list X *)</span><br></pre></td></tr></table></figure>


<h2 id="Slide-QA"><a href="#Slide-QA" class="headerlink" title="Slide QA"></a>Slide QA</h2><ol>
<li>ill-typed</li>
<li><code>forall X : Type, X -&gt; nat -&gt; list X</code></li>
<li><code>list nat</code></li>
</ol>
<h2 id="Type-Argument-Inference"><a href="#Type-Argument-Inference" class="headerlink" title="Type Argument Inference"></a>Type Argument Inference</h2><p><code>X</code> must be a <code>Type</code> since <code>nil</code> expects an <code>Type</code> as its first argument.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> <span class="built_in">repeat</span>&#x27; X x count : list X :=     <span class="comment">(* return type [:list X] can be omitted as well *)</span></span><br><span class="line">  <span class="keyword">match</span> count <span class="built_in">with</span></span><br><span class="line">  | <span class="type">0</span> ⇒ nil X</span><br><span class="line">  | <span class="type">S</span> count&#x27; ⇒ cons X x (<span class="built_in">repeat</span>&#x27; X x count&#x27;)</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> <span class="built_in">repeat</span>&#x27;.</span><br><span class="line"><span class="comment">(* ===&gt; forall X : Type, X -&gt; nat -&gt; list X *)</span></span><br></pre></td></tr></table></figure>


<h2 id="Type-Argument-Synthesis"><a href="#Type-Argument-Synthesis" class="headerlink" title="Type Argument Synthesis"></a>Type Argument Synthesis</h2><p>We can write <code>_</code> (hole) in place of <code>X</code> and Coq will try to <strong>unify</strong> all local information.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> <span class="built_in">repeat</span>&#x27;&#x27; X x count : list X :=</span><br><span class="line">  <span class="keyword">match</span> count <span class="built_in">with</span></span><br><span class="line">  | <span class="type">0</span> ⇒ nil <span class="keyword">_</span></span><br><span class="line">  | <span class="type">S</span> count&#x27; ⇒ cons <span class="keyword">_</span> x (<span class="built_in">repeat</span>&#x27;&#x27; <span class="keyword">_</span> x count&#x27;)</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Definition</span> list123&#x27; :=</span><br><span class="line">  cons <span class="keyword">_</span> <span class="number">1</span> (cons <span class="keyword">_</span> <span class="number">2</span> (cons <span class="keyword">_</span> <span class="number">3</span> (nil <span class="keyword">_</span>))).</span><br></pre></td></tr></table></figure>

<p>Same underlying mechanisms:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">repeat</span>&#x27; X x count : list X :=</span><br><span class="line"><span class="built_in">repeat</span>&#x27; (X : <span class="keyword">_</span>) (x : <span class="keyword">_</span>) (count : <span class="keyword">_</span>) : list X :=</span><br></pre></td></tr></table></figure>


<h2 id="Implicit-Arguments"><a href="#Implicit-Arguments" class="headerlink" title="Implicit Arguments"></a>Implicit Arguments</h2><p>Using <code>Arguments</code> directives to tell if an argument need to be implicit (i.e. omitted and always to infer) or not. </p>
<blockquote>
<p>Implicitly convert to <code>_</code> (synthesis) by frontend.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Arguments</span> nil &#123;X&#125;.</span><br><span class="line"><span class="keyword">Arguments</span> cons &#123;X&#125; <span class="keyword">_</span> <span class="keyword">_</span>.       <span class="comment">(* data constructor usually don&#x27;t specify the name *)</span></span><br><span class="line"><span class="keyword">Arguments</span> <span class="built_in">repeat</span> &#123;X&#125; x count. <span class="comment">(* fun definition usually do *)</span></span><br></pre></td></tr></table></figure>

<p>The even more convenient syntax is that we can declare them right in our function definition.<br>Just <em>surrounding them with curly braces</em>.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> <span class="built_in">repeat</span>&#x27;&#x27;&#x27; &#123;X : <span class="keyword">Type</span>&#125; (x : X) (count : nat) : list X :=</span><br><span class="line">  <span class="keyword">match</span> count <span class="built_in">with</span></span><br><span class="line">  | <span class="type">0</span> ⇒ nil</span><br><span class="line">  | <span class="type">S</span> count&#x27; ⇒ cons x (<span class="built_in">repeat</span>&#x27;&#x27;&#x27; x count&#x27;)</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>


<h2 id="Implicit-Arguments-Pitfalls-on-Inductive"><a href="#Implicit-Arguments-Pitfalls-on-Inductive" class="headerlink" title="Implicit Arguments Pitfalls on Inductive"></a>Implicit Arguments Pitfalls on <code>Inductive</code></h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> list&#x27; &#123;X:<span class="keyword">Type</span>&#125; : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">nil</span>&#x27;</span><br><span class="line">  | <span class="type">cons</span>&#x27; (x : X) (l : list&#x27;).</span><br></pre></td></tr></table></figure>

<p>Doing this will make <code>X</code> implicit for even <code>list&#39;</code>, the type constructor itself… </p>
<h2 id="Other-Polymorphic-List-functions"><a href="#Other-Polymorphic-List-functions" class="headerlink" title="Other Polymorphic List functions"></a>Other Polymorphic List functions</h2><p>No difference but add implicit type argument <code>&#123;X : Type&#125;</code>.</p>
<h2 id="Supplying-Type-Arguments-Explicitly"><a href="#Supplying-Type-Arguments-Explicitly" class="headerlink" title="Supplying Type Arguments Explicitly"></a>Supplying Type Arguments Explicitly</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fail <span class="keyword">Definition</span> mynil := nil.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Definition</span> mynil : list nat := nil.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> @nil. <span class="comment">(* ===&gt; @nil : forall X : Type, list X *)</span></span><br><span class="line"><span class="keyword">Definition</span> mynil&#x27; := @nil nat.</span><br></pre></td></tr></table></figure>

<p>First thought: Existential<br>Second thought: A wait to be unified Universal. (after being implicit and require inference)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> nil.</span><br><span class="line"></span><br><span class="line">nil : </span><br><span class="line">   list ?X</span><br><span class="line"><span class="keyword">where</span> ?X : [ |<span class="type">- Type</span>]</span><br></pre></td></tr></table></figure>


<h2 id="List-notation"><a href="#List-notation" class="headerlink" title="List notation"></a>List notation</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;x :: y&quot;</span> := (cons x y)</span><br><span class="line">                     (<span class="built_in">at</span> level <span class="number">60</span>, <span class="built_in">right</span> associativity).</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;[ ]&quot;</span> := nil.</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;[ x ; .. ; y ]&quot;</span> := (cons x .. (cons y []) ..).</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;x ++ y&quot;</span> := (app x y)</span><br><span class="line">                     (<span class="built_in">at</span> level <span class="number">60</span>, <span class="built_in">right</span> associativity).</span><br></pre></td></tr></table></figure>

<p>Same with before thanks to the implicit argument</p>
<h2 id="Slide-Q-A-2"><a href="#Slide-Q-A-2" class="headerlink" title="Slide Q&amp;A 2"></a>Slide Q&amp;A 2</h2><ol>
<li>we use <code>;</code> not <code>,</code>!!</li>
<li><code>list nat</code></li>
<li>ill-typed</li>
<li>ill-typed</li>
<li><code>list (list nat)</code></li>
<li><code>list (list nat)</code> (tricky in first look)</li>
<li><code>list bool</code></li>
<li>ill-typed</li>
<li>ill-typed</li>
</ol>
<h2 id="Poly-Pair"><a href="#Poly-Pair" class="headerlink" title="Poly Pair"></a>Poly Pair</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> prod (X Y : <span class="keyword">Type</span>) : <span class="keyword">Type</span> :=</span><br><span class="line">| <span class="type">pair</span> (x : X) (y : Y).</span><br><span class="line"><span class="keyword">Arguments</span> pair &#123;X&#125; &#123;Y&#125; <span class="keyword">_</span> <span class="keyword">_</span>.  <span class="comment">(* omit two type var **)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;( x , y )&quot;</span> := (pair x y).</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;X * Y&quot;</span> := (prod X Y) : type_scope.  <span class="comment">(* only be used when parsing type, avoids clashing with multiplication *)</span></span><br></pre></td></tr></table></figure>

<p>Be careful of <code>(X,Y)</code> and <code>X*Y</code>. Coq pick the ML way, not haskell way.</p>
<h2 id="Combine-or-Zip"><a href="#Combine-or-Zip" class="headerlink" title="Combine or Zip"></a><code>Combine</code> or <code>Zip</code></h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> combine &#123;X Y : <span class="keyword">Type</span>&#125; (lx : list X) (ly : list Y)</span><br><span class="line">           : list (X*Y) :=</span><br><span class="line">  <span class="keyword">match</span> lx, ly <span class="built_in">with</span></span><br><span class="line">  | <span class="type">[], _</span> ⇒ []</span><br><span class="line">  | <span class="type">_</span>, [] ⇒ []</span><br><span class="line">  | <span class="type">x</span> :: tx, y :: ty ⇒ (x, y) :: (combine tx ty)</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>Guess type?</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> @combine.</span><br><span class="line">@combine</span><br><span class="line">     : <span class="keyword">forall</span> X Y : <span class="keyword">Type</span>,</span><br><span class="line">       list X -&gt; list Y -&gt; list (X * Y)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* A special form of `forall`? *)</span></span><br><span class="line"><span class="keyword">Check</span> combine.</span><br><span class="line">combine</span><br><span class="line">     : list ?X -&gt; list ?Y -&gt; list (?X * ?Y)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">?X : [ |<span class="type">- Type</span>]</span><br><span class="line">?Y : [ |<span class="type">- Type</span>]</span><br></pre></td></tr></table></figure>


<h2 id="Poly-Option"><a href="#Poly-Option" class="headerlink" title="Poly Option"></a>Poly Option</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> option (X:<span class="keyword">Type</span>) : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">Some</span> (x : X)</span><br><span class="line">  | <span class="type">None</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Arguments</span> Some &#123;X&#125; <span class="keyword">_</span>.</span><br><span class="line"><span class="keyword">Arguments</span> None &#123;X&#125;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">(* find nth element if exist, None otherwise *)</span></span><br><span class="line"><span class="keyword">Fixpoint</span> nth_error &#123;X : <span class="keyword">Type</span>&#125; (l : list X) (n : nat) : option X :=</span><br><span class="line">  <span class="keyword">match</span> l <span class="built_in">with</span></span><br><span class="line">  | <span class="type">[] ⇒ None</span></span><br><span class="line">  | <span class="type">a</span> :: l&#x27; ⇒ <span class="keyword">if</span> n =? O <span class="keyword">then</span> Some a <span class="keyword">else</span> nth_error l&#x27; (pred n)</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>


<h2 id="Function-as-data"><a href="#Function-as-data" class="headerlink" title="Function as data"></a>Function as data</h2><p><em>Functions as first-class citizens</em></p>
<h2 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher-Order Functions"></a>Higher-Order Functions</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> doit3times &#123;X:<span class="keyword">Type</span>&#125; (f:X→X) (n:X) : X :=</span><br><span class="line">  f (f (f n)).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> @doit3times.</span><br><span class="line"><span class="comment">(* ===&gt; doit3times : forall X : Type, (X -&gt; X) -&gt; X -&gt; X *)</span></span><br></pre></td></tr></table></figure>


<h2 id="Filter-taking-a-predicate-on-X"><a href="#Filter-taking-a-predicate-on-X" class="headerlink" title="Filter (taking a predicate on X)"></a>Filter (taking a <em>predicate</em> on <code>X</code>)</h2><p><em>collection-oriented</em> programming style - my first time seeing this, any comments?</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> filter &#123;X:<span class="keyword">Type</span>&#125; (test: X→bool) (l:list X)</span><br><span class="line">                : (list X) :=</span><br><span class="line">  <span class="keyword">match</span> l <span class="built_in">with</span></span><br><span class="line">  | <span class="type">[] ⇒ []</span></span><br><span class="line"><span class="type">  | h</span> :: t ⇒ <span class="keyword">if</span> test h <span class="keyword">then</span> h :: (filter test t)</span><br><span class="line">                        <span class="keyword">else</span> filter test t</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Example</span> test_filter1: filter evenb [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>] = [<span class="number">2</span>;<span class="number">4</span>].</span><br><span class="line"><span class="keyword">Proof</span>. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>


<h2 id="Anonymous-Functions"><a href="#Anonymous-Functions" class="headerlink" title="Anonymous Functions"></a>Anonymous Functions</h2><blockquote>
<p>It is arguably a little sad, in the example just above, to be forced to define the function length_is_1 and give it a name just to be able to pass it as an argument to filter</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> test_anon_fun&#x27;:</span><br><span class="line">  doit3times (<span class="keyword">fun</span> n ⇒ n * n) <span class="number">2</span> = <span class="number">256.</span></span><br><span class="line"><span class="keyword">Proof</span>. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>Syntax: hybrid of OCaml <code>fun n -&gt; n</code> and SML <code>fn n =&gt; n</code>.<br>and support multi-arguments (curried)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Compute</span> ((<span class="keyword">fun</span> x y =&gt; x + y) <span class="number">3</span> <span class="number">5</span>).</span><br></pre></td></tr></table></figure>


<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Should be familar.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> map &#123;X Y: <span class="keyword">Type</span>&#125; (f:X→Y) (l:list X) : (list Y) :=</span><br><span class="line">  <span class="keyword">match</span> l <span class="built_in">with</span></span><br><span class="line">  | <span class="type">[] ⇒ []</span></span><br><span class="line"><span class="type">  | h</span> :: t ⇒ (f h) :: (map f t)</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> @map</span><br><span class="line"></span><br><span class="line">@map : <span class="keyword">forall</span> X Y : <span class="keyword">Type</span>, (X -&gt; Y) -&gt; list X -&gt; list Y</span><br></pre></td></tr></table></figure>


<h2 id="Slide-Q-A-3"><a href="#Slide-Q-A-3" class="headerlink" title="Slide Q&amp;A 3"></a>Slide Q&amp;A 3</h2><ol>
<li>as above</li>
</ol>
<h2 id="option-map"><a href="#option-map" class="headerlink" title="option map"></a><code>option</code> map</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> option_map &#123;X Y : <span class="keyword">Type</span>&#125; (f : X → Y) (xo : option X) : option Y :=</span><br><span class="line">  <span class="keyword">match</span> xo <span class="built_in">with</span></span><br><span class="line">    | <span class="type">None</span> ⇒ None</span><br><span class="line">    | <span class="type">Some</span> x ⇒ Some (f x)</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>Functor Map (<code>fmap</code>) !</p>
<h2 id="Fold-Reduce"><a href="#Fold-Reduce" class="headerlink" title="Fold (Reduce)"></a>Fold (Reduce)</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> <span class="built_in">fold</span> &#123;X Y: <span class="keyword">Type</span>&#125; (f: X→Y→Y) (l: list X) (b: Y) : Y :=</span><br><span class="line">  <span class="keyword">match</span> l <span class="built_in">with</span></span><br><span class="line">  | <span class="type">nil</span> ⇒ b</span><br><span class="line">  | <span class="type">h</span> :: t ⇒ f h (<span class="built_in">fold</span> f t b)</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>Fold Right (<code>foldr</code>). Argument order same with OCaml, different with Haskell. </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> @<span class="built_in">fold</span></span><br><span class="line"></span><br><span class="line">@<span class="built_in">fold</span></span><br><span class="line">     : <span class="keyword">forall</span> X Y : <span class="keyword">Type</span>,</span><br><span class="line">       (X -&gt; Y -&gt; Y) -&gt; list X -&gt; Y -&gt; Y</span><br></pre></td></tr></table></figure>

<h2 id="Slide-Q-A-4"><a href="#Slide-Q-A-4" class="headerlink" title="Slide Q&amp;A 4"></a>Slide Q&amp;A 4</h2><ol>
<li>as above (type can be simply readed out)</li>
<li><code>list nat -&gt; nat -&gt; nat</code></li>
<li>10</li>
</ol>
<h2 id="Functions-That-Construct-Functions"><a href="#Functions-That-Construct-Functions" class="headerlink" title="Functions That Construct Functions"></a>Functions That Construct Functions</h2><p>Should be familar.<br>Use of <em>closure</em>.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">definition constfun &#123;X: <span class="keyword">Type</span>&#125; (x: X) : nat→X :=</span><br><span class="line">  <span class="keyword">fun</span> (k:nat) ⇒ x.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Definition</span> ftrue := constfun true.</span><br><span class="line"><span class="keyword">Example</span> constfun_example1 : ftrue <span class="number">0</span> = true.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Example</span> constfun_example2 : (constfun <span class="number">5</span>) <span class="number">99</span> = <span class="number">5.</span></span><br></pre></td></tr></table></figure>

<p><strong>Curried</strong> and <strong>partial application</strong></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> plus.</span><br><span class="line"><span class="comment">(* ==&gt; nat -&gt; nat -&gt; nat *)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> plus <span class="number">3.</span></span><br><span class="line"><span class="comment">(* ==&gt; nat -&gt; nat *)</span></span><br></pre></td></tr></table></figure>


<h2 id="Universe-Inconsistency"><a href="#Universe-Inconsistency" class="headerlink" title="Universe Inconsistency"></a>Universe Inconsistency</h2><p>I encounter this problem when doing church numeral exercise.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> plus (n m : cnat) : cnat := n cnat succ m.</span><br></pre></td></tr></table></figure>

<p>will result in <code>universe inconsistency</code> error.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span> <span class="keyword">Printing</span> <span class="keyword">Universes</span>. <span class="comment">(* giving more error msg *)</span></span><br><span class="line"></span><br><span class="line">In environment</span><br><span class="line">n : cnat</span><br><span class="line">m : cnat</span><br><span class="line">The term <span class="string">&quot;cnat&quot;</span> has type <span class="string">&quot;Type@&#123;Top.168+1&#125;&quot;</span> while it is expected to have type <span class="string">&quot;Type@&#123;Top.168&#125;&quot;</span></span><br><span class="line">(universe inconsistency: Cannot enforce Top<span class="number">.168</span> &lt; Top<span class="number">.168</span> because Top<span class="number">.168</span> = Top<span class="number">.168</span>).</span><br></pre></td></tr></table></figure>


<h3 id="What’s-happening"><a href="#What’s-happening" class="headerlink" title="What’s happening?"></a>What’s happening?</h3><blockquote>
<p>Yes, you can define: <code>Definition plus (n m : cnat) : cnat := n cnat succ m.</code> in System F.  However, in Coq’s richer logic, you need to be a little more careful about allowing types to be instantiated at their own types, else you run into issue of inconsistency. Essentially, there is a stratification of types (by “universes”) that says that one universe cannot contain a “bigger” universe. Often, things are polymorphic in their universe (i.e., work in all universes), you run into this where you cannot instantiate the “forall X, …” that is the definition of cnat by cnat itself.<br>– Prof. Fluet</p>
</blockquote>
<h3 id="https-stackoverflow-com-questions-32153710-what-does-error-universe-inconsistency-mean-in-coq"><a href="#https-stackoverflow-com-questions-32153710-what-does-error-universe-inconsistency-mean-in-coq" class="headerlink" title="https://stackoverflow.com/questions/32153710/what-does-error-universe-inconsistency-mean-in-coq"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/32153710/what-does-error-universe-inconsistency-mean-in-coq">https://stackoverflow.com/questions/32153710/what-does-error-universe-inconsistency-mean-in-coq</a></h3><p><code>Check Type =&gt; Type</code> is a bit of a lie, everytime it the <code>Type</code> is not that same, but <strong>a bigger one</strong>.</p>
<blockquote>
<p>Formally, every Type has an index associated to it, called its <em>universe level</em>.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span> <span class="keyword">Printing</span> <span class="keyword">Universes</span>. <span class="comment">(* giving more error msg *)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> <span class="keyword">Type</span>. </span><br><span class="line"><span class="keyword">Type</span>@&#123;Top<span class="number">.1</span>&#125; : <span class="keyword">Type</span>@&#123;Top<span class="number">.1</span>+<span class="number">1</span>&#125; <span class="comment">(* &#123;Top.1&#125; |=  *)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> <span class="keyword">Type</span>. </span><br><span class="line"><span class="keyword">Type</span>@&#123;Top<span class="number">.2</span>&#125; : <span class="keyword">Type</span>@&#123;Top<span class="number">.2</span>+<span class="number">1</span>&#125; <span class="comment">(* &#123;Top.2&#125; |=  *)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Thus, the correct answer for that question is that <code>Type_i</code> has type <code>Type_j</code>, for any index <code>j &gt; i</code>. This is needed to ensure the consistency of Coq’s theory: <em>if there were only one Type, it would be possible to show a contradiction, similarly to how one gets a contradiction in set theory if you assume that there is a set of all sets.</em><br>Coq generates one new index variable every time you write Type, and keeps track of internal constraints</p>
</blockquote>
<blockquote>
<p>The error message you saw means that <em>Coq’s constraint solver</em> for universe levels says that there can’t be a solution to the constraint system you asked for.</p>
</blockquote>
<blockquote>
<p>The problem is that the <code>forall</code> in the definition of <code>nat</code> is quantified over <code>Type_i</code>, but Coq’s logic forces <code>nat</code> to be itself of type <code>Type_j</code>, with <code>j &gt; i</code>. On the other hand, the application <code>n nat</code> requires that <code>j &lt;= i</code>, resulting in a non-satisfiable set of index constraints.</p>
</blockquote>
<p>From my understanding, the essences are: </p>
<ol>
<li>reasons: Allowing self-application introduces <em>logic contradiction (paradox)</em>.</li>
<li>understanding: The <code>forall</code> is quantified over <em>types in the previous universe</em> (the universe w&#x2F;o itself).</li>
</ol>
<h3 id="From-https-coq-inria-fr-refman-addendum-universe-polymorphism-html"><a href="#From-https-coq-inria-fr-refman-addendum-universe-polymorphism-html" class="headerlink" title="From https://coq.inria.fr/refman/addendum/universe-polymorphism.html"></a>From <a target="_blank" rel="noopener" href="https://coq.inria.fr/refman/addendum/universe-polymorphism.html">https://coq.inria.fr/refman/addendum/universe-polymorphism.html</a></h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> identity &#123;A : <span class="keyword">Type</span>&#125; (a : A) := a.</span><br><span class="line"></span><br><span class="line">Fail <span class="keyword">Definition</span> selfid := identity (@identity).</span><br></pre></td></tr></table></figure>

<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The command has indeed failed <span class="built_in">with</span> message:</span><br><span class="line">The term <span class="string">&quot;@identity&quot;</span> has type <span class="string">&quot;forall A : Type, A -&gt; A&quot;</span></span><br><span class="line">while it is expected to have type <span class="string">&quot;?A&quot;</span></span><br><span class="line">(unable to find a well-typed instantiation <span class="keyword">for</span> <span class="string">&quot;?A&quot;</span>: cannot ensure that</span><br><span class="line"><span class="string">&quot;Type@&#123;Top.1+1&#125;&quot;</span> is a subtype of <span class="string">&quot;Type@&#123;Top.1&#125;&quot;</span>).</span><br></pre></td></tr></table></figure>

<p>The link also introduce some advanced&#x2F;experimental way to do <em>polymorphic universe</em></p>
<h2 id="Polymorphic-Church-Numerals-w-o-self-applying-itself"><a href="#Polymorphic-Church-Numerals-w-o-self-applying-itself" class="headerlink" title="Polymorphic Church Numerals w&#x2F;o self-applying itself"></a>Polymorphic Church Numerals w&#x2F;o self-applying itself</h2><blockquote>
<p>References: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Church_encoding">https://en.wikipedia.org/wiki/Church_encoding</a></p>
</blockquote>
<h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>Untyped doesn’t need to declare type…<br>STLC doesn’t have enough expressive power to represent church encoding<br>System F definition: </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> cnat := <span class="keyword">forall</span> X : <span class="keyword">Type</span>, (X -&gt; X) -&gt; X -&gt; X.</span><br></pre></td></tr></table></figure>

<h3 id="succ"><a href="#succ" class="headerlink" title="succ"></a><code>succ</code></h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">succ</span> = \n s z -&gt; s (n s z) </span><br></pre></td></tr></table></figure>

<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> succ (n : cnat) : cnat :=</span><br><span class="line">  <span class="keyword">fun</span> X s z =&gt; s (n X s z).</span><br></pre></td></tr></table></figure>

<h3 id="plus"><a href="#plus" class="headerlink" title="plus"></a><code>plus</code></h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">plus</span> = \m n -&gt; m scc n</span><br><span class="line"><span class="title">plus</span> = \m n s z -&gt; m s (n s z)</span><br></pre></td></tr></table></figure>

<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> plus (n m : cnat) : cnat :=</span><br><span class="line">  n cnat succ m.                <span class="comment">(* System F *)</span></span><br><span class="line">  <span class="keyword">fun</span> X s z =&gt; n X s (m X s z). <span class="comment">(* Coq *)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plus = </span><br><span class="line">  lambda m:CNat.</span><br><span class="line">  lambda n:CNat. ( </span><br><span class="line">    lambda X.</span><br><span class="line">    lambda s:X-&gt;X.</span><br><span class="line">    lambda z:X. </span><br><span class="line">      m [X] s (n [X] s z)</span><br><span class="line">  ) as CNat;</span><br><span class="line"></span><br><span class="line">plus = </span><br><span class="line">  lambda m:CNat.</span><br><span class="line">  lambda n:CNat. </span><br><span class="line">    m [CNat] succ&#x27; n;</span><br></pre></td></tr></table></figure>

<h3 id="mult"><a href="#mult" class="headerlink" title="mult"></a><code>mult</code></h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mult</span> = \m n -&gt; m (plus n) n0 </span><br></pre></td></tr></table></figure>

<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> mult (n m : cnat) : cnat :=</span><br><span class="line">  n cnat (plus m) zero.         <span class="comment">(* SystemF *)</span></span><br><span class="line">  <span class="keyword">fun</span> X s z =&gt; (m X (n X s) z). <span class="comment">(* Coq *)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mult = </span><br><span class="line">  lambda m:CNat.</span><br><span class="line">  lambda n:CNat. </span><br><span class="line">    m [CNat] (plus n) c0;   /* partial app `plus` */</span><br></pre></td></tr></table></figure>


<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a><code>exp</code></h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pow</span> = \m n -&gt; m (mult n) n1</span><br><span class="line"><span class="title">exp</span> = \m n -&gt; n m</span><br></pre></td></tr></table></figure>

<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> exp (n m : cnat) : cnat :=</span><br><span class="line">  n cnat (mult m) one         <span class="comment">(* SystemF *)</span></span><br><span class="line">  <span class="keyword">fun</span> X =&gt; m (X -&gt; X) (n X).  <span class="comment">(* Coq *)</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_lf/2019-01-05-sf-lf-05-tactics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_lf/2019-01-05-sf-lf-05-tactics/" class="post-title-link" itemprop="url">「SF-LC」5 Tactics</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a><code>apply</code></h2><ul>
<li><em>exactly</em> the same as some hypothesis</li>
<li>can be used to <strong>finish</strong> a proof (shorter than <code>rewrite</code> then <code>reflexivity</code>)</li>
</ul>
<p>It also works with <em>conditional</em> hypotheses:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n, m, o, p : nat</span><br><span class="line">eq1 : n = m</span><br><span class="line">eq2 : <span class="keyword">forall</span> q r : nat, q = r -&gt; [q; o] = [r; p]</span><br><span class="line">============================</span><br><span class="line">[n; o] = [m; p]</span><br><span class="line"></span><br><span class="line"><span class="built_in">apply</span> eq2.</span><br><span class="line">n = m</span><br></pre></td></tr></table></figure>

<p>It works by working backwards.<br>It will try to <em>pattern match</em> the universally quantified <code>q r</code>. (i.e. universal var)<br>We match the <em>conclusion</em> and generates the <em>hypothesis</em> as a <em>subgoal</em>.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> trans_eq : <span class="keyword">forall</span> (X:<span class="keyword">Type</span>) (n m o : X), n = m -&gt; m = o -&gt; n = o.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Example</span> trans_eq_example&#x27; : <span class="keyword">forall</span> (a b c d e f : nat),</span><br><span class="line">     [a;b] = [c;d] -&gt; [c;d] = [e;f] -&gt; [a;b] = [e;f].</span><br><span class="line"><span class="keyword">Proof</span>. </span><br><span class="line">  <span class="built_in">intros</span> a b c d e f eq1 eq2.</span><br><span class="line">  <span class="built_in">apply</span> trans_eq. <span class="comment">(* Error: Unable to find an instance for the variable m. *)</span></span><br></pre></td></tr></table></figure>

<p>The <em>unification algo</em> won’t happy since:</p>
<ul>
<li>it can find instance for <code>n = o</code> from <code>[a;b] = [e;f]</code> (matching both conclusion)</li>
<li>but what should be <code>m</code>? It could be anything as long as <code>n = m</code> and <code>m = o</code> holds.</li>
</ul>
<p>So we need to tell Coq explicitly which value should be picked for <code>m</code>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">apply</span> trans_eq <span class="built_in">with</span> (m:=[c;d]).   <span class="comment">(* &lt;- supplying extra info, [m:=] can be ommited *)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Prof Mtf: As a PL person, you should feel this is a little bit awkward since now function argument name must be remembered. (but it’s just local and should be able to do any alpha-conversion).<br>named argument is more like a record.</p>
</blockquote>
<p>In Coq Intensive 2 (2018), someone proposed the below which works:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> trans_eq_example&#x27;&#x27; : <span class="keyword">forall</span> (a b c d e f : nat),</span><br><span class="line">  [a;b] = [c;d] -&gt; [c;d] = [e;f] -&gt; [a;b] = [e;f]. </span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> a b c d e f.</span><br><span class="line">  <span class="built_in">apply</span> trans_eq.          <span class="comment">(* Coq was able to match three at all at this time...hmm *)</span></span><br><span class="line"><span class="keyword">Qed</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="injection-and-discrinimate"><a href="#injection-and-discrinimate" class="headerlink" title="injection and discrinimate"></a><code>injection</code> and <code>discrinimate</code></h2><h3 id="Side-Note-on-Terminologys-of-Function"><a href="#Side-Note-on-Terminologys-of-Function" class="headerlink" title="Side Note on Terminologys of Function"></a>Side Note on Terminologys of Function</h3><pre><code>                     relation
</code></pre>
<blockquote>
<p>function is defined as <em>a special kind of binary relation</em>.<br>it requires <code>xRy1 ∧ xRy2 → y1 = y2</code>  called “functional” or “univalent”, “right-unique”, or “deterministic”<br>and also <code>∀x ∈ X, ∃y ∈ Y s.t. xRy</code>   called “left-total”</p>
</blockquote>
<pre><code>                x       ↦      f(x)
              input     ↦     output
            argument    ↦     value

                X       ↦       Y
             domain 域  ↦  co-domain 陪域      
       what can go into ↦  what possibly come out

              A ⊆ X     ↦  f(A) = &#123;f(x) | x ∈ A&#125;
                        ↦     image
                        ↦  what actually come out

f⁻¹(B)=&#123;x ∈ X|f(x) ∈ B&#125; ↦     B ⊆ Y
             preimage   ↦

            when A = X  ↦       Y
                        ↦     range  
                           image of domain
</code></pre>
<p>Besides subset, the notation of <code>image</code> and <code>pre-image</code> can be applied to <em>element</em> as well.<br>However, by definition:</p>
<ul>
<li>the image    of an element <code>x</code> of domain    ↦  always single element of codomain (singleton set)</li>
<li>the preimage of an element <code>y</code> of codomain  ↦  may be empty, or one, or many!<ul>
<li><code>&lt;= 1 ↦ 1</code> : injective   (left-unique)</li>
<li><code>&gt;= 1 ↦ 1</code> : surjective  (right-total)</li>
<li><code>   1 ↦ 1</code> : bijective</li>
</ul>
</li>
</ul>
<p>Noted that the definition of “function” doesn’t require “right-total”ity) until we have <code>surjective</code>.</p>
<p>graph &#x3D; <code>[(x, f(x))]</code>, these points form a “curve”, 真的是图像</p>
<h3 id="Total-vs-Partial"><a href="#Total-vs-Partial" class="headerlink" title="Total vs Partial"></a>Total vs Partial</h3><p>For math, we seldon use partial function since we can simply “define a perfect domain for that”.<br>But in Type Theory, Category Theory, we usually consider the <em>domain</em> <code>X</code> and the <em>domain of definition</em> <code>X&#39;</code>.</p>
<p>Besides, <code>f(x)</code> can be <code>undefined</code>. (not “left-total”, might not have “right”)</p>
<h3 id="Conclusion-the-road-from-Relation-to-Function"><a href="#Conclusion-the-road-from-Relation-to-Function" class="headerlink" title="Conclusion - the road from Relation to Function"></a>Conclusion - the road from Relation to Function</h3><pre><code>            bi-relation 
                 | + right-unique 
          partial function
                 | + left-total   
          (total) function
 + left-unique /   \ + right-total
      injection     surjection
               \   /
             bijection
</code></pre>
<h3 id="Original-notes-on-Injective-surjective-Bijective"><a href="#Original-notes-on-Injective-surjective-Bijective" class="headerlink" title="Original notes on Injective, surjective, Bijective"></a>Original notes on <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Function">Injective, surjective, Bijective</a></h3><p>All talk about the propeties of <em>preimage</em>!</p>
<ul>
<li>Injective:  <code>&lt;= 1 ↦ 1</code> or <code>0, 1 ↦ 1</code> (distinctness) </li>
<li>Surjective: <code>&gt;= 1 ↦ 1</code> (at least 1 in the domain)</li>
<li>Bijective:  <code>   1 ↦ 1</code> (intersection of Inj and Surj, so only <code>1</code> preimage, <em>one-to-one correspondence</em>)</li>
</ul>
<h3 id="injectivitiy-and-disjointness-or-inversion"><a href="#injectivitiy-and-disjointness-or-inversion" class="headerlink" title="injectivitiy and disjointness, or inversion."></a><em>injectivitiy</em> and <em>disjointness</em>, or <code>inversion</code>.</h3><p>Recall the definition of <code>nat</code>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> nat : <span class="keyword">Type</span> :=</span><br><span class="line">| <span class="type">O</span> : nat</span><br><span class="line">| <span class="type">S</span> : nat → nat.</span><br></pre></td></tr></table></figure>

<p>Besides there are two forms of <code>nat</code> (for <code>destruct</code> and <code>induction</code>), there are more facts:</p>
<ol>
<li>The constructor <code>S</code> is <em>injective</em> (distinct), i.e <code>S n = S m -&gt; n = m</code>.</li>
<li>The constructors <code>O</code> and <code>S</code> are <em>disjoint</em>, i.e. <code>forall n, O != S n </code>.</li>
</ol>
<h3 id="injection"><a href="#injection" class="headerlink" title="injection"></a><code>injection</code></h3><ul>
<li>can be used to prove the <em>preimages</em> are the same.</li>
<li><code>injection</code> leave things in conclusion rather than hypo. with <code>as</code> would be in hypo.</li>
</ul>
<h3 id="disjoint"><a href="#disjoint" class="headerlink" title="disjoint"></a><code>disjoint</code></h3><ul>
<li><em>principle of explosion</em> (a logical principle)<ul>
<li>asserts a contraditory hypothesis entails anything. (even false things)</li>
<li><em>vacously true</em></li>
</ul>
</li>
<li><code>false = true</code> is contraditory because they are distinct constructors.</li>
</ul>
<h3 id="inversion"><a href="#inversion" class="headerlink" title="inversion"></a><code>inversion</code></h3><ul>
<li>the big hammer: inversion of the definition.</li>
<li>combining <code>injection</code> and <code>disjoint</code> and even some more <code>rewrite</code>.<ul>
<li>IMH, which one to use depends on <em>semantics</em></li>
</ul>
</li>
</ul>
<p>from Coq Intensive (not sure why it’s not the case in book version).</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> S_injective_inv : <span class="keyword">forall</span> (n m : nat),</span><br><span class="line">  S n = S m -&gt; n = m.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n m H. <span class="built_in">inversion</span> H. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Theorem</span> inversion_ex1 : <span class="keyword">forall</span> (n m : nat),</span><br><span class="line">  [n] = [m] -&gt; n = m.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n m H. <span class="built_in">inversion</span> H. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Side question: could Coq derive equality function for inductive type?<br>A: nope. Equality for some inductive types are <em>undecidable</em>.</p>
</blockquote>
<h3 id="Converse-of-injectivity"><a href="#Converse-of-injectivity" class="headerlink" title="Converse of injectivity"></a>Converse of injectivity</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> <span class="built_in">f_equal</span> : ∀(A B : <span class="keyword">Type</span>) (f: A → B) (x y: A),</span><br><span class="line">  x = y → f x = f y.</span><br><span class="line"><span class="keyword">Proof</span>. </span><br><span class="line">  <span class="built_in">intros</span> A B f x y eq. </span><br><span class="line">  <span class="built_in">rewrite</span> eq. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>


<h3 id="Slide-Q-A-1"><a href="#Slide-Q-A-1" class="headerlink" title="Slide Q&amp;A 1"></a>Slide Q&amp;A 1</h3><ol>
<li>The tactic fails because tho <code>negb</code> is injective but <code>injection</code> only workks on constructors.</li>
</ol>
<h2 id="Using-Tactics-in-Hypotheses"><a href="#Using-Tactics-in-Hypotheses" class="headerlink" title="Using Tactics in Hypotheses"></a>Using Tactics in Hypotheses</h2><h3 id="Reasoning-Backwards-and-Reasoning-Forward-from-Coq-Intensive-2"><a href="#Reasoning-Backwards-and-Reasoning-Forward-from-Coq-Intensive-2" class="headerlink" title="Reasoning Backwards and Reasoning Forward (from Coq Intensive 2)"></a>Reasoning Backwards and Reasoning Forward (from Coq Intensive 2)</h3><p>Style of reasoning</p>
<ul>
<li>Backwards: start with <em>goal</em>, applying tactics <code>simpl/destruct/induction</code>, generate <em>subgoals</em>, until proved.<ul>
<li>iteratively reasons about what would imply the goal, until premises or previously proven theorems are reached.</li>
</ul>
</li>
<li>Forwards:  start with <em>hypo</em>, applying tactics, iteratively draws conclusions, until the goal is reached.</li>
</ul>
<p>Backwards reasoning is dominated stratgy of theroem prover (and execution of prolog). But not natural in informal proof.</p>
<blockquote>
<p>True forward reasoning derives fact, but in Coq it’s like hypo deriving hypo, very imperative.</p>
</blockquote>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a><code>in</code></h3><blockquote>
<p>most tactics also have a variant that performs a similar operation on a statement in the context.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">simpl</span> <span class="built_in">in</span> H.</span><br><span class="line"><span class="built_in">simpl</span> <span class="built_in">in</span> *. <span class="comment">(* in all hypo and goal *)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">symmetry</span> <span class="built_in">in</span> H.</span><br><span class="line"><span class="built_in">apply</span> L <span class="built_in">in</span> H.</span><br></pre></td></tr></table></figure>

<h3 id="applying-in-hypothesis-and-in-conclusion"><a href="#applying-in-hypothesis-and-in-conclusion" class="headerlink" title="applying in hypothesis and in conclusion"></a><code>apply</code>ing in hypothesis and in conclusion</h3><p><code>apply</code>ing in hypo is very different with <code>apply</code>ing in conclusion.</p>
<blockquote>
<p>it’s not we unify the ultimate conclusion and generate premises as new goal, but trying to find a hypothesis to match and left the residual conclusion as new hypothesis.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> silly3&#x27;&#x27; : <span class="keyword">forall</span> (n : nat),</span><br><span class="line">  (true = (n =? <span class="number">5</span>) -&gt; true = ((S (S n)) =? <span class="number">7</span>)) -&gt;</span><br><span class="line">  true = (n =? <span class="number">5</span>)  -&gt;</span><br><span class="line">  true = ((S (S n)) =? <span class="number">7</span>).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n eq H.</span><br><span class="line">  <span class="built_in">apply</span> eq <span class="built_in">in</span> H.  <span class="comment">(* or *)</span>  <span class="built_in">apply</span> eq. <span class="comment">(* would be different *)</span></span><br><span class="line">  <span class="built_in">apply</span> H.  <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>Also if we add one more premises <code>true = true -&gt;</code>,<br>the subgoal generated by <code>apply</code> would be in reversed order: </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> silly3&#x27;&#x27; : <span class="keyword">forall</span> (n : nat),</span><br><span class="line">  (true = true -&gt; true = (n =? <span class="number">5</span>) -&gt; true = ((S (S n)) =? <span class="number">7</span>)) -&gt;</span><br><span class="line">  true = (n =? <span class="number">5</span>)  -&gt;</span><br><span class="line">  true = ((S (S n)) =? <span class="number">7</span>).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Again: “proof engineering”: proof can be done in so many different ways and in different orders.</p>
</blockquote>
<h2 id="Varying-the-Induction-Hypothesis"><a href="#Varying-the-Induction-Hypothesis" class="headerlink" title="Varying the Induction Hypothesis"></a>Varying the Induction Hypothesis</h2><p>Sometimes it’s important to control the exact form of the induction hypothesis!!</p>
<p>Considering:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> double_injective: ∀n m,</span><br><span class="line">        <span class="built_in">double</span> n = <span class="built_in">double</span> m → n = m.</span><br></pre></td></tr></table></figure>

<p>if we begin with <code>intros n m. induction n.</code><br>then we get stuck in the inductive case of <code>n</code>, where the induction hypothesis <code>IHn&#39;</code> generated is:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IHn&#x27; : <span class="built_in">double</span> n&#x27; = <span class="built_in">double</span> m -&gt; n&#x27; = m</span><br><span class="line">IHn&#x27; : <span class="built_in">double</span> n&#x27; = <span class="built_in">double</span> (S m&#x27;) -&gt; n&#x27; = S m&#x27;  <span class="comment">(* m = S m&#x27; *)</span></span><br></pre></td></tr></table></figure>

<p>This is not what we want!! </p>
<p>To prove <code>double_injective</code>, we hope <code>IHn&#39;</code> can give us <code>double n&#39; = double m&#39; -&gt; n&#39; = m&#39;</code> (i.e. the <code>P(n-1)</code> case).</p>
<p>The problem is <code>intros</code> implies <em>for these particular <code>n</code> and <code>m</code></em>. (not more <code>forall</code> but <em>const</em>).  And when we <code>intros n m. induction n</code>, we are trying to prove a statement involving <em>every</em> n but just a <em>single</em> m…</p>
<h3 id="How-to-keep-m-generic-universal"><a href="#How-to-keep-m-generic-universal" class="headerlink" title="How to keep m generic (universal)?"></a><em>How to keep <code>m</code> generic (universal)?</em></h3><p>By either <code>induction n</code> before <code>intros m</code> or using <code>generalize dependent m</code>, we can have:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IHn&#x27; : <span class="keyword">forall</span> m : nat, <span class="built_in">double</span> n&#x27; = <span class="built_in">double</span> m -&gt; n&#x27; = m</span><br></pre></td></tr></table></figure>
<p>where the <code>m</code> here is still universally quantified, so we can instaniate <code>m</code> with <code>m&#39;</code> by <code>apply</code>ing it with <code>double n&#39; = double m&#39;</code> to yield <code>n&#39; = m&#39;</code> or vice versa. (recall conditional statements can be <code>apply</code>ed in 2 ways.)</p>
<h3 id="Notes-on-generalize-dependent"><a href="#Notes-on-generalize-dependent" class="headerlink" title="Notes on generalize dependent"></a>Notes on <code>generalize dependent</code></h3><p>Usually used when the argument order is conflict with instantiate (<code>intros</code>) order.</p>
<blockquote>
<p>? <em>reflection</em>: turing a computational result into a propositional result </p>
</blockquote>
<h2 id="Unfolding-Definitions"><a href="#Unfolding-Definitions" class="headerlink" title="Unfolding Definitions."></a>Unfolding Definitions.</h2><blockquote>
<p>tactics like <code>simpl</code>, <code>reflexivity</code>, and <code>apply</code> will often unfold the definitions of functions automatically.<br>However, this automatic unfolding is somewhat <em>conservative</em>. </p>
</blockquote>
<p><code>simpl.</code> only do unfolding when it can furthur simplify after unfolding. But sometimes you might want to explicitly <code>unfold</code> then do furthur works on that.</p>
<h2 id="Using-destruct-on-Compound-Expressions"><a href="#Using-destruct-on-Compound-Expressions" class="headerlink" title="Using destruct on Compound Expressions"></a>Using <code>destruct</code> on Compound Expressions</h2><p>destruct the whole arbitrary expression.</p>
<p><code>destruct</code> by default throw away the whole expression after it, which might leave you into a stuck state.<br>So explicitly saying <code>eqn:Name</code> would help with that!</p>
<h2 id="Micro-Sermon-Mindless-proof-hacking"><a href="#Micro-Sermon-Mindless-proof-hacking" class="headerlink" title="Micro Sermon - Mindless proof-hacking"></a>Micro Sermon - Mindless proof-hacking</h2><p>From Coq Intensive…</p>
<ul>
<li>a lot of fun </li>
<li>…w&#x2F;o thinking at all</li>
<li>terrible temptation</li>
<li>you shouldn’t always resist…</li>
</ul>
<p>But after 5 mins…you should step back and try to think</p>
<p>A typical coq user</p>
<ul>
<li>sitting and does not have their brain engaged all the time…</li>
<li>at some point…(get stuck)<ul>
<li>oh I have to reengage brain..</li>
</ul>
</li>
</ul>
<p>what is this really saying…</p>
<p>One way: good old paper and pencil</p>
<p>5 mins is good time!</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_lf/2019-01-06-sf-lf-06-logic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_lf/2019-01-06-sf-lf-06-logic/" class="post-title-link" itemprop="url">「SF-LC」6 Logic</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>We have seen…</p>
<ul>
<li><em>propositions</em>: factual claims<ul>
<li>equality propositions (<code>e1 = e2</code>)</li>
<li>implications (<code>P → Q</code>)</li>
<li>quantified propositions (<code>∀ x, P</code>)</li>
</ul>
</li>
<li><em>proofs</em>: ways of presenting <strong>evidence</strong> for the truth of a proposition</li>
</ul>
<h2 id="Prop-type"><a href="#Prop-type" class="headerlink" title="Prop type"></a><code>Prop</code> type</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> <span class="number">3</span> = <span class="number">3.</span>  <span class="comment">(* ===&gt; Prop. A provable prop *)</span></span><br><span class="line"><span class="keyword">Check</span> <span class="number">3</span> = <span class="number">4.</span>  <span class="comment">(* ===&gt; Prop. A unprovable prop *)</span></span><br></pre></td></tr></table></figure>

<p><code>Prop</code> is <em>first-class entity</em> we can </p>
<ul>
<li>name it</li>
<li><em>parametrized</em>!</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> is_three (n : nat) : <span class="keyword">Prop</span> :=</span><br><span class="line">  n = <span class="number">3.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> is_three. <span class="comment">(* ===&gt; nat -&gt; Prop *)</span></span><br></pre></td></tr></table></figure>

<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><blockquote>
<p>In Coq, <em>functions that return propositions</em> are said to define <em>properties</em> of their arguments.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> injective &#123;A B&#125; (f : A → B) :=</span><br><span class="line">  ∀x y : A, f x = f y → x = y.</span><br><span class="line"><span class="keyword">Lemma</span> succ_inj : injective S. <span class="comment">(* can be read off as &quot;injectivity is a property of S&quot; *)</span></span><br><span class="line"><span class="keyword">Proof</span>. </span><br><span class="line">  <span class="built_in">intros</span> n m H. <span class="built_in">injection</span> H <span class="built_in">as</span> H1. <span class="built_in">apply</span> H1. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>The equality operator <code>=</code> is also a function that returns a <code>Prop</code>. (property: <em>equality</em>)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> @eq. <span class="comment">(* ===&gt; forall A : Type, A -&gt; A -&gt; Prop *)</span></span><br></pre></td></tr></table></figure>

<p>Theroems are types, and proofs are existentials.</p>
<h2 id="Slide-Q-A-1"><a href="#Slide-Q-A-1" class="headerlink" title="Slide Q&amp;A - 1."></a>Slide Q&amp;A - 1.</h2><ol>
<li><code>Prop</code></li>
<li><code>Prop</code></li>
<li><code>Prop</code></li>
<li>Not typeable</li>
<li><code>nat -&gt; nat</code></li>
<li><code>nat -&gt; Prop</code></li>
<li>(3)</li>
</ol>
<p>think that Big Lambda (the type abstraction) works at type level, accepts type var, substitute and reture a type.<br><code>forall</code> in Coq is same (the concrete syntax) and only typecheck with <code>Type</code> or its subtype <code>Set</code> &amp; <code>Prop</code>.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> (∀n:nat, S (pred n)).  <span class="comment">(* not typeable *)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Definition</span> foo : (<span class="keyword">forall</span> n:nat, bool) <span class="comment">(* foo: nat -&gt; bool *)</span></span><br><span class="line">  := <span class="keyword">fun</span> x =&gt; true.</span><br></pre></td></tr></table></figure>


<h2 id="Logical-Connectives"><a href="#Logical-Connectives" class="headerlink" title="Logical Connectives"></a>Logical Connectives</h2><blockquote>
<p>noticed that connectives symbols are “unicodize” in book and spacemacs.</p>
</blockquote>
<h3 id="Conjuction-logical-and"><a href="#Conjuction-logical-and" class="headerlink" title="Conjuction (logical and)"></a>Conjuction (logical and)</h3><p><code>and</code> is just binary <code>Prop -&gt; Prop -&gt; Prop</code> and associative. </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Print</span> <span class="string">&quot;/\&quot;.</span></span><br><span class="line"><span class="string">Inductive and (A B : Prop) : Prop :=  conj : A -&gt; B -&gt; A /\ B</span></span><br><span class="line"><span class="string">Check and. (* ===&gt; and : Prop -&gt; Prop -&gt; Prop *)</span></span><br></pre></td></tr></table></figure>

<h4 id="and-introduction"><a href="#and-introduction" class="headerlink" title="and introduction"></a>and introduction</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> and_intro : <span class="keyword">forall</span> A B : <span class="keyword">Prop</span>, A -&gt; B -&gt; A /\ B.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> A B HA HB. <span class="built_in">split</span>.</span><br><span class="line">  - <span class="built_in">apply</span> HA.</span><br><span class="line">  - <span class="built_in">apply</span> HB.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>To prove a conjunction, </p>
<ul>
<li>use the <code>split</code> tactic. It will generate two subgoals,</li>
<li>or use <code>apply and_intro.</code>, which match the conclusion and give its two premises as your subgoals.</li>
</ul>
</blockquote>
<h4 id="and-elimination"><a href="#and-elimination" class="headerlink" title="and elimination"></a>and elimination</h4><p>if we already have a proof of <code>and</code>, <code>destruct</code> can give us both.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> and_example2&#x27; :</span><br><span class="line">  ∀n m : nat, n = <span class="number">0</span> ∧ m = <span class="number">0</span> → n + m = <span class="number">0.</span></span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n m [Hn Hm]. <span class="comment">(* = intro H. destruct H. *)</span></span><br><span class="line">  <span class="built_in">rewrite</span> Hn. <span class="built_in">rewrite</span> Hm. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.  <span class="comment">(* you could use only one *)</span></span><br></pre></td></tr></table></figure>

<p>Instead of packing into conjunction <code>∀n m : nat, n = 0 ∧ m = 0 → n + m = 0.</code><br>why not two separate premises?      <code>∀n m : nat, n = 0 -&gt; m = 0 → n + m = 0.</code><br>Both are fine in this case but conjunction are useful as intermediate step etc.</p>
<blockquote>
<p>Coq Intensive Q: why <code>destruct</code> can work on <code>and</code>? is <code>and</code> inductively defined?<br>A: Yes.</p>
</blockquote>
<h3 id="Disjunction-locial-or"><a href="#Disjunction-locial-or" class="headerlink" title="Disjunction (locial or)"></a>Disjunction (locial or)</h3><h4 id="or-elimination"><a href="#or-elimination" class="headerlink" title="or elimination"></a>or elimination</h4><p>We need do case analysis (either <code>P</code> or <code>Q</code> should be able to prove the theroem separately!)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> or_example :</span><br><span class="line">  <span class="keyword">forall</span> n m : nat, n = <span class="number">0</span> \/ m = <span class="number">0</span> -&gt; n * m = <span class="number">0.</span></span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="comment">(* This pattern implicitly does case analysis on [n = 0 \/ m = 0] *)</span></span><br><span class="line">  <span class="built_in">intros</span> n m [Hn | <span class="type">Hm</span>]. <span class="comment">(* = intro H. destruct H. *)</span></span><br><span class="line">  - <span class="comment">(* Here, [n = 0] *)</span> <span class="built_in">rewrite</span> Hn. <span class="built_in">reflexivity</span>.</span><br><span class="line">  - <span class="comment">(* Here, [m = 0] *)</span> <span class="built_in">rewrite</span> Hm. <span class="built_in">rewrite</span> &lt;- mult_n_O. <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<h4 id="or-introduction"><a href="#or-introduction" class="headerlink" title="or introduction"></a>or introduction</h4><p>When trying to establish (intro into conclusion) an <code>or</code>, using <code>left</code> or <code>right</code> to pick one side to prove is sufficient.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> or_intro : <span class="keyword">forall</span> A B : <span class="keyword">Prop</span>, A -&gt; A \/ B.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> A B HA.</span><br><span class="line">  <span class="built_in">left</span>.  <span class="comment">(* tactics *)</span></span><br><span class="line">  <span class="built_in">apply</span> HA.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>



<h3 id="Falsehood-and-negation"><a href="#Falsehood-and-negation" class="headerlink" title="Falsehood and negation"></a>Falsehood and negation</h3><h4 id="False"><a href="#False" class="headerlink" title="False?"></a>False?</h4><p>Recall the <em>princple of explosion</em>: it asserts that, if we assume a <em>contradiction</em>, then any other proposition can be derived.<br>we could define <code>¬ P</code> (“not P”) as <code>∀ Q, P → Q.</code>. </p>
<blockquote>
<p>Coq actually makes a slightly different (but equivalent) choice, defining <code>¬ P as P → False</code>, where <code>False</code> is a specific <em>contradictory proposition</em> defined in the standard library. </p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> not (P:<span class="keyword">Prop</span>) := P → False.</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;¬x&quot;</span> := (not x) : type_scope.</span><br></pre></td></tr></table></figure>

<p>Prove the <em>princple of explosion</em>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> ex_falso_quodlibet : <span class="keyword">forall</span> (P:<span class="keyword">Prop</span>),</span><br><span class="line">  False -&gt; P.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> P contra.</span><br><span class="line">  <span class="built_in">destruct</span> contra.  <span class="keyword">Qed</span>.  <span class="comment">(* 0 cases to prove since ⊥ is not provable. [inversion] also works *)</span></span><br></pre></td></tr></table></figure>


<h4 id="Inequality"><a href="#Inequality" class="headerlink" title="Inequality"></a>Inequality</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;x &lt;&gt; y&quot;</span> := (~(x = y)).</span><br></pre></td></tr></table></figure>

<p>Same as SML and OCaml (for structural equality, OCaml uses <code>!=</code> for physical equality.)</p>
<h4 id="Proving-of-negation-or-how-to-prove-¬P"><a href="#Proving-of-negation-or-how-to-prove-¬P" class="headerlink" title="Proving of negation (or how to prove ¬P)"></a>Proving of negation (or how to prove <code>¬P</code>)</h4><p>thinking about as <code>unfold not</code>, i.e. <code>P -&gt; False</code>.<br>so you have an assumptions <code>P</code> that could be <code>intros HP.</code> and the residual goal would be simply <code>False</code>.<br>which is usually proved by some kind of contradiction in hypotheses with tactics <code>discriminate.</code> or <code>contradiction.</code></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> contradiction_implies_anything : <span class="keyword">forall</span> P Q : <span class="keyword">Prop</span>,</span><br><span class="line">  (P /\ ~P) -&gt; Q.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> P Q [HP HNA].                 <span class="comment">(* we could [contradiction.] to end the proof here`*)</span></span><br><span class="line">  <span class="built_in">unfold</span> not <span class="built_in">in</span> HNA. <span class="built_in">apply</span> HNA <span class="built_in">in</span> HP.  <span class="comment">(* HP : False, HNA : P -&gt; False  ⊢  HP: False  *)</span></span><br><span class="line">  <span class="built_in">destruct</span> HP.  <span class="keyword">Qed</span>.                   <span class="comment">(* destruct False.  *)</span></span><br></pre></td></tr></table></figure>

<h4 id="Tactic-exfalso"><a href="#Tactic-exfalso" class="headerlink" title="Tactic exfalso."></a>Tactic <code>exfalso.</code></h4><blockquote>
<p>If you are trying to prove a goal that is nonsensical (e.g., the goal state is <code>false = true</code>), apply <code>ex_falso_quodlibet</code> to change the goal to <code>False</code>. This makes it easier to use assumptions of the form <code>¬P</code> that may be available in the context — in particular, assumptions of the form <code>x≠y</code>.</p>
</blockquote>
<blockquote>
<p>Since reasoning with <code>ex_falso_quodlibet</code> is quite common, Coq provides a built-in tactic, <code>exfalso</code>, for applying it.</p>
</blockquote>
<h2 id="Slide-Q-A-2"><a href="#Slide-Q-A-2" class="headerlink" title="Slide Q&amp;A - 2"></a>Slide Q&amp;A - 2</h2><blockquote>
<p>?<code>unfold</code> is implicit</p>
</blockquote>
<ol>
<li>only <code>destruct</code> (if we consider <code>intros</code> destruct is also <code>destruct</code>.), ?<code>unfold</code></li>
<li>none (?<code>unfold</code>)</li>
<li><code>left.</code></li>
<li><code>destruct</code>, <code>unfold</code>, <code>left</code> and <code>right</code></li>
<li><code>discrinminate</code> (or <code>inversion</code>)</li>
</ol>
<h3 id="Truth"><a href="#Truth" class="headerlink" title="Truth"></a>Truth</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> True_is_true : True.</span><br><span class="line"><span class="keyword">Proof</span>. <span class="built_in">apply</span> I. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p><code>I : True</code> is a predefined Prop…</p>
<h3 id="Logical-Equivalence"><a href="#Logical-Equivalence" class="headerlink" title="Logical Equivalence"></a>Logical Equivalence</h3><p><em>if and only if</em> is just the conjunction of two implications. (so we need <code>split</code> to get 2 subgoals)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> iff (P Q : <span class="keyword">Prop</span>) := (P → Q) ∧ (Q → P).</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;P ↔ Q&quot;</span> := (iff P Q)</span><br><span class="line">                    (<span class="built_in">at</span> level <span class="number">95</span>, no associativity) : type_scope.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>rewrite</code> and <code>reflexivity</code> can be used with iff statements, not just equalities.</p>
</blockquote>
<h3 id="Existential-Quantification"><a href="#Existential-Quantification" class="headerlink" title="Existential Quantification"></a>Existential Quantification</h3><p>To prove a statement of the form <code>∃x, P</code>, we must show that <code>P</code> holds for some specific choice of value for <code>x</code>,<br>known as the <strong>witness</strong> of the existential.</p>
<p>So we explicitly tell Coq which witness <code>t</code> we have in mind by invoking <code>exists t</code>.<br>then all occurences of that “type variable” would be replaced.</p>
<h4 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> four_is_even : <span class="built_in">exists</span> n : nat, <span class="number">4</span> = n + n.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">exists</span> <span class="number">2.</span> <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<h4 id="Elim"><a href="#Elim" class="headerlink" title="Elim"></a>Elim</h4><p>Below is an interesting question…by intros and destruct we can have equation <code>n = 4 + m</code> in hypotheses.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> exists_example_2 : <span class="keyword">forall</span> n,</span><br><span class="line">  (<span class="built_in">exists</span> m, n = <span class="number">4</span> + m) -&gt;</span><br><span class="line">  (<span class="built_in">exists</span> o, n = <span class="number">2</span> + o).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n [m Hm]. <span class="comment">(* note implicit [destruct] here *)</span></span><br><span class="line">  <span class="built_in">exists</span> (<span class="number">2</span> + m).</span><br><span class="line">  <span class="built_in">apply</span> Hm.  <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>



<h2 id="Programming-with-Propositions"><a href="#Programming-with-Propositions" class="headerlink" title="Programming with Propositions"></a>Programming with Propositions</h2><p>Considering writing a common recursive <code>is_in</code> for polymorphic lists.<br>(Though we dont have a polymorphic <code>=?</code> (<code>eqb</code>) defined yet) </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> is_in &#123;A : <span class="keyword">Type</span>&#125; (x : A) (l : list A) : bool :=</span><br><span class="line">  <span class="keyword">match</span> l <span class="built_in">with</span></span><br><span class="line">  | <span class="type">[] =&gt; false</span></span><br><span class="line">  | <span class="type">x</span>&#x27; :: l&#x27; =&gt; <span class="keyword">if</span> (x&#x27; =? x) <span class="keyword">then</span> true <span class="keyword">else</span> is_in x l&#x27;</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>Similarly, we can write this function but with disjunction and return a <code>Prop</code>!<br><em>so we can write function to generate&#x2F;create statements&#x2F;propositions!</em> (thx for the idea Prop is first-class)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> In &#123;A : <span class="keyword">Type</span>&#125; (x : A) (l : list A) : <span class="keyword">Prop</span> :=</span><br><span class="line">  <span class="keyword">match</span> l <span class="built_in">with</span></span><br><span class="line">  | <span class="type">[] =&gt; False</span></span><br><span class="line">  | <span class="type">x</span>&#x27; :: l&#x27; =&gt; x&#x27; = x ∨ In x l&#x27;</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>The whole thing I understood as a <em>type operator</em> (function in type level) and it’s <em>recursive</em>!</p>
<p>Coq dare to do that becuz its <em>total</em>, which is guarded by its <em>termination checker</em>.<br>un-total PL, if having this, would make its type system <em>Turing Complete</em> (thus having <em>Halting Problem</em>).<br>(Recursive Type like ADT&#x2F;GADT in ML&#x2F;Haskell is a limited form of recursion allowing no arbitray recursion.)</p>
<h3 id="In-map"><a href="#In-map" class="headerlink" title="In_map"></a>In_map</h3><p>I took this one since it’s like a formal version of <em>Property-based Tests</em>!.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> In_map :</span><br><span class="line">  <span class="keyword">forall</span> (A B : <span class="keyword">Type</span>) (f : A -&gt; B) (l : list A) (x : A),</span><br><span class="line">    In x l -&gt;</span><br><span class="line">    In (f x) (map f l).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> A B f l x.</span><br><span class="line">  <span class="built_in">induction</span> l <span class="built_in">as</span> [|<span class="type">x</span>&#x27; l&#x27; IHl&#x27;].</span><br><span class="line">  - <span class="comment">(* l = nil, contradiction *)</span></span><br><span class="line">    <span class="built_in">simpl</span>. <span class="built_in">intros</span> [].</span><br><span class="line">  - <span class="comment">(* l = x&#x27; :: l&#x27; *)</span></span><br><span class="line">    <span class="built_in">simpl</span>. <span class="built_in">intros</span> [H | <span class="type">H</span>].           <span class="comment">(* evaluating [In] gives us 2 cases:  *)</span></span><br><span class="line">    + <span class="built_in">rewrite</span> H. <span class="built_in">left</span>. <span class="built_in">reflexivity</span>.  <span class="comment">(* in head of l *)</span></span><br><span class="line">    + <span class="built_in">right</span>. <span class="built_in">apply</span> IHl&#x27;. <span class="built_in">apply</span> H.    <span class="comment">(* in tail of l*)</span></span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Q &amp; A: </p>
<ol>
<li><code>eq</code> is just another inductively defined and doesn’t have any computational content. (satisfication)</li>
<li>Why use <code>Prop</code> instead of <code>bool</code>? See <em>reflection</em> below.</li>
</ol>
</blockquote>
<h3 id="Drawbacks"><a href="#Drawbacks" class="headerlink" title="Drawbacks"></a>Drawbacks</h3><blockquote>
<p>In particular, it is subject to Coq’s usual restrictions regarding the definition of recursive functions,<br>e.g., the requirement that they be “obviously terminating.”</p>
</blockquote>
<blockquote>
<p>In the next chapter, we will see how to define propositions <em>inductively</em>,<br>a different technique with its own set of strengths and limitations.</p>
</blockquote>
<h2 id="Applying-Theorems-to-Arguments"><a href="#Applying-Theorems-to-Arguments" class="headerlink" title="Applying Theorems to Arguments."></a>Applying Theorems to Arguments.</h2><h3 id="Check-some-theorem-print-the-statement"><a href="#Check-some-theorem-print-the-statement" class="headerlink" title="Check some_theorem print the statement!"></a><code>Check some_theorem</code> print the statement!</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> plus_comm.</span><br><span class="line"><span class="comment">(* ===&gt; forall n m : nat, n + m = m + n *)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Coq prints the <em>statement</em> of the <code>plus_comm</code> theorem in the same way that it prints the <em>type</em> of any term that we ask it to Check. Why?</p>
</blockquote>
<p>Hmm…I just noticed that!!<br>But I should notice because <strong>Propositions are Types! (and terms are proof)</strong></p>
<h3 id="Proof-Object"><a href="#Proof-Object" class="headerlink" title="Proof Object"></a>Proof Object</h3><blockquote>
<p><em>proofs</em> as first-class objects.</p>
</blockquote>
<p>After <code>Qed.</code>, Coq defined they as <em>Proof Object</em> and the <em>type of this obj</em> is the statement of the theorem.</p>
<blockquote>
<p>Provable: some type is inhabited by some thing (having terms).</p>
</blockquote>
<p>So I guess when we apply theorems, Coq implicitly use the type of the Proof Object. (it’s already type abstraction)<br>…we will get to there later at ProofObject chapter.</p>
<h3 id="Apply-theorem-as-function"><a href="#Apply-theorem-as-function" class="headerlink" title="Apply theorem as function"></a>Apply theorem as function</h3><blockquote>
<p><code>rewrite</code> select variables greedily by default</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> plus_comm3_take3 :</span><br><span class="line">  ∀x y z, x + (y + z) = (z + y) + x.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> x y z.</span><br><span class="line">  <span class="built_in">rewrite</span> plus_comm.</span><br><span class="line">  <span class="built_in">rewrite</span> (plus_comm y z).     <span class="comment">(* we can explicitly provide type var! *)</span></span><br><span class="line">  <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p><code>x y z</code> were some type var and <em>instantiated to values</em> by <code>intros</code>, e.g. <code>x, y, z:nat</code><br>but we can explicilty pass in to <code>plus_comm</code>, which is a forall type abstraction! (<code>Δ n m. (eq (n + m) (m + n))</code>) </p>
<blockquote>
<p>there must be something there in Proof Object so we can apply <em>values</em> to a <em>type-level function</em></p>
</blockquote>
<h2 id="Coq-vs-Set-Theory"><a href="#Coq-vs-Set-Theory" class="headerlink" title="Coq vs. Set Theory"></a>Coq vs. Set Theory</h2><p>Coq’s logical core, <em>the Calculus of Inductive Constructions</em>, is a <em>metalanguage for math</em>, but differs from other foundations of math e.g. ZFC Set Theory</p>
<h3 id="Functional-Extensionality"><a href="#Functional-Extensionality" class="headerlink" title="Functional Extensionality"></a>Functional Extensionality</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(∀x, f x = g x) → f = g</span><br><span class="line"></span><br><span class="line">∃f g, (∀x, f x = g x) → f = g</span><br><span class="line"></span><br><span class="line">∃f g, (∀x, f x = g x) ∧ f != g    <span class="comment">(* negation, consistent but not interesting... *)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>In common math practice, two functions <code>f</code> and <code>g</code> are considered equal if they produce the same outputs.<br>This is known as the principle of <em>functional extensionality</em>.</p>
</blockquote>
<blockquote>
<p>Informally speaking, an “extensional property” is one that pertains to an object’s observable behavior.<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Extensionality">https://en.wikipedia.org/wiki/Extensionality</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Extensional_and_intensional_definitions">https://en.wikipedia.org/wiki/Extensional_and_intensional_definitions</a>?</p>
</blockquote>
<p>This is not built-in Coq, but we can add them as Axioms.<br>Why not add everything?</p>
<blockquote>
<ol>
<li>One or multiple axioms combined might render <em>inconsistency</em>.</li>
<li>Code extraction might be problematic</li>
</ol>
</blockquote>
<blockquote>
<p>Fortunately, it is known that adding functional extensionality, in particular, is consistent.<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consistency">consistency</a>:<br>   a consistent theory is one that does not contain a contradiction.</p>
</blockquote>
<h3 id="Adding-Axioms"><a href="#Adding-Axioms" class="headerlink" title="Adding Axioms"></a>Adding Axioms</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Axiom</span> functional_extensionality : <span class="keyword">forall</span> &#123;X Y: <span class="keyword">Type</span>&#125;</span><br><span class="line">                                    &#123;f g : X -&gt; Y&#125;,</span><br><span class="line">  (<span class="keyword">forall</span> (x:X), f x = g x) -&gt; f = g.</span><br></pre></td></tr></table></figure>

<p>It’s like <code>Admitted.</code> but alerts we’re not going to fill in later. </p>
<h3 id="Exercise-Proving-Reverse-with-app-and-with-cons-are-fn-exensionally-equivalent"><a href="#Exercise-Proving-Reverse-with-app-and-with-cons-are-fn-exensionally-equivalent" class="headerlink" title="Exercise - Proving Reverse with app and with cons are fn-exensionally equivalent."></a>Exercise - Proving Reverse with <code>app</code> and with <code>cons</code> are fn-exensionally equivalent.</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> rev_append &#123;X&#125; (l1 l2 : list X) : list X :=</span><br><span class="line">  <span class="keyword">match</span> l1 <span class="built_in">with</span></span><br><span class="line">  | <span class="type">[] =&gt; l2</span></span><br><span class="line">  | <span class="type">x</span> :: l1&#x27; =&gt; rev_append l1&#x27; (x :: l2)</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Definition</span> tr_rev &#123;X&#125; (l : list X) : list X :=</span><br><span class="line">  rev_append l [].</span><br></pre></td></tr></table></figure>

<p>BTW, this version is <code>tail recursive</code> becuz the recursive call is the last operation needs to performed.<br>(In <code>rev</code> i.e. <code>rev t ++ [h]</code>, recursive call is a argument of function <code>++</code> and we are CBV.)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> tr_rev_correct : <span class="keyword">forall</span> X, @tr_rev X = @rev X.</span><br></pre></td></tr></table></figure>



<h3 id="Propositions-and-Booleans"><a href="#Propositions-and-Booleans" class="headerlink" title="Propositions and Booleans"></a>Propositions and Booleans</h3><blockquote>
<p>We’ve seen two different ways of expressing logical claims in Coq: </p>
<ol>
<li>with booleans     (of type <code>bool</code>),  ; computational way</li>
<li>with propositions (of type <code>Prop</code>).  ; logical way</li>
</ol>
</blockquote>
<p>There’re two ways to define 42 is even:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> even_42_bool : evenb <span class="number">42</span> = true.</span><br><span class="line"><span class="keyword">Example</span> even_42_prop : ∃k, <span class="number">42</span> = <span class="built_in">double</span> k.</span><br></pre></td></tr></table></figure>

<p>We wanna show there are <em>interchangable</em>.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> even_bool_prop : ∀n,</span><br><span class="line">  evenb n = true ↔ ∃k, n = <span class="built_in">double</span> k.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>In view of this theorem, we say that the<br>boolean computation <code>evenb n</code> <em>reflects</em> the truth of the proposition <code>∃ k, n = double k</code>.</p>
</blockquote>
<p>We can futhur general this to any equations representing as <code>bool</code> or <code>Prop</code>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> eqb_eq : ∀n1 n2 : nat,</span><br><span class="line">  n1 =? n2 = true ↔ n1 = n2.</span><br></pre></td></tr></table></figure>

<h4 id="Notes-on-Computability"><a href="#Notes-on-Computability" class="headerlink" title="Notes on Computability."></a>Notes on Computability.</h4><blockquote>
<p>However, even they are equivalent from a purely logical perspective,<br>they may not be equivalent <code>operationally</code>.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fail <span class="keyword">Definition</span> is_even_prime n :=</span><br><span class="line">  <span class="keyword">if</span> n = <span class="number">2</span> <span class="keyword">then</span> true</span><br><span class="line">  <span class="keyword">else</span> false.</span><br><span class="line"></span><br><span class="line">Error: The term <span class="string">&quot;n = 2&quot;</span> has type <span class="string">&quot;Prop&quot;</span> which is not a (co-)inductive type.</span><br></pre></td></tr></table></figure>

<p><code>=</code>, or <code>eq</code>, as any function in Coq, need to be computable and total. And we have no way to tell <em>whether any given proposition is true or false</em>. (…We can only naturally deduce things are inductively defined)</p>
<blockquote>
<p>As a consequence, Prop in Coq does not have a universal case analysis operation telling whether any given proposition is true or false, since such an operation would allow us to write non-computable functions.</p>
</blockquote>
<blockquote>
<p>Although general non-computable properties cannot be phrased as boolean computations, it is worth noting that even many computable properties are easier to express using Prop than bool, since recursive function definitions are subject to significant restrictions in Coq.</p>
</blockquote>
<p>E.g. Verifying Regular Expr in next chapter. </p>
<blockquote>
<p>Doing the same with <code>bool</code> would amount to writing a <em>full regular expression matcher</em> (so we can execute the regex).</p>
</blockquote>
<h4 id="Proof-by-Reflection"><a href="#Proof-by-Reflection" class="headerlink" title="Proof by Reflection!"></a>Proof by Reflection!</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(* Logically *)</span></span><br><span class="line"><span class="keyword">Example</span> even_1000 : ∃k, <span class="number">1000</span> = <span class="built_in">double</span> k.</span><br><span class="line"><span class="keyword">Proof</span>. ∃<span class="number">500.</span> <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">(* Computationally *)</span></span><br><span class="line"><span class="keyword">Example</span> even_1000&#x27; : evenb <span class="number">1000</span> = true.</span><br><span class="line"><span class="keyword">Proof</span>. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">(* Prove logical version by reflecting in computational version *)</span></span><br><span class="line"><span class="keyword">Example</span> even_1000&#x27;&#x27; : ∃k, <span class="number">1000</span> = <span class="built_in">double</span> k.</span><br><span class="line"><span class="keyword">Proof</span>. <span class="built_in">apply</span> even_bool_prop. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>As an extreme example, the Coq proof of the famous <em>4-color theorem</em> uses reflection to reduce the analysis of hundreds of different cases to a boolean computation.</p>
</blockquote>
<h3 id="Classical-vs-Constructive-Logic"><a href="#Classical-vs-Constructive-Logic" class="headerlink" title="Classical vs. Constructive Logic"></a>Classical vs. Constructive Logic</h3><p>…</p>
<h2 id="Future-Schedule"><a href="#Future-Schedule" class="headerlink" title="Future Schedule"></a>Future Schedule</h2><blockquote>
<p>Proof got messier!<br>Lean on your past PLT experience</p>
</blockquote>
<p>As discussion leader</p>
<ul>
<li>having many materials now</li>
<li>selected troublesome and interesting ones</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_lf/2019-01-07-sf-lf-07-indprop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_lf/2019-01-07-sf-lf-07-indprop/" class="post-title-link" itemprop="url">「SF-LC」7 Ind Prop</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Inductively-Defined-Propositions"><a href="#Inductively-Defined-Propositions" class="headerlink" title="Inductively Defined Propositions "></a>Inductively Defined Propositions </h2><h3 id="The-3rd-way-to-state-Evenness…"><a href="#The-3rd-way-to-state-Evenness…" class="headerlink" title="The 3rd way to state Evenness…"></a>The 3rd way to state Evenness…</h3><p>Besides: </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> even_bool_prop : ∀n,</span><br><span class="line">  evenb n = true ↔ ∃k, n = <span class="built_in">double</span> k.</span><br><span class="line"> <span class="comment">(*bool*)</span>                 <span class="comment">(*prop*)</span></span><br></pre></td></tr></table></figure>

<p>we can write an <em>Inductive definition</em> of the <code>even</code> property!</p>
<h3 id="Inference-rules"><a href="#Inference-rules" class="headerlink" title="Inference rules"></a>Inference rules</h3><p>In CS, we often uses <em>inference rules</em> </p>
<pre><code>                    ev n
---- ev_0       ------------ ev_SS
ev 0            ev (S (S n))
</code></pre>
<p>and <em>proof tree</em> (i.e. evidence), there could be multiple premieses to make it more tree-ish.</p>
<pre><code>---- ev_0
ev 0
---- ev_SS
ev 2
---- ev_SS
ev 4
</code></pre>
<p>So we can literally translate them into a GADT:</p>
<h3 id="Inductive-Definition-of-Evenness"><a href="#Inductive-Definition-of-Evenness" class="headerlink" title="Inductive Definition of Evenness"></a>Inductive Definition of Evenness</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> even : nat → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">ev_0</span>  : even <span class="number">0</span></span><br><span class="line">  | <span class="type">ev_SS</span> : ∀n, even n → even (S (S n)). </span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> even_SS.</span><br><span class="line"><span class="comment">(* ==&gt; : forall n : nat, even n -&gt; even (S (S n)) *)</span></span><br></pre></td></tr></table></figure>

<p>There are two ways to understand the <code>even</code> here:</p>
<h3 id="1-A-Property-of-nat-and-two-theorems-Intuitively"><a href="#1-A-Property-of-nat-and-two-theorems-Intuitively" class="headerlink" title="1. A Property of nat and two theorems (Intuitively)"></a>1. A Property of <code>nat</code> and two theorems (Intuitively)</h3><blockquote>
<p>the thing we are defining is not a <code>Type</code>, but rather a function <code>nat -&gt; Prop</code> — i.e., a property of numbers. </p>
</blockquote>
<p>we have two ways to provide an evidence to show the <code>nat</code> is <code>even</code>, either or:</p>
<ol>
<li>it’s <code>0</code>, we can immediately conclude it’s <code>even</code>.</li>
<li>for any <code>n</code>, if we can provide a evidence that <code>n</code> is <code>even</code>, then <code>S (S n)</code> is <code>even</code> as well.</li>
</ol>
<blockquote>
<p>We can think of the definition of <code>even</code> as defining a Coq property <code>even : nat → Prop</code>, together with primitive theorems <code>ev_0 : even 0</code> and <code>ev_SS : ∀ n, even n → even (S (S n))</code>.</p>
</blockquote>
<h3 id="2-An-“Indexed”-GADT-and-two-constructors-Technically"><a href="#2-An-“Indexed”-GADT-and-two-constructors-Technically" class="headerlink" title="2. An “Indexed” GADT and two constructors (Technically)"></a>2. An “Indexed” GADT and two constructors (Technically)</h3><blockquote>
<p>In an Inductive definition, an argument to the type constructor on the left of the colon is called a “parameter”, whereas an argument on the right is called an “index”. – “Software Foundaton”</p>
</blockquote>
<p>Considered a “parametrized” ADT such as the polymorphic list, </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> list (X:<span class="keyword">Type</span>) : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">nil</span></span><br><span class="line">  | <span class="type">cons</span> (x : X) (l : list X).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> list. <span class="comment">(* ===&gt; list : Type -&gt; Type *)</span></span><br></pre></td></tr></table></figure>

<p>where we defined type con <code>list : Type -&gt; Type</code>, by having a type var <code>X</code> in the left of the <code>:</code>.<br>the <code>X</code> is called a <em>parameter</em> and would be <em>parametrized i.e. substituted, globally</em>, in constructors.</p>
<p>Here, we write <code>nat</code> in the right of the <code>:</code> w&#x2F;o giving it a name (to refer and to substitute),<br>which allows the <code>nat</code> taking different values in different constructors (as constraints).<br>it’s called an <em>index</em> and will form a family of type indexed by <code>nat</code> (to type check?)</p>
<p>From this perspective, there is an alternative way to write this GADT:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> even : nat → <span class="keyword">Prop</span> :=</span><br><span class="line">| <span class="type">ev_0</span>                         : even <span class="number">0</span></span><br><span class="line">| <span class="type">ev_SS</span> (n : nat) (H : even n) : even (S (S n)).</span><br></pre></td></tr></table></figure>

<p>we have two ways to construct the <code>even</code> type (<code>Prop &lt;: Type</code>), either or:</p>
<ol>
<li><code>ev_0</code> takes no argument, so simply instantiate <code>even</code> with <code>nat</code> 0</li>
<li><code>ev_SS</code> takes a <code>nat</code> <code>n</code> and a <code>H</code> typed <code>even n</code>,</li>
</ol>
<ul>
<li>the <em>dependency</em> between two arguments thus established! </li>
<li>as long as the <em>constraint on same <code>n</code></em> is fullfilled, we can build type <code>even</code> with <code>S (S n)</code></li>
</ul>
<p>The take way is that <em>dependent type (Pi-type)</em> allow us to constriant constructors with different values.</p>
<blockquote>
<p><em>indexed</em> way is more general. it formed a larger type, and is only used when extra power needed.<br>every parametrized one can be represented as indexed one (it’s just that index happended to be the same)</p>
</blockquote>
<h3 id="“Constructor-Theorems”"><a href="#“Constructor-Theorems”" class="headerlink" title="“Constructor Theorems”"></a>“Constructor Theorems”</h3><blockquote>
<p>Such “constructor theorems” have the same status as proven theorems. In particular, we can use Coq’s <code>apply</code> tactic with the rule names to prove <code>even</code> for particular numbers…</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> ev_4 : even <span class="number">4.</span></span><br><span class="line"><span class="keyword">Proof</span>. <span class="built_in">apply</span> ev_SS. <span class="built_in">apply</span> ev_SS. <span class="built_in">apply</span> ev_0. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>Proof States Transition:</p>
<pre><code>even 4
------ apply ev_SS.
even 2
------ apply ev_SS.
even 0
------ apply ev_0.
       Qed.
</code></pre>
<p>I believed what <code>apply</code> do is trying to <em>backward reasoning</em>, i.e. matching the goal and leave the “evidence” need to be proved (to conclude the goal).</p>
<p>we can write it as normal function application syntax w&#x2F;o using tactics like other Dependent-typed PL as well</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> ev_4&#x27; : even <span class="number">4.</span></span><br><span class="line"><span class="keyword">Proof</span>. <span class="built_in">apply</span> (ev_SS <span class="number">2</span> (ev_SS <span class="number">0</span> ev_0)). <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>


<h2 id="Using-Evidence-in-Proofs"><a href="#Using-Evidence-in-Proofs" class="headerlink" title="Using Evidence in Proofs"></a>Using Evidence in Proofs</h2><blockquote>
<p>Besides <em>constructing evidence</em> that numbers are even, we can also <em>reason</em> about such evidence.</p>
</blockquote>
<blockquote>
<p>Introducing <code>even</code> with an <code>Inductive</code> declaration tells Coq that these two constructors are the <strong>only</strong> ways to build evidence that numbers are <code>even</code>. </p>
</blockquote>
<blockquote>
<p>In other words, if someone gives us evidence <code>E</code> for the assertion <code>even n</code>, then we know that <code>E</code> must have one of two shapes</p>
</blockquote>
<blockquote>
<p>This suggests that it should be possible to analyze a hypothesis of the form <code>even n</code> much <em>as we do inductively defined data structures</em>; in particular, it should be possible to argue by <strong>induction</strong> and <strong>case analysis</strong> on such evidence.</p>
</blockquote>
<p>This starts to get familiar as what we did for many calculi, ranging from Logics to PLT.<br>This is called the <strong>Inversion property</strong>.</p>
<h3 id="Inversion-on-Evidence"><a href="#Inversion-on-Evidence" class="headerlink" title="Inversion on Evidence"></a>Inversion on Evidence</h3><p>We can prove the inersion property by ourselves:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> ev_inversion :</span><br><span class="line">  ∀(n : nat), even n →</span><br><span class="line">    (n = <span class="number">0</span>) ∨ (∃n&#x27;, n = S (S n&#x27;) ∧ even n&#x27;).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n E.</span><br><span class="line">  <span class="built_in">destruct</span> E <span class="built_in">as</span> [ | <span class="type">n</span>&#x27; E&#x27;].</span><br><span class="line">  - <span class="comment">(* E = ev_0 : even 0 *)</span>                  <span class="built_in">left</span>. <span class="built_in">reflexivity</span>.</span><br><span class="line">  - <span class="comment">(* E = ev_SS n&#x27;, E&#x27; : even (S (S n&#x27;)) *)</span> <span class="built_in">right</span>. ∃n&#x27;. <span class="built_in">split</span>. <span class="built_in">reflexivity</span>. <span class="built_in">apply</span> E&#x27;.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>But Coq provide the <code>inversion</code> tactics that does more! (not always good tho, too automagical)</p>
<blockquote>
<p>The inversion tactic does quite a bit of work. When applied to equalities, as a special case, it does the work of both <code>discriminate</code> and <code>injection</code>. In addition, it carries out the <code>intros</code> and <code>rewrite</code>s</p>
</blockquote>
<blockquote>
<p>Here’s how inversion works in general. Suppose the name <code>H</code> refers to an assumption <code>P</code> in the current context, <em>where <code>P</code> has been defined by an <code>Inductive</code> declaration</em>. Then, for each of the constructors of <code>P</code>, <code>inversion H</code> generates a subgoal in which <code>H</code> has been replaced by the <em>exact, specific conditions under which this constructor could have been used to prove <code>P</code></em>.<br>Some of these subgoals will be self-contradictory; inversion throws these away. The ones that are left represent the cases that must be proved to establish the original goal. For those, inversion adds all equations into the proof context that must hold of the arguments given to <code>P</code> (e.g., <code>S (S n&#39;) = n</code> in the proof of <code>evSS_ev</code>).<br>(<code>9-proof-object.md</code> has a better explaination on <code>inversion</code>)</p>
</blockquote>
<p><code>inversion</code> is a specific use upon <code>destruct</code> (both do case analysis on constructors), but many property need <code>induction</code>!.<br>By <code>induction (even n)</code>, we have cases and subgoals splitted, and induction hypothesis as well.</p>
<h3 id="Induction-on-Evidence"><a href="#Induction-on-Evidence" class="headerlink" title="Induction on Evidence"></a>Induction on Evidence</h3><p>Similar to induction on inductively defined data such as <code>list</code>: </p>
<blockquote>
<p>To prove a property of (for any <code>X</code>)                       <code>list X</code> holds, we can use <code>induction</code> on <code>list X</code>.<br>To prove a property of <code>n</code> holds for all numbers for which <code>even n</code> holds, we can use <code>induction</code> on <code>even n</code>.</p>
</blockquote>
<h4 id="Notes-on-induction"><a href="#Notes-on-induction" class="headerlink" title="Notes on induction"></a>Notes on induction</h4><p><em>The principle of induction</em> is to prove <code>P(n-1) -&gt; P(n)</code> (多米诺) for some (well-founded partial order) set of <code>n</code>. </p>
<p>Here, we are induction over “the set of numbers fullfilling the property <code>even</code>“.<br>Noticed that we r proving things over this set, meaning we already have it (i.e. a proof, or a evidence) in premises, instead of proving the <code>even</code>ness of the set.</p>
<h4 id="Proof-by-Mathematical-Induction-is-Deductive-Reasoning"><a href="#Proof-by-Mathematical-Induction-is-Deductive-Reasoning" class="headerlink" title="Proof by Mathematical Induction is Deductive Reasoning"></a>Proof by Mathematical Induction is Deductive Reasoning</h4><blockquote>
<p>“Proof by induction,” despite the name, is deductive. The reason is that proof by induction does not simply involve “going from many specific cases to the general case.” Instead, in order for proof by induction to work, we need a deductive proof that each specific case implies the next specific case. Mathematical induction is not philosophical induction.<br><a target="_blank" rel="noopener" href="https://math.stackexchange.com/a/1960895/528269">https://math.stackexchange.com/a/1960895/528269</a></p>
</blockquote>
<blockquote>
<p>Mathematical induction is an inference rule used in formal proofs. Proofs by mathematical induction are, in fact, examples of deductive reasoning.<br>Equivalence with the well-ordering principle: The principle of mathematical induction is usually stated as an axiom of the natural numbers; see Peano axioms. However, it can be proved from the well-ordering principle. Indeed, suppose the following:<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mathematical_induction">https://en.wikipedia.org/wiki/Mathematical_induction</a></p>
</blockquote>
<h4 id="Also-Structual-Induction-is-one-kind-of-Math-Induction"><a href="#Also-Structual-Induction-is-one-kind-of-Math-Induction" class="headerlink" title="Also, Structual Induction is one kind of Math. Induction"></a>Also, Structual Induction is one kind of Math. Induction</h4><blockquote>
<p>和标准的数学归纳法等价于良序原理一样，结构归纳法也等价于良序原理。</p>
</blockquote>
<blockquote>
<p>…A <em>well-founded</em> <em>partial order</em> is defined on the structures…<br>…Formally speaking, this then satisfies the premises of an <em>axiom of well-founded induction</em>…<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Structural_induction">https://en.wikipedia.org/wiki/Structural_induction</a></p>
</blockquote>
<p>In terms of Well-ordering and Well-founded:</p>
<blockquote>
<p>If the set of all structures of a certain kind admits a well-founded partial order,<br>then every nonempty subset must have a minimal element. (This is the definition of “well-founded”.)<br>如果某种整个结构的集容纳一个良基偏序， 那么每个非空子集一定都含有最小元素。（其实这也是良基的定义</p>
</blockquote>
<h2 id="Inductive-Relations"><a href="#Inductive-Relations" class="headerlink" title="Inductive Relations"></a>Inductive Relations</h2><p>Just as a single-argument proposition defines a <em>property</em>, 性质<br>a two-argument proposition defines a <em>relation</em>. 关系</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> le : nat → nat → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">le_n</span> n                : le n n</span><br><span class="line">  | <span class="type">le_S</span> n m (H : le n m) : le n (S m).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;n ≤ m&quot;</span> := (le n m).</span><br></pre></td></tr></table></figure>

<blockquote>
<p>It says that there are two ways to <em>give evidence</em> that one number is less than or equal to another:</p>
</blockquote>
<ol>
<li>either same number</li>
<li>or give evidence that <code>n ≤ m</code> then we can have <code>n ≤ m + 1</code>.</li>
</ol>
<p>and we can use the same tactics as we did for properties.</p>
<h2 id="Slide-Q-A-1"><a href="#Slide-Q-A-1" class="headerlink" title="Slide Q&amp;A - 1"></a>Slide Q&amp;A - 1</h2><ol>
<li>First <code>destruct</code> <code>even n</code> into 2 cases, then <code>discriminate</code> on each.</li>
</ol>
<p>Another way…<br>rewriting <code>n=1</code> on <code>even n</code>. It won’t compute <code>Prop</code>, but <code>destruct</code> can do some <code>discriminate</code> behind the scene.</p>
<h2 id="Slide-Q-A-2"><a href="#Slide-Q-A-2" class="headerlink" title="Slide Q&amp;A - 2"></a>Slide Q&amp;A - 2</h2><p><code>inversion</code> and <code>rewrite plus_comm</code> (for <code>n+2</code>)</p>
<h2 id="destruct-vs-inversion-vs-induction"><a href="#destruct-vs-inversion-vs-induction" class="headerlink" title="destruct vs. inversion vs. induction."></a><code>destruct</code> vs. <code>inversion</code> vs. <code>induction</code>.</h2><blockquote>
<p><code>destruct</code>, <code>inversion</code>, <code>induction</code> (on general thing)… similar&#x2F;specialized version of each…</p>
</blockquote>
<p>Trying to internalize this concept better: <em>When to use which?</em></p>
<p>For any inductively defined proposition (<code>&lt;: Type</code>) in hypothesis:<br>meaning from type perspective, it’s already a “proper type” (<code>::*</code>)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> P = C1 : P1 | <span class="type">C2</span> : A2 -&gt; P2 | <span class="type">...</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>destruct</code>     case analysis on inductive type</li>
</ol>
<ul>
<li>simply give you each cases, i.e. each constructors.</li>
<li>we can destruct on <code>a =? b</code> since <code>=?</code> is inductively defined.</li>
</ul>
<ol start="2">
<li><code>induction</code>    use induction principle</li>
</ol>
<ul>
<li>proving <code>P</code> holds for all base cases</li>
<li>proving <code>P(n)</code> holds w&#x2F; <code>P(n-1)</code> for all inductive cases<br>(<code>destruct</code> stucks in this case because of no induction hypothesis gained from induction principle)</li>
</ul>
<ol start="3">
<li><code>inversion</code>    invert the conclusion and give you all cases with premises of that case.</li>
</ol>
<p>For GADT, i.e. “indexed” <code>Prop</code> (property&#x2F;relation), <code>P</code> could have many shape<br><code>inversion</code> give you <code>Ax</code> for shape <code>P</code> assuming built with <code>Cx</code></p>
<p><code>inversion</code> discards cases when shape <code>P != Px</code>.<br>(<code>destruct</code> stucks in this case because of no equation gained from inversion lemma)</p>
<h2 id="Case-Study-Regular-Expressions"><a href="#Case-Study-Regular-Expressions" class="headerlink" title="Case Study: Regular Expressions"></a>Case Study: Regular Expressions</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p><em>Definition of RegExp in formal language can be found in FCT&#x2F;CC materials</em></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> reg_exp &#123;T : <span class="keyword">Type</span>&#125; : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">EmptySet</span>                 <span class="comment">(* ∅ *)</span></span><br><span class="line">  | <span class="type">EmptyStr</span>                 <span class="comment">(* ε *)</span></span><br><span class="line">  | <span class="type">Char</span> (t : T)</span><br><span class="line">  | <span class="type">App</span> (r1 r2 : reg_exp)    <span class="comment">(* r1r2 *)</span></span><br><span class="line">  | <span class="type">Union</span> (r1 r2 : reg_exp)  <span class="comment">(* r1 | r2 *)</span></span><br><span class="line">  | <span class="type">Star</span> (r : reg_exp).      <span class="comment">(* r*  *)</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>Note that this definition is <em>polymorphic</em>.<br>We depart slightly in that <em>we do not require the type <code>T</code> to be finite</em>. (difference not significant here)</p>
</blockquote>
<blockquote>
<p><code>reg_exp T</code> describe <em>strings</em> with characters drawn from <code>T</code> — that is, <strong>lists of elements of <code>T</code></strong>. </p>
</blockquote>
<h3 id="Matching"><a href="#Matching" class="headerlink" title="Matching"></a>Matching</h3><p>The matching is somewhat similar to <em>Parser Combinator</em> in Haskell… </p>
<p>e.g.<br><code>EmptyStr</code> matches <code>[]</code><br><code>Char x</code>   matches <code>[x]</code></p>
<blockquote>
<p>we definied it into an <code>Inductive</code> relation (can be displayed as <em>inference-rule</em>).<br>somewhat type-level computing !</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> exp_match &#123;T&#125; : list T → reg_exp → <span class="keyword">Prop</span> :=</span><br><span class="line">| <span class="type">MEmpty</span> : exp_match [] EmptyStr</span><br><span class="line">| <span class="type">MChar</span> x : exp_match [x] (Char x)</span><br><span class="line">| <span class="type">MApp</span> s1 re1 s2 re2</span><br><span class="line">            (H1 : exp_match s1 re1)</span><br><span class="line">            (H2 : exp_match s2 re2) :</span><br><span class="line">            exp_match (s1 ++ s2) (App re1 re2)</span><br><span class="line"><span class="comment">(** etc. **)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;s =~ re&quot;</span> := (exp_match s re) (<span class="built_in">at</span> level <span class="number">80</span>).  <span class="comment">(* the Perl notation! *)</span></span><br></pre></td></tr></table></figure>

<h2 id="Slide-Q-A-3"><a href="#Slide-Q-A-3" class="headerlink" title="Slide Q&amp;A - 3"></a>Slide Q&amp;A - 3</h2><p>The lack of rule for <code>EmptySet</code> (“negative rule”) give us what we want as PLT</p>
<h3 id="Union-and-Star"><a href="#Union-and-Star" class="headerlink" title="Union and Star."></a><code>Union</code> and <code>Star</code>.</h3><blockquote>
<p>the informal rules for <code>Union</code> and <code>Star</code> correspond to <em>two constructors</em> each.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">| <span class="type">MUnionL</span> s1 re1 re2</span><br><span class="line">              (H1 : exp_match s1 re1) :</span><br><span class="line">              exp_match s1 (Union re1 re2)</span><br><span class="line">| <span class="type">MUnionR</span> re1 s2 re2</span><br><span class="line">              (H2 : exp_match s2 re2) :</span><br><span class="line">              exp_match s2 (Union re1 re2)</span><br><span class="line">| <span class="type">MStar0</span> re : exp_match [] (Star re)</span><br><span class="line">| <span class="type">MStarApp</span> s1 s2 re</span><br><span class="line">              (H1 : exp_match s1 re)</span><br><span class="line">              (H2 : exp_match s2 (Star re)) :</span><br><span class="line">              exp_match (s1 ++ s2) (Star re).</span><br></pre></td></tr></table></figure>

<p>Thinking about their <em>NFA</em>: they both have non-deterministic branches!<br>The recursive occurrences of <code>exp_match</code> gives as <em>direct argument</em> (evidence) about which branches we goes.</p>
<blockquote>
<p>we need some <em>sanity check</em> since Coq simply trust what we declared…<br>that’s why there is even Quick Check for Coq.</p>
</blockquote>
<h3 id="Direct-Proof"><a href="#Direct-Proof" class="headerlink" title="Direct Proof"></a>Direct Proof</h3><p>In fact, <code>MApp</code> is also non-deterministic about how does <code>re1</code> and <code>re2</code> collaborate…<br>So we have to be explicit:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> reg_exp_ex2 : [<span class="number">1</span>; <span class="number">2</span>] =~ App (Char <span class="number">1</span>) (Char <span class="number">2</span>).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">apply</span> (MApp [<span class="number">1</span>] <span class="keyword">_</span> [<span class="number">2</span>]).</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h3 id="Inversion-on-Evidence-1"><a href="#Inversion-on-Evidence-1" class="headerlink" title="Inversion on Evidence"></a>Inversion on Evidence</h3><p>This, if we want to prove via <code>destruct</code>,<br>we have to write our own <em>inversion lemma</em> (like <code>ev_inversion</code> for <code>even</code>).<br>Otherwise we have no equation (which we should have) to say <code>contradiction</code>.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> reg_exp_ex3 : ~ ([<span class="number">1</span>; <span class="number">2</span>] =~ Char <span class="number">1</span>).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> H. <span class="built_in">inversion</span> H.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Manual-Manipulation"><a href="#Manual-Manipulation" class="headerlink" title="Manual Manipulation"></a>Manual Manipulation</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> MStar1 :</span><br><span class="line">  <span class="keyword">forall</span> T s (re : @reg_exp T) ,</span><br><span class="line">    s =~ re -&gt;</span><br><span class="line">    s =~ Star re.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> T s re H.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (app_nil_r <span class="keyword">_</span> s).  <span class="comment">(* extra &quot;massaging&quot; to convert [s] =&gt; [s ++ []] *)</span></span><br><span class="line">  <span class="built_in">apply</span> (MStarApp s [] re).    <span class="comment">(* to the shape [MStarApp] expected thus can pattern match on *)</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">(* proving [MStarApp] requires [s1 s2 re H1 H2]. By giving [s [] re], we left two evidence *)</span></span><br><span class="line">      | <span class="type">MStarApp</span> s1 s2 re</span><br><span class="line">          (H1 : exp_match s1 re)</span><br><span class="line">          (H2 : exp_match s2 (Star re)) :</span><br><span class="line">          exp_match (s1 ++ s2) (Star re).</span><br><span class="line"></span><br><span class="line">  - <span class="built_in">apply</span> H.                   <span class="comment">(* evidence H1 *)</span></span><br><span class="line">  - <span class="built_in">apply</span> MStar0.              <span class="comment">(* evidence H2 *)</span></span><br><span class="line"><span class="keyword">Qed</span>.                           <span class="comment">(* the fun fact is that we can really think the _proof_</span></span><br><span class="line"><span class="comment">                                  as providing evidence by _partial application_. *)</span></span><br></pre></td></tr></table></figure>

<h3 id="Induction-on-Evidence-1"><a href="#Induction-on-Evidence-1" class="headerlink" title="Induction on Evidence"></a>Induction on Evidence</h3><blockquote>
<p>By the recursive nature of <code>exp_match</code>, proofs will often require induction.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** Recursively collecting all characters that occur in a regex **)</span></span><br><span class="line"><span class="keyword">Fixpoint</span> re_chars &#123;T&#125; (re : reg_exp) : list T :=</span><br><span class="line">  <span class="keyword">match</span> re <span class="built_in">with</span></span><br><span class="line">  | <span class="type">EmptySet</span> ⇒ []</span><br><span class="line">  | <span class="type">EmptyStr</span> ⇒ []</span><br><span class="line">  | <span class="type">Char</span> x ⇒ [x]</span><br><span class="line">  | <span class="type">App</span> re1 re2 ⇒ re_chars re1 ++ re_chars re2</span><br><span class="line">  | <span class="type">Union</span> re1 re2 ⇒ re_chars re1 ++ re_chars re2</span><br><span class="line">  | <span class="type">Star</span> re ⇒ re_chars re</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>The proof of <code>in_re_match</code> went through by <code>inversion</code> on relation <code>s =~ re</code>. (which gives us all 7 cases.)<br>The interesting case is <code>MStarApp</code>, where the proof tree has two <em>branches</em> (of premises):</p>
<pre><code>                  s1 =~ re    s2 =~ Star re
                 ---------------------------            (MStarApp)
                    s1 ++ s2 =~ Star re
</code></pre>
<p>So by induction on the relation (rule), we got <em>two induction hypotheses</em>!<br>That’s what we need for the proof.</p>
<h2 id="The-remember-tactic-Induction-on-Evidence-of-A-Specific-Case"><a href="#The-remember-tactic-Induction-on-Evidence-of-A-Specific-Case" class="headerlink" title="The remember tactic (Induction on Evidence of A Specific Case)"></a>The <code>remember</code> tactic (Induction on Evidence of A Specific Case)</h2><p>One interesting&#x2F;confusing features is that <code>induction</code> over a term that’s <em>insuffciently general</em>. e.g. </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> star_app: ∀T (s1 s2 : list T) (re : @reg_exp T),</span><br><span class="line">  s1 =~ Star re →</span><br><span class="line">  s2 =~ Star re →</span><br><span class="line">  s1 ++ s2 =~ Star re.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> T s1 s2 re H1.</span><br></pre></td></tr></table></figure>

<p>Here, we know the fact that both <code>s1</code> and <code>s2</code> are matching with the form <code>Star re</code>.<br>But by <code>induction</code>. it will give us <em>all 7 cases</em> to prove, but <em>5 of them are contradictory</em>!</p>
<p>That’s where we need <code>remember (Star re) as re&#39;</code> to get this bit of information back to <code>discriminate</code>.</p>
<h3 id="Sidenotes-inversion-vs-induction-on-evidence"><a href="#Sidenotes-inversion-vs-induction-on-evidence" class="headerlink" title="Sidenotes: inversion vs. induction on evidence"></a>Sidenotes: <code>inversion</code> vs. <code>induction</code> on evidence</h3><p>We might attemp to use <code>inversion</code>,<br>which is best suitted for have a specific conclusion of some rule and inverts back to get its premises.</p>
<p>But for <em>recursive cases</em> (e.g. <code>Star</code>), we always need <code>induction</code>. </p>
<p><code>induction</code> on a specific conclusion then <code>remember + contradiction</code> is similar with how <code>inversion</code> solves contradictionary cases. (They both <code>destruct</code> the inductively defined things for sure)</p>
<h2 id="Exercise-5-stars-advanced-pumping"><a href="#Exercise-5-stars-advanced-pumping" class="headerlink" title="Exercise: 5 stars, advanced (pumping)"></a>Exercise: 5 stars, advanced (pumping)</h2><p>FCT&#x2F;Wikipedia “proves” <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages">pumping lemma for regex</a> in a non-constructive way.</p>
<p>Here we attempts to give a constructive proof.</p>
<h2 id="Case-Study-Improving-Reflection-互映"><a href="#Case-Study-Improving-Reflection-互映" class="headerlink" title="Case Study: Improving Reflection (互映)"></a>Case Study: Improving Reflection (互映)</h2><blockquote>
<p>we often need to relate boolean computations to statements in <code>Prop</code></p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> reflect (P : <span class="keyword">Prop</span>) : bool → <span class="keyword">Prop</span> :=</span><br><span class="line">| <span class="type">ReflectT</span> (H : P) : reflect P true</span><br><span class="line">| <span class="type">ReflectF</span> (H : ¬P) : reflect P false.</span><br></pre></td></tr></table></figure>

<p>The <em>only</em> way to construct <code>ReflectT/F</code> is by showing (a proof) of <code>P/¬P</code>,<br>meaning invertion on <code>reflect P bool</code> can give us back the evidence. </p>
<p><code>iff_reflect</code> give us <code>eqbP</code>.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> eqbP : ∀n m, reflect (n = m) (n =? m).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n m. <span class="built_in">apply</span> iff_reflect. <span class="built_in">rewrite</span> eqb_eq. <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>This gives us a small gain in convenience: we immediately give the <code>Prop</code> from <code>bool</code>, no need to <code>rewrite</code>.</p>
<blockquote>
<p>Proof Engineering Hacks…</p>
</blockquote>
<h3 id="SSReflect-small-scale-reflection"><a href="#SSReflect-small-scale-reflection" class="headerlink" title="SSReflect - small-scale reflection"></a>SSReflect - small-scale reflection</h3><blockquote>
<p>a Coq library<br>used to prove 4-color theorem…!<br>simplify small proof steps with boolean computations. (somewhat automation with decision procedures)</p>
</blockquote>
<h2 id="Extended-Exercise-A-Verified-Regular-Expression-Matcher"><a href="#Extended-Exercise-A-Verified-Regular-Expression-Matcher" class="headerlink" title="Extended Exercise: A Verified Regular-Expression Matcher"></a>Extended Exercise: A Verified Regular-Expression Matcher</h2><blockquote>
<p>we have defined a <em>match relation</em> that can <em>prove</em> a regex matches a string.<br>but it does not give us a <em>program</em> that can <em>run</em> to determine a match automatically…</p>
</blockquote>
<blockquote>
<p>we hope to translate <em>inductive rules (for constructing evidence)</em> to <em>recursive fn</em>.<br>however, since <code>reg_exp</code> is recursive, Coq won’t accept it always terminates </p>
</blockquote>
<p>theoritically, the regex &#x3D; DFA so it is decidable and halt.<br>technically, it only halts on finite strings but not infinite strings.<br>(and infinite strings are probably beyond the scope of halting problem?)</p>
<blockquote>
<p>Heavily-optimized regex matcher &#x3D; translating into <em>state machine</em> e.g. NFA&#x2F;DFA.<br>Here we took a <em>derivative</em> approach which operates purely on string.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Require</span> <span class="keyword">Export</span> Coq.Strings.Ascii.</span><br><span class="line"><span class="keyword">Definition</span> string := list ascii.</span><br></pre></td></tr></table></figure>

<p>Coq 标准库中的 ASCII 字符串也是归纳定义的，不过我们这里为了之前定义的 match relation 用 <code>list ascii</code>.</p>
<blockquote>
<p>to define regex matcher over <code>list X</code> i.e. polymorphic lists.<br>we need to be able to <em>test equality</em> for each <code>X</code> etc.</p>
</blockquote>
<h3 id="Rules-Derivatives"><a href="#Rules-Derivatives" class="headerlink" title="Rules &amp; Derivatives."></a>Rules &amp; Derivatives.</h3><p>Check paper <a href="">Regular-expression derivatives reexamined - JFP 09</a> as well.</p>
<p><code>app</code> and <code>star</code> are the hardest ones. </p>
<h4 id="Let’s-take-app-as-an-example"><a href="#Let’s-take-app-as-an-example" class="headerlink" title="Let’s take app as an example"></a>Let’s take <code>app</code> as an example</h4><h5 id="1-等价-helper"><a href="#1-等价-helper" class="headerlink" title="1. 等价 helper"></a>1. 等价 helper</h5><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> app_exists : ∀(s : string) re0 re1,</span><br><span class="line">    s =~ App re0 re1 ↔ ∃s0 s1, s = s0 ++ s1 ∧ s0 =~ re0 ∧ s1 =~ re1.</span><br></pre></td></tr></table></figure>

<p>this <em>helper rules</em> is written for the sake of convenience:</p>
<ul>
<li>the <code>&lt;-</code> is the definition of <code>MApp</code>.</li>
<li>the <code>-&gt;</code> is the <code>inversion s =~ App re0 re1</code>.</li>
</ul>
<h5 id="2-App-对于-a-s-的匹配性质"><a href="#2-App-对于-a-s-的匹配性质" class="headerlink" title="2. App 对于 a :: s 的匹配性质"></a>2. <code>App</code> 对于 <code>a :: s</code> 的匹配性质</h5><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> app_ne : ∀(a : ascii) s re0 re1,</span><br><span class="line">    a :: s =~ (App re0 re1) ↔</span><br><span class="line">    ([ ] =~ re0 ∧ a :: s =~ re1) ∨</span><br><span class="line">    ∃s0 s1, s = s0 ++ s1 ∧ a :: s0 =~ re0 ∧ s1 =~ re1.</span><br></pre></td></tr></table></figure>
<p>the second rule is more interesting. It states the <em>property</em> of <code>app</code>:</p>
<blockquote>
<p>App re0 re1 匹配 a::s 当且仅当  (re0 匹配空字符串 且 a::s 匹配 re1)  或  (s&#x3D;s0++s1，其中 a::s0 匹配 re0 且 s1 匹配 re1)。</p>
</blockquote>
<p>这两条对后来的证明很有帮助，<code>app_exists</code> 反演出来的 existential 刚好用在 <code>app_ne</code> 中.</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/jiangsy/SoftwareFoundation/blob/47543ce8b004cd25d0e1769f7444d57f0e26594d/IndProp.v">https://github.com/jiangsy/SoftwareFoundation/blob/47543ce8b004cd25d0e1769f7444d57f0e26594d/IndProp.v</a></p>
</blockquote>
<h5 id="3-定义-derivative-关系"><a href="#3-定义-derivative-关系" class="headerlink" title="3. 定义 derivative 关系"></a>3. 定义 derivative 关系</h5><p>the relation <em><code>re&#39;</code> is a derivative of <code>re</code> on <code>a</code></em> is defind as follows:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> is_der re (a : ascii) re&#x27; :=</span><br><span class="line">  ∀s, a :: s =~ re ↔ s =~ re&#x27;.</span><br></pre></td></tr></table></figure>

<h5 id="4-实现-derive"><a href="#4-实现-derive" class="headerlink" title="4. 实现 derive"></a>4. 实现 derive</h5><p>Now we can impl <code>derive</code> by follwing <code>2</code>, the property.<br>In paper we have:</p>
<pre><code>∂ₐ(r · s) = ∂ₐr · s + ν(r) · ∂ₐs       -- subscriprt &quot;a&quot; meaning &quot;respective to a&quot; 

where 
  ν(r) = nullable(r) ? ε : ∅ 
</code></pre>
<p>In our Coq implementation, <code>nullable(r) == match_eps(r)</code>, </p>
<p>Since we know that<br><code>∀r, ∅ · r = ∅</code>,<br><code>∀r, ε · r = r</code>,<br>we can be more straightforward by expanding out <code>v(r)</code>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Fixpoint</span> derive (a : ascii) (re : @reg_exp ascii) : @reg_exp ascii :=</span><br><span class="line">...</span><br><span class="line"> | <span class="type">App</span> r1 r2 =&gt; <span class="keyword">if</span> match_eps r1                            <span class="comment">(** nullable(r) ? **)</span></span><br><span class="line">      <span class="keyword">then</span> Union (App (derive a r1) r2) (derive a r2)      <span class="comment">(**  ∂ₐr · s + ∂ₐs **)</span></span><br><span class="line">      <span class="keyword">else</span> App (derive a r1) r2                            <span class="comment">(**  ∂ₐr · s       **)</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_lf/2019-01-08-sf-lf-08-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_lf/2019-01-08-sf-lf-08-map/" class="post-title-link" itemprop="url">「SF-LC」8 Maps</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>useful as env</p>
</blockquote>
<p>Map &#x3D;&#x3D; Dictionary</p>
<ul>
<li>building data structure.</li>
<li>use of reflection to streamline proofs.</li>
</ul>
<p>Two flavors of maps:</p>
<ol>
<li><em>total</em>   maps, return <em>default</em> when lookup fails</li>
<li><em>partial</em> maps, return <code>option</code> to indicate success&#x2F;failure, using <code>None</code> as the default.</li>
</ol>
<h2 id="The-Coq-Standard-Lib"><a href="#The-Coq-Standard-Lib" class="headerlink" title="The Coq Standard Lib"></a>The Coq Standard Lib</h2><p>From now on, importing from std lib. (but should not notice much difference)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">From</span> Coq <span class="keyword">Require</span> <span class="keyword">Import</span> Arith.Arith.</span><br><span class="line"><span class="keyword">From</span> Coq <span class="keyword">Require</span> <span class="keyword">Import</span> Bool.Bool.</span><br><span class="line"><span class="keyword">Require</span> <span class="keyword">Export</span> Coq.Strings.String.</span><br><span class="line"><span class="keyword">From</span> Coq <span class="keyword">Require</span> <span class="keyword">Import</span> Logic.FunctionalExtensionality.</span><br><span class="line"><span class="keyword">From</span> Coq <span class="keyword">Require</span> <span class="keyword">Import</span> Lists.List.</span><br><span class="line"><span class="keyword">Import</span> ListNotations.</span><br></pre></td></tr></table></figure>

<p>TODO: what’s the differences above?<br>Answered in Coq Intensive:</p>
<ul>
<li><code>Require</code> give access but need to use qualified name</li>
<li><code>Import</code>  no need to use qualified name</li>
<li><code>Export</code>  module importing me no need to use qualified name as well</li>
</ul>
<p><code>String</code> in Coq is <code>list</code> of <code>Char</code> and <code>Char</code> is record of 8 <code>Bool</code>…</p>
<h2 id="Identifiers"><a href="#Identifiers" class="headerlink" title="Identifiers"></a>Identifiers</h2><blockquote>
<p>we need a type for the <em>keys</em> that we use to index into our maps.</p>
</blockquote>
<p>In <code>Lists.v</code> (Partial Maps):</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> id : <span class="keyword">Type</span> := </span><br><span class="line">  | <span class="type">Id</span> (n : nat).</span><br></pre></td></tr></table></figure>

<p>From now on we will use the <code>string</code> from Coq’s std lib:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> eqb_string (x y : string) : bool :=</span><br><span class="line">  <span class="keyword">if</span> string_dec x y <span class="keyword">then</span> true <span class="keyword">else</span> false.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> string_dec: <span class="comment">(* ===&gt; *)</span></span><br><span class="line">     : <span class="keyword">forall</span> s1 s2 : string, &#123;s1 = s2&#125; + &#123;s1 &lt;&gt; s2&#125;</span><br></pre></td></tr></table></figure>

<p>The equality check fn for <code>string</code> from stdlib is <code>string_des</code>, which returns a <code>sumbool</code> type, i.e. <code>&#123;x=y&#125; + &#123;x≠y&#125;</code>.</p>
<blockquote>
<p>which can be thought of as an <strong>“evidence-carrying boolean”</strong>.<br>Formally, an element of <code>sumbool</code> is either or</p>
<ul>
<li>a proof that two things are equal</li>
<li>a proof that they are unequal,<br>together with a tag indicating which.</li>
</ul>
</blockquote>
<p>Some properties:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(* reflexive relation *)</span></span><br><span class="line"><span class="keyword">Theorem</span> eqb_string_refl : ∀s : string, true = eqb_string s s.</span><br><span class="line"></span><br><span class="line"><span class="comment">(* functional extensionality *)</span></span><br><span class="line"><span class="keyword">Theorem</span> eqb_string_true_iff : ∀x y : string, eqb_string x y = true ↔ x = y.</span><br><span class="line"><span class="keyword">Theorem</span> eqb_string_false_iff : ∀x y : string, eqb_string x y = false ↔ x ≠ y.</span><br></pre></td></tr></table></figure>


<h2 id="Total-Maps"><a href="#Total-Maps" class="headerlink" title="Total Maps"></a>Total Maps</h2><blockquote>
<p>use <em>functions</em>, rather than lists of key-value pairs, to build maps.<br>The advantage of this representation is that it offers a more <em>extensional</em> view of maps. 外延性</p>
</blockquote>
<blockquote>
<p>(where two maps that respond to queries in the same way will be represented as literally the same thing rather than just “equivalent” data structures. This, in turn, simplifies proofs that use maps.)</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> total_map (A : <span class="keyword">Type</span>) := string -&gt; A.</span><br><span class="line"></span><br><span class="line"><span class="comment">(* empty take a default value *)</span></span><br><span class="line"><span class="keyword">Definition</span> t_empty &#123;A : <span class="keyword">Type</span>&#125; (v : A) : total_map A :=</span><br><span class="line">  (<span class="keyword">fun</span> <span class="keyword">_</span> =&gt; v).</span><br><span class="line"></span><br><span class="line"><span class="comment">(* update take a key value pair *)</span></span><br><span class="line"><span class="keyword">Definition</span> t_update &#123;A : <span class="keyword">Type</span>&#125; (m : total_map A)</span><br><span class="line">                    (x : string) (v : A) <span class="comment">(* : total_map A *)</span> :=</span><br><span class="line">  <span class="keyword">fun</span> x&#x27; =&gt; <span class="keyword">if</span> eqb_string x x&#x27; <span class="keyword">then</span> v <span class="keyword">else</span> m x&#x27;.</span><br></pre></td></tr></table></figure>

<p>Where is the data stored? <em>Closure</em>!</p>
<h3 id="My-Reviews-on-API-style-of-ML"><a href="#My-Reviews-on-API-style-of-ML" class="headerlink" title="My Reviews on API style of ML"></a>My Reviews on API style of ML</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> examplemap :=</span><br><span class="line">  t_update (t_update (t_empty false) <span class="string">&quot;foo&quot;</span> true)</span><br><span class="line">           <span class="string">&quot;bar&quot;</span> true.</span><br></pre></td></tr></table></figure>

<p>since <code>t_update</code> is defined as so called “t-first” style.<br>Reason&#x2F;BuckleScript and OCaml stdlib uses this style as well:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> examplemap = </span><br><span class="line">  <span class="title function_">t_empty</span>(<span class="literal">false</span>)</span><br><span class="line">  |. <span class="title function_">t_update</span>(<span class="string">&quot;foo&quot;</span>, <span class="literal">true</span>)         <span class="comment">/* fast pipe */</span></span><br><span class="line">  |. <span class="title function_">t_update</span>(<span class="string">&quot;bar&quot;</span>, <span class="literal">true</span>) </span><br></pre></td></tr></table></figure>

<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> add : key -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> t -&gt; <span class="symbol">&#x27;a</span> t</span><br><span class="line"><span class="keyword">let</span> examplemap = </span><br><span class="line">  <span class="type">Map</span>.empty </span><br><span class="line">  |&gt; <span class="type">Map</span>.add <span class="string">&quot;foo&quot;</span> <span class="literal">true</span></span><br><span class="line">  |&gt; <span class="type">Map</span>.add <span class="string">&quot;bar&quot;</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>Or, In Jane Street “named-argument” style<br>e.g. <a target="_blank" rel="noopener" href="https://v1.realworldocaml.org/v1/en/html/maps-and-hash-tables.html">Real World OCaml</a></p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> examplemap = </span><br><span class="line">  <span class="type">Map</span>.empty</span><br><span class="line">  |&gt; <span class="type">Map</span>.add ~key:<span class="string">&quot;foo&quot;</span> ~data:<span class="literal">true</span></span><br><span class="line">  |&gt; <span class="type">Map</span>.add ~key:<span class="string">&quot;bar&quot;</span> ~data:<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="Lightweight-Meta-Programming-in-Coq-Notation"><a href="#Lightweight-Meta-Programming-in-Coq-Notation" class="headerlink" title="Lightweight Meta-Programming in Coq - Notation"></a>Lightweight Meta-Programming in Coq - Notation</h3><p>In Coq, we can leverage some meta programming:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;&#x27;_&#x27; &#x27;!-&gt;&#x27; v&quot;</span> := (t_empty v)</span><br><span class="line">  (<span class="built_in">at</span> level <span class="number">100</span>, <span class="built_in">right</span> associativity).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;x &#x27;!-&gt;&#x27; v &#x27;;&#x27; m&quot;</span> := (t_update m x v)</span><br><span class="line">  (<span class="built_in">at</span> level <span class="number">100</span>, v <span class="built_in">at</span> next level, <span class="built_in">right</span> associativity).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Definition</span> examplemap&#x27; :=</span><br><span class="line">  ( <span class="string">&quot;bar&quot;</span> !-&gt; true;</span><br><span class="line">    <span class="string">&quot;foo&quot;</span> !-&gt; true;</span><br><span class="line">    <span class="keyword">_</span>     !-&gt; false</span><br><span class="line">  ).</span><br></pre></td></tr></table></figure>

<p>Noticed that the “Map building” is in a <em>reversed</em> order…</p>
<blockquote>
<p>Note that we don’t need to define a find operation because it is just function application!</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> update_example2 : examplemap&#x27; <span class="string">&quot;foo&quot;</span> = true.</span><br><span class="line"><span class="keyword">Example</span> update_example4 : examplemap&#x27; <span class="string">&quot;bar&quot;</span> = true.</span><br><span class="line"><span class="keyword">Example</span> update_example1 : examplemap&#x27; <span class="string">&quot;baz&quot;</span> = false. <span class="comment">(* default *)</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Partial-Maps"><a href="#Partial-Maps" class="headerlink" title="Partial Maps"></a>Partial Maps</h2><blockquote>
<p>we define partial maps on top of total maps.<br>A partial map with elements of type <code>A</code> is simply a total map with elements of type <code>option A</code> and default element <code>None</code>.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> partial_map (A : <span class="keyword">Type</span>) := total_map (option A).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Definition</span> empty &#123;A : <span class="keyword">Type</span>&#125; : partial_map A :=</span><br><span class="line">  t_empty None.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Definition</span> update &#123;A : <span class="keyword">Type</span>&#125; (m : partial_map A)</span><br><span class="line">           (x : string) (v : A) :=</span><br><span class="line">  (x !-&gt; Some v ; m).</span><br><span class="line">  </span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;x &#x27;⊢&gt;&#x27; v &#x27;;&#x27; m&quot;</span> := (update m x v)</span><br><span class="line">  (<span class="built_in">at</span> level <span class="number">100</span>, v <span class="built_in">at</span> next level, <span class="built_in">right</span> associativity).</span><br><span class="line"></span><br><span class="line"><span class="comment">(** hide the empty case. Since it&#x27;s always [None] **)</span></span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;x &#x27;⊢&gt;&#x27; v&quot;</span> := (update empty x v)</span><br><span class="line">  (<span class="built_in">at</span> level <span class="number">100</span>).</span><br><span class="line">  </span><br><span class="line"><span class="comment">(** so nice **)</span></span><br><span class="line"><span class="keyword">Example</span> examplepmap :=</span><br><span class="line">  (<span class="string">&quot;Church&quot;</span> ⊢&gt; true ; </span><br><span class="line">   <span class="string">&quot;Turing&quot;</span> ⊢&gt; false).</span><br></pre></td></tr></table></figure>

<p>we use the “standard” map operator <code>↦</code> for partial map since maps in CS are usually partial.</p>
<hr>
<h2 id="Maps-are-functions"><a href="#Maps-are-functions" class="headerlink" title="Maps are functions"></a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Map_(mathematics)#Maps_as_functions">Maps are functions</a></h2><blockquote>
<p>In many branches of mathematics, the term map is used to mean a function.<br><em>partial map</em> &#x3D; <em>partial function</em>,<br><em>total   map</em> &#x3D; <em>total   function</em>.</p>
</blockquote>
<blockquote>
<p>In category theory, “map” is often used as a synonym for morphism or arrow.</p>
</blockquote>
<blockquote>
<p>In formal logic, “map” is sometimes used for a functional symbol.</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_lf/2019-01-09-sf-lf-09-proof-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_lf/2019-01-09-sf-lf-09-proof-object/" class="post-title-link" itemprop="url">「SF-LC」9 ProofObjects</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>“Algorithms are the computational content of proofs.” —Robert Harper</p>
</blockquote>
<p>So the book material is designed to be gradually reveal the facts that </p>
<blockquote>
<p>Programming and proving in Coq are two sides of the same coin. </p>
</blockquote>
<p>e.g.</p>
<ul>
<li><code>Inductive</code> is useds for both data types and propositions.</li>
<li><code>-&gt;</code> is used for both type of functions and logical implication.</li>
</ul>
<p>The fundamental idea of Coq is that:</p>
<blockquote>
<p><em>provability</em> in Coq is represented by <em>concrete evidence</em>. When we construct the proof of a basic proposition, we are actually <em>building a tree of evidence</em>, which can be thought of as a data structure.</p>
</blockquote>
<p>e.g.</p>
<ul>
<li>implication like <code>A → B</code>, its proof will be an <em>evidence transformer</em>: a recipe for converting evidence for A into evidence for B.</li>
</ul>
<blockquote>
<p>Proving manipulates evidence, much as programs manipuate data.</p>
</blockquote>
<h2 id="Curry-Howard-Correspondence"><a href="#Curry-Howard-Correspondence" class="headerlink" title="Curry-Howard Correspondence"></a>Curry-Howard Correspondence</h2><blockquote>
<p>deep connection between the world of logic and the world of computation:</p>
</blockquote>
<pre><code>propositions             ~  types
proofs / evidence        ~  terms / data values 
</code></pre>
<p><code>ev_0 : even 0</code></p>
<ul>
<li><code>ev_0</code> <strong>has type</strong>                             <code>even 0</code></li>
<li><code>ev_0</code> <strong>is a proof of</strong> &#x2F; <strong>is evidence for</strong>  <code>even 0</code></li>
</ul>
<p><code>ev_SS : ∀n, even n -&gt; even (S (S n))</code></p>
<ul>
<li>takes a nat <code>n</code> and evidence for <code>even n</code> and yields evidence for <code>even (S (S n))</code>.</li>
</ul>
<p>This is <em>Props as Types</em>.</p>
<h2 id="Proof-Objects"><a href="#Proof-Objects" class="headerlink" title="Proof Objects"></a>Proof Objects</h2><p>Proofs are data! We can see the <em>proof object</em> that results from this <em>proof script</em>.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Print</span> ev_4.</span><br><span class="line"><span class="comment">(* ===&gt; ev_4 = ev_SS 2 (ev_SS 0 ev_0) </span></span><br><span class="line"><span class="comment">             : even 4  *)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> (ev_SS <span class="number">2</span> (ev_SS <span class="number">0</span> ev_0)).     <span class="comment">(* concrete derivation tree, we r explicitly say the number tho *)</span></span><br><span class="line"><span class="comment">(* ===&gt; even 4 *)</span></span><br></pre></td></tr></table></figure>

<p>These two ways are the same in principle!</p>
<h2 id="Proof-Scripts"><a href="#Proof-Scripts" class="headerlink" title="Proof Scripts"></a>Proof Scripts</h2><p><code>Show Proof.</code>  will show the <em>partially constructed</em> proof terms &#x2F; objects.<br><code>?Goal</code> is the <em>unification variable</em>. (the hold we need to fill in to complete the proof)</p>
<p>more complicated in branching cases<br>one hole more subgoal</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> ev_4&#x27;&#x27; : even <span class="number">4.</span>   <span class="comment">(*  match? (even 4) *)</span></span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="keyword">Show</span> <span class="keyword">Proof</span>.              <span class="comment">(*  ?Goal  *)</span></span><br><span class="line">  <span class="built_in">apply</span> ev_SS.</span><br><span class="line">  <span class="keyword">Show</span> <span class="keyword">Proof</span>.              <span class="comment">(*  (ev_SS 2 ?Goal)  *)</span></span><br><span class="line">  <span class="built_in">apply</span> ev_SS.</span><br><span class="line">  <span class="keyword">Show</span> <span class="keyword">Proof</span>.              <span class="comment">(*  (ev_SS 2 (ev_SS 0 ?Goal))  *)</span></span><br><span class="line">  <span class="built_in">apply</span> ev_0. </span><br><span class="line">  <span class="keyword">Show</span> <span class="keyword">Proof</span>.              <span class="comment">(*  ?Goal (ev_SS 2 (ev_SS 0 ev_0))  *)</span></span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tactic proofs are useful and convenient, but they are not essential:<br>in principle, we can always construct the required evidence by hand</p>
</blockquote>
<p>Agda doesn’t have tactics built-in. (but also Interactive)</p>
<h2 id="Quantifiers-Implications-Functions"><a href="#Quantifiers-Implications-Functions" class="headerlink" title="Quantifiers, Implications, Functions"></a>Quantifiers, Implications, Functions</h2><p>In Coq’s <em>computational universe</em> (where data structures and programs live), to give <code>-&gt;</code>:</p>
<ul>
<li>constructors (introduced by <code>Indutive</code>)</li>
<li>functions</li>
</ul>
<p>in Coq’s <em>logical universe</em> (where we carry out proofs), to give implication:</p>
<ul>
<li>constructors</li>
<li>functions!</li>
</ul>
<p>So instead of writing proof scripts e.g._</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> ev_plus4 : ∀n, even n → even (<span class="number">4</span> + n).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n H. <span class="built_in">simpl</span>.</span><br><span class="line">  <span class="built_in">apply</span> ev_SS.</span><br><span class="line">  <span class="built_in">apply</span> ev_SS.</span><br><span class="line">  <span class="built_in">apply</span> H.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>we can give proof object, which is a <em>function</em> here, directly!</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> ev_plus4&#x27; : ∀n, even n → even (<span class="number">4</span> + n) :=    <span class="comment">(* ∀ is syntax for Pi? *)</span></span><br><span class="line">  <span class="keyword">fun</span> (n : nat)    ⇒ </span><br><span class="line">  <span class="keyword">fun</span> (H : even n) ⇒</span><br><span class="line">    ev_SS (S (S n)) (ev_SS n H).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Definition</span> ev_plus4&#x27;&#x27; (n : nat) (H : even n)           <span class="comment">(* tricky: implicitly `Pi` when `n` get mentioned?  *)</span></span><br><span class="line">                    : even (<span class="number">4</span> + n) :=</span><br><span class="line">  ev_SS (S (S n)) (ev_SS n H).</span><br></pre></td></tr></table></figure>

<p>two interesting facts:</p>
<ol>
<li><code>intros x</code> corresponds to <code>λx.</code> (or <code>Pi x.</code>??)</li>
<li><code>apply</code> corresponds to…not quite function application… but more like <em>filling the hole</em>.</li>
<li><code>even n</code> mentions the <em>value</em> of 1st argument <code>n</code>. i.e. <em>dependent type</em>!</li>
</ol>
<p>Recall Ari’s question in “applying theorem as function” e.g. <code>plus_comm</code><br>why we can apply value in type-level fun.<br>becuz of dependent type.</p>
<p>Now we call them <code>dependent type function</code></p>
<h3 id="→-is-degenerated-∀-Pi"><a href="#→-is-degenerated-∀-Pi" class="headerlink" title="→ is degenerated ∀ (Pi)"></a><code>→</code> is degenerated <code>∀</code> (<code>Pi</code>)</h3><blockquote>
<p>Notice that both implication (<code>→</code>) and quantification (<code>∀</code>) correspond to functions on evidence.<br>In fact, they are really the same thing: <code>→</code> is just a shorthand for a degenerate use of <code>∀</code> where there is no dependency, i.e., no need to give a name to the type on the left-hand side of the arrow:</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  ∀(x:nat), nat </span><br><span class="line">= ∀(<span class="keyword">_</span>:nat), nat </span><br><span class="line">= nat → nat</span><br><span class="line"></span><br><span class="line">  ∀n, ∀(E : even n), even (n + <span class="number">2</span>).</span><br><span class="line">= ∀n, ∀(<span class="keyword">_</span> : even n), even (n + <span class="number">2</span>).</span><br><span class="line">= ∀n, even n → even (n + <span class="number">2</span>).</span><br></pre></td></tr></table></figure>

<blockquote>
<p>In general, <code>P → Q</code> is just syntactic sugar for <code>∀ (_:P), Q</code>.</p>
</blockquote>
<p>TaPL also mention this fact for <code>Pi</code>.</p>
<h2 id="Q-A-Slide-15"><a href="#Q-A-Slide-15" class="headerlink" title="Q&amp;A - Slide 15"></a>Q&amp;A - Slide 15</h2><ol>
<li><code>∀ n, even n → even (4 + n)</code>. (<code>2 + n = S (S n)</code>)</li>
</ol>
<h2 id="Programming-with-Tactics"><a href="#Programming-with-Tactics" class="headerlink" title="Programming with Tactics."></a>Programming with Tactics.</h2><p>If we can build proofs by giving explicit terms rather than executing tactic scripts,<br>you may be wondering whether we can <em>build programs using tactics</em>? Yes!</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> add1 : nat → nat.</span><br><span class="line">  <span class="built_in">intro</span> n.</span><br><span class="line">  <span class="keyword">Show</span> <span class="keyword">Proof</span>.      </span><br><span class="line"><span class="comment">(** </span></span><br><span class="line"><span class="comment">the goal (proof state):</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    n : nat</span></span><br><span class="line"><span class="comment">    =======</span></span><br><span class="line"><span class="comment">    nat</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">the response:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (fun n : nat =&gt; ?Goal) </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">What is really interesting here, is that the premies [n:nat] is actually the arguments!</span></span><br><span class="line"><span class="comment">again, the process of applying tactics is _partial application_</span></span><br><span class="line"><span class="comment">**)</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">apply</span> S.</span><br><span class="line">  <span class="keyword">Show</span> <span class="keyword">Proof</span>.      </span><br><span class="line"><span class="comment">(** </span></span><br><span class="line"><span class="comment">    (fun n : nat =&gt; S ?Goal) </span></span><br><span class="line"><span class="comment">**)</span></span><br><span class="line">  <span class="built_in">apply</span> n. </span><br><span class="line"><span class="keyword">Defined</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Print</span> add1.</span><br><span class="line"><span class="comment">(* ==&gt; add1 = fun n : nat =&gt; S n</span></span><br><span class="line"><span class="comment">            : nat -&gt; nat *)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Notice that we terminate the Definition with a <code>.</code> rather than with <code>:=</code> followed by a term.<br>This tells Coq to enter <em>proof scripting mode</em> (w&#x2F;o <code>Proof.</code>, which did nothing)</p>
</blockquote>
<blockquote>
<p>Also, we terminate the proof with <code>Defined</code> rather than <code>Qed</code>; this makes the definition <em>transparent</em> so that it can be used in computation like a normally-defined function<br>(<code>Qed</code>-defined objects are <em>opaque</em> during computation.).</p>
</blockquote>
<p><code>Qed</code> make things <code>unfold</code>able,<br>thus <code>add 1</code> ends with <code>Qed</code> is not computable…<br>(becuz of not even <code>unfold</code>able thus computation engine won’t deal with it)</p>
<blockquote>
<p>Prof.Mtf: meaning “we don’t care about the details of Proof”</p>
</blockquote>
<p>see as well <a target="_blank" rel="noopener" href="https://wiki.haskell.org/Smart_constructors">Smart Constructor</a></p>
<blockquote>
<p>This feature is mainly useful for writing functions with dependent types</p>
</blockquote>
<p>In Coq      - you do as much as ML&#x2F;Haskell when you can…?<br>Unlike Agda - you program intensively in dependent type…?</p>
<p>When Extracting to OCaml…Coq did a lot of <code>Object.magic</code> for coercion to bypass OCaml type system. (Coq has maken sure the type safety.)</p>
<h2 id="Logical-Connectives-as-Inductive-Types"><a href="#Logical-Connectives-as-Inductive-Types" class="headerlink" title="Logical Connectives as Inductive Types"></a>Logical Connectives as Inductive Types</h2><blockquote>
<p>Inductive definitions are powerful enough to express most of the connectives we have seen so far.<br>Indeed, only universal quantification (with implication as a special case) is built into Coq;<br>all the others are defined inductively.<br>Wow…</p>
</blockquote>
<blockquote>
<p>CoqI: What’s Coq logic? Forall + Inductive type (+ coinduction), that’s it.</p>
</blockquote>
<h3 id="Conjunctions"><a href="#Conjunctions" class="headerlink" title="Conjunctions"></a>Conjunctions</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> and (P Q : <span class="keyword">Prop</span>) : <span class="keyword">Prop</span> :=</span><br><span class="line">| <span class="type">conj</span> : P → Q → and P Q.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Print</span> prod.</span><br><span class="line"><span class="comment">(* ===&gt;</span></span><br><span class="line"><span class="comment">   Inductive prod (X Y : Type) : Type :=</span></span><br><span class="line"><span class="comment">   | pair : X -&gt; Y -&gt; X * Y. *)</span></span><br></pre></td></tr></table></figure>

<p>similar to <code>prod</code> (product) type… more connections happening here.</p>
<blockquote>
<p>This similarity should clarify why <code>destruct</code> and <code>intros</code> patterns can be used on a conjunctive hypothesis. </p>
</blockquote>
<blockquote>
<p>Similarly, the <code>split</code> tactic actually works for any inductively defined proposition with exactly one constructor<br>(so here, <code>apply conj</code>, which will match the conclusion and generate two subgoal from assumptions )</p>
</blockquote>
<p>A <em>very direct</em> proof:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> and_comm&#x27;_aux P Q (H : P ∧ Q) : Q ∧ P :=</span><br><span class="line">  <span class="keyword">match</span> H <span class="built_in">with</span></span><br><span class="line">  | <span class="type">conj</span> HP HQ ⇒ conj HQ HP</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>



<h3 id="Disjunction"><a href="#Disjunction" class="headerlink" title="Disjunction"></a>Disjunction</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> or (P Q : <span class="keyword">Prop</span>) : <span class="keyword">Prop</span> :=</span><br><span class="line">| <span class="type">or_introl</span> : P → or P Q</span><br><span class="line">| <span class="type">or_intror</span> : Q → or P Q.</span><br></pre></td></tr></table></figure>

<p>this explains why <code>destruct</code> works but <code>split</code> not..</p>
<h2 id="Q-A-Slide-22-24"><a href="#Q-A-Slide-22-24" class="headerlink" title="Q&amp;A - Slide 22 + 24"></a>Q&amp;A - Slide 22 + 24</h2><p>Both Question asked about what’s the type of some expression</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> P Q R (H1: and P Q) (H2: and Q R) ⇒</span><br><span class="line">    <span class="keyword">match</span> (H1,H2) <span class="built_in">with</span></span><br><span class="line">    | <span class="type">(conj</span> <span class="keyword">_</span> <span class="keyword">_</span> HP <span class="keyword">_</span>, conj <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> HR) ⇒ conj P R HP HR</span><br><span class="line">    <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">fun</span> P Q H ⇒</span><br><span class="line">    <span class="keyword">match</span> H <span class="built_in">with</span></span><br><span class="line">    | <span class="type">or_introl</span> HP ⇒ or_intror Q P HP</span><br><span class="line">    | <span class="type">or_intror</span> HQ ⇒ or_introl Q P HQ</span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<p>But if you simply <code>Check</code> on them, you will get errors saying:<br><code>Error: The constructor conj (in type and) expects 2 arguments.</code> or<br><code>Error: The constructor or_introl (in type or) expects 2 arguments.</code>.</p>
<h3 id="Coq-Magics-“Implicit”-Implicit-and-Overloading"><a href="#Coq-Magics-“Implicit”-Implicit-and-Overloading" class="headerlink" title="Coq Magics, “Implicit” Implicit and Overloading??"></a>Coq Magics, “Implicit” Implicit and Overloading??</h3><p>So what’s the problem?<br>Well, Coq did some magics…</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Print</span> and.</span><br><span class="line"><span class="comment">(* ===&gt; *)</span></span><br><span class="line"><span class="keyword">Inductive</span> and (A B : <span class="keyword">Prop</span>) : <span class="keyword">Prop</span> :=  conj : A -&gt; B -&gt; A /\ B</span><br><span class="line">For conj: <span class="keyword">Arguments</span> A, B are implicit</span><br></pre></td></tr></table></figure>

<p>constructor <code>conj</code> has implicit type arg w&#x2F;o using <code>&#123;&#125;</code> in <code>and</code> …</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> or (A B : <span class="keyword">Prop</span>) : <span class="keyword">Prop</span> :=</span><br><span class="line">    or_introl : A -&gt; A \/ B | <span class="type">or_intror</span> : B -&gt; A \/ B</span><br><span class="line"></span><br><span class="line">For or_introl, when applied to no more than <span class="number">1</span> argument:</span><br><span class="line">  <span class="keyword">Arguments</span> A, B are implicit</span><br><span class="line">For or_introl, when applied to <span class="number">2</span> arguments:</span><br><span class="line">  Argument A is implicit</span><br><span class="line">For or_intror, when applied to no more than <span class="number">1</span> argument:</span><br><span class="line">  <span class="keyword">Arguments</span> A, B are implicit</span><br><span class="line">For or_intror, when applied to <span class="number">2</span> arguments:</span><br><span class="line">  Argument B is implicit</span><br></pre></td></tr></table></figure>

<p>this is even more bizarre…<br>constructor <code>or_introl</code> (and <code>or_intror</code>) are <em>overloaded</em>!! (WTF)</p>
<p>And the questions’re still given as if they’re inside the modules we defined our plain version of <code>and</code> &amp; <code>or</code> (w&#x2F;o any magics), thus we need <code>_</code> in the positions we instantiate <code>and</code> &amp; <code>or</code> so Coq will infer.</p>
<h3 id="Existential-Quantification"><a href="#Existential-Quantification" class="headerlink" title="Existential Quantification"></a>Existential Quantification</h3><blockquote>
<p>To give evidence for an existential quantifier, we package a witness <code>x</code> together with a proof that <code>x</code> satisfies the property <code>P</code>:</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> ex &#123;A : <span class="keyword">Type</span>&#125; (P : A → <span class="keyword">Prop</span>) : <span class="keyword">Prop</span> :=</span><br><span class="line">| <span class="type">ex_intro</span> : ∀x : A, P x → ex P.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> ex.                    <span class="comment">(* ===&gt; *)</span> : (?A -&gt; <span class="keyword">Prop</span>) -&gt; <span class="keyword">Prop</span> </span><br><span class="line"><span class="keyword">Check</span> even.                  <span class="comment">(* ===&gt; *)</span> : nat -&gt; <span class="keyword">Prop</span>  <span class="comment">(* ?A := nat  *)</span></span><br><span class="line"><span class="keyword">Check</span> ex even.               <span class="comment">(* ===&gt; *)</span> : <span class="keyword">Prop</span> </span><br><span class="line"><span class="keyword">Check</span> ex (<span class="keyword">fun</span> n =&gt; even n)   <span class="comment">(* ===&gt; *)</span> : <span class="keyword">Prop</span>     <span class="comment">(* same *)</span></span><br></pre></td></tr></table></figure>

<p>one interesting fact is, <em>outside</em> of our module, the built-in Coq behaves differently (<em>magically</em>):</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> ev.                    <span class="comment">(* ===&gt; *)</span> : ∀ (A : <span class="keyword">Type</span>), (A -&gt; <span class="keyword">Prop</span>) -&gt; <span class="keyword">Prop</span></span><br><span class="line"><span class="keyword">Check</span> even.                  <span class="comment">(* ===&gt; *)</span> : nat -&gt; <span class="keyword">Prop</span>  <span class="comment">(* A := nat  *)</span></span><br><span class="line"><span class="keyword">Check</span> ex (<span class="keyword">fun</span> n =&gt; even n)   <span class="comment">(* ===&gt; *)</span> : ∃ (n : nat) , even n : <span class="keyword">Prop</span>  <span class="comment">(* WAT !? *)</span></span><br></pre></td></tr></table></figure>

<p>A example of explicit proof object (that inhabit this type):</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> some_nat_is_even : ∃n, even n :=</span><br><span class="line">  ex_intro even <span class="number">4</span> (ev_SS <span class="number">2</span> (ev_SS <span class="number">0</span> ev_0)).</span><br></pre></td></tr></table></figure>

<p>the <code>ex_intro</code> take <code>even</code> first then <code>4</code>…not sure why the order becomes this… </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> (ex_intro).            <span class="comment">(* ===&gt; *)</span> : <span class="keyword">forall</span> (P : ?A -&gt; <span class="keyword">Prop</span>) (x : ?A), P x -&gt; ex P</span><br></pre></td></tr></table></figure>

<p>To prove <code>ex P</code>, given a witness <code>x</code> and a proof of <code>P x</code>. This desugar to <code>∃ x, P x</code></p>
<ul>
<li>the <code>P</code> here, is getting applied when we define prop <code>∃ x, P x</code>.</li>
<li>but the <code>x</code> is not mentioned in type constructor…so it’s a <em>existential type</em>.<ul>
<li>I don’t know why languages (including Haskell) use <code>forall</code> for <em>existential</em> tho.</li>
</ul>
</li>
</ul>
<p><code>exists</code> tactic &#x3D; applying <code>ex_intro</code></p>
<h3 id="True-and-False"><a href="#True-and-False" class="headerlink" title="True and False"></a>True and False</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> True : <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">I</span> : True.</span><br><span class="line"></span><br><span class="line"><span class="comment">(* with 0 constructors, no way of presenting evidence for False *)</span></span><br><span class="line"><span class="keyword">Inductive</span> False : <span class="keyword">Prop</span> := .</span><br></pre></td></tr></table></figure>


<h2 id="Equality"><a href="#Equality" class="headerlink" title="Equality"></a>Equality</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> eq &#123;X:<span class="keyword">Type</span>&#125; : X → X → <span class="keyword">Prop</span> :=</span><br><span class="line">| <span class="type">eq_refl</span> : ∀x, eq x x.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;x == y&quot;</span> := (eq x y)</span><br><span class="line">                    (<span class="built_in">at</span> level <span class="number">70</span>, no associativity)</span><br><span class="line">                    : type_scope.</span><br></pre></td></tr></table></figure>


<blockquote>
<p>given a set <code>X</code>, it defines a <em>family</em> of propositions “x is equal to y,”, <em>indexed by</em> pairs of values (x and y) from <code>X</code>.</p>
</blockquote>
<blockquote>
<p>Can we also use it to construct evidence that <code>1 + 1 = 2</code>?<br>Yes, we can. Indeed, it is the very same piece of evidence!</p>
</blockquote>
<blockquote>
<p>The reason is that Coq treats as “the same” any two terms that are convertible according to a simple set of computation rules.</p>
</blockquote>
<p>nothing in the unification engine but we relies on the <em>reduction engine</em>.</p>
<blockquote>
<p>Q: how much is it willing to do?<br>Mtf: just run them! (since Coq is total!)</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> four: <span class="number">2</span> + <span class="number">2</span> == <span class="number">1</span> + <span class="number">3.</span></span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">apply</span> eq_refl.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>The <code>reflexivity</code> tactic is essentially just shorthand for <code>apply eq_refl</code>.</p>
<h2 id="Slide-Q-A"><a href="#Slide-Q-A" class="headerlink" title="Slide Q &amp; A"></a>Slide Q &amp; A</h2><ul>
<li>(4) has to be applicable thing, i.e. lambda, or “property” in the notion!</li>
</ul>
<p>In terms of provability of <code>reflexivity</code></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">fun</span> n =&gt; S (S n)) = (<span class="keyword">fun</span> n =&gt; <span class="number">2</span> + n)          <span class="comment">(* reflexivity *)</span></span><br><span class="line">(<span class="keyword">fun</span> n =&gt; S (S n)) = (<span class="keyword">fun</span> n =&gt; n + <span class="number">2</span>)          <span class="comment">(* rewrite add_com *)</span></span><br></pre></td></tr></table></figure>

<h3 id="Inversion-Again"><a href="#Inversion-Again" class="headerlink" title="Inversion, Again"></a>Inversion, Again</h3><blockquote>
<p>We’ve seen inversion used with both equality hypotheses and hypotheses about inductively defined propositions. Now that we’ve seen that these are actually the same thing</p>
</blockquote>
<p>In general, the <code>inversion</code> tactic…</p>
<ol>
<li>take hypo <code>H</code> whose type <code>P</code> is inductively defined</li>
<li>for each constructor <code>C</code> in <code>P</code><ol>
<li>generate new subgoal (assume <code>H</code> was built with <code>C</code>)</li>
<li>add the arguments (i.e. evidences of premises) of <code>C</code> as extra hypo (to the context of subgoal)</li>
<li>(apply <code>constructor</code> theorem), match the conclusion of <code>C</code>, calculates a set of equalities (some extra restrictions)</li>
<li>adds these equalities</li>
<li>if there is contradiction, <code>discriminate</code>, solve subgoal.</li>
</ol>
</li>
</ol>
<h3 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h3><blockquote>
<p>Q: Can we write <code>+</code> in a communitive way?<br>A: I don’t believe so.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ground_truth">Ground truth</a></p>
<ul>
<li>provided by direct observation (instead of inference)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ground_expression#Ground_terms">Ground term</a> </p>
<ul>
<li>that does not contain any free variables.</li>
</ul>
<p>Groundness</p>
<ul>
<li>根基性?</li>
</ul>
<blockquote>
<p>Weird <code>Axiomness</code> might break the soundness of generated code in OCaml…</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_lf/2019-01-10-sf-lf-10-ind-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_lf/2019-01-10-sf-lf-10-ind-principle/" class="post-title-link" itemprop="url">「SF-LC」10 IndPrinciples</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><blockquote>
<p>每次我们使用 <code>Inductive</code> 来声明数据类型时，Coq 会自动为这个类型生成 _归纳原理_。<br>Every time we declare a new <code>Inductive</code> datatype, Coq automatically generates an <em>induction principle</em> for this type. </p>
</blockquote>
<p>自然数的归纳原理:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> nat_ind. :</span><br><span class="line"></span><br><span class="line">∀ P : nat → <span class="keyword">Prop</span>,</span><br><span class="line">  P <span class="number">0</span>  →</span><br><span class="line">  (∀ n : nat, P n -&gt; P (S n)) →</span><br><span class="line">  ∀ n : nat, P n</span><br></pre></td></tr></table></figure>

<p>written as inference rule:</p>
<pre><code>                    P 0
  ∀ n : nat, P n -&gt; P (S n)
  -------------------------
  ∀ n : nat,        P n
</code></pre>
<blockquote>
<p><code>induction</code> tactic is wrapper of <code>apply t_ind</code></p>
</blockquote>
<blockquote>
<p>Coq 为每一个 <code>Inductive</code> 定义的数据类型生成了归纳原理，包括那些非递归的<br>Coq generates induction principles for every datatype defined with <code>Inductive</code>, including those that aren’t recursive. </p>
</blockquote>
<blockquote>
<p>尽管我们不需要使用归纳来证明非递归数据类型的性质<br>Although of course we don’t need induction to prove properties of non-recursive datatypes. (<code>destruct</code> would be sufficient)</p>
</blockquote>
<blockquote>
<p>归纳原理的概念仍然适用于它们： 它是一种证明一个对于这个类型所有值都成立的性质的方法。<br>the idea of an induction principle still makes sense for them: it gives a way to prove that a property holds for all values of the type.</p>
</blockquote>
<h3 id="Non-recursive"><a href="#Non-recursive" class="headerlink" title="Non-recursive"></a>Non-recursive</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> yesno : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">yes</span></span><br><span class="line">  | <span class="type">no</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> yesno_ind. :</span><br><span class="line">yesno_ind : ∀ P : yesno → <span class="keyword">Prop</span>,</span><br><span class="line">  P yes  →</span><br><span class="line">  P no   →</span><br><span class="line">  ∀ y : yesno, P y </span><br></pre></td></tr></table></figure>

<pre><code>             P yes 
             P no
------------------
∀ y : yesno, P y 
</code></pre>
<h3 id="Structural-Recursive"><a href="#Structural-Recursive" class="headerlink" title="Structural-Recursive"></a>Structural-Recursive</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> natlist : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">nnil</span></span><br><span class="line">  | <span class="type">ncons</span> (n : nat) (l : natlist).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> natlist_ind. :</span><br><span class="line">natlist_ind : ∀ P : natlist → <span class="keyword">Prop</span>,</span><br><span class="line">  P nnil  →</span><br><span class="line">  (∀ (n : nat) (l : natlist), P l -&gt; P (ncons n l)) →</span><br><span class="line">  ∀ l : natlist, P l </span><br></pre></td></tr></table></figure>

<pre><code>                                  P nnil 
∀ (n : nat) (l : natlist), P l -&gt; P (ncons n l)
-----------------------------------------------
∀ l : natlist,                    P l 
</code></pre>
<p><code>P</code> only need to fullfill <code>l : the_type</code> but not <code>n:nat</code> since we are proving property of <code>the_type</code>.</p>
<h3 id="The-Pattern"><a href="#The-Pattern" class="headerlink" title="The Pattern"></a>The Pattern</h3><blockquote>
<p>These generated principles follow a similar pattern. </p>
</blockquote>
<ul>
<li>induction on each cases </li>
<li>proof by exhaustiveness?</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> t : <span class="keyword">Type</span> := </span><br><span class="line">  | <span class="type">c1</span> (x1 : a1) ... (xn : an)</span><br><span class="line">  ...</span><br><span class="line">  | <span class="type">cn</span> ...</span><br><span class="line"></span><br><span class="line">t_ind : ∀P : t → <span class="keyword">Prop</span>,</span><br><span class="line">              ... <span class="built_in">case</span> <span class="keyword">for</span> c1 ... →</span><br><span class="line">              ... <span class="built_in">case</span> <span class="keyword">for</span> c2 ... → ...</span><br><span class="line">              ... <span class="built_in">case</span> <span class="keyword">for</span> cn ... →</span><br><span class="line">              ∀n : t, P n</span><br></pre></td></tr></table></figure>

<p>对于 <code>t</code> 的归纳原理是又所有对于 <code>c</code> 的归纳原理所组成的: （即所有 case 成立)</p>
<p>对于 <code>c</code> 的归纳原理则是</p>
<blockquote>
<p>对于所有的类型为 <code>a1...an</code> 的值 <code>x1...xn</code>，如果 <code>P</code> 对每个 归纳的参数（每个具有类型 <code>t</code> 的 <code>xi</code>）都成立，那么 <code>P</code> 对于 <code>c x1 ... xn</code> 成立”</p>
</blockquote>
<p>每个具有类型 <code>t</code> 的参数的地方即发生了「递归」与「子结构」，归纳假设 &#x3D; 「对子结构成立」.</p>
<h2 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h2><p>接下来考虑多态列表：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(* in ADT syntax *)</span></span><br><span class="line"><span class="keyword">Inductive</span> list (X:<span class="keyword">Type</span>) : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">nil</span> </span><br><span class="line">  | <span class="type">cons</span> (x : X) (l&#x27;: list X) </span><br><span class="line"></span><br><span class="line"><span class="comment">(* in GADT syntax *)</span></span><br><span class="line"><span class="keyword">Inductive</span> list (X:<span class="keyword">Type</span>) : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">nil</span> : list X</span><br><span class="line">  | <span class="type">cons</span> : X → list X → list X.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>here, the whole def is <em>parameterized</em> on a <code>set X</code>: that is, we are defining a <em>family</em> of inductive types <code>list X</code>, one for each <code>X</code>.</p>
</blockquote>
<p>这里，整个定义都是被集合 <code>X</code> <em>参数化_的：<br>也即，我们定义了一个族 <code>list : X -&gt; Type</code>, 对于每个 <code>X</code>，我们都有一个对应的_项</em>: <code>list X</code>, which is a <code>Type</code>, 可写作 <code>list X : Type</code>.</p>
<blockquote>
<p><code>list_ind</code> can be thought of as a polymorphic function that,<br>when applied to a type <code>X</code>, gives us back an induction principle specialized to the type <code>list X</code>.</p>
</blockquote>
<p>因此，其归纳定理 <code>list_ind</code> 是一个被 <code>X</code> 参数化多态的函数。<br>当应用 <code>X : Type</code> 时，返回一个特化在 <code>list X : Type</code> 上的归纳原理</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list_ind : ∀(X : <span class="keyword">Type</span>) (P : list X → <span class="keyword">Prop</span>),</span><br><span class="line">    P [] →</span><br><span class="line">    (∀(x : X) (l : list X), P l → P (x :: l)) →</span><br><span class="line">    ∀l : list X, P l</span><br></pre></td></tr></table></figure>

<pre><code>∀(X : Type), &#123;

                           P []                   -- base structure holds
    ∀(x : X) (l : list X), P l → P (x :: l)       -- sub-structure holds -&gt; structure holds
    ---------------------------------------
    ∀l : list X,           P l                    -- all structure holds

&#125;
</code></pre>
<h2 id="Induction-Hypotheses-归纳假设"><a href="#Induction-Hypotheses-归纳假设" class="headerlink" title="Induction Hypotheses 归纳假设"></a>Induction Hypotheses 归纳假设</h2><blockquote>
<p> The induction hypothesis is the <em>premise</em> of this latter implication<br>— the assumption that <code>P</code> holds of <code>n&#39;</code>, which we are allowed to use in proving that <code>P</code> holds for <code>S n&#39;</code>.</p>
</blockquote>
<p><em>归纳假设就是 <code>P n&#39; -&gt; P (S n&#39;)</code> 这个蕴含式中的前提部分</em><br>使用 <code>nat_ind</code> 时需要显式得用 <code>intros n IHn</code> 引入，于是就变成了 proof context 中的假设.</p>
<h2 id="More-on-the-induction-Tactic"><a href="#More-on-the-induction-Tactic" class="headerlink" title="More on the induction Tactic"></a>More on the <code>induction</code> Tactic</h2><h3 id="“Re-generalize”-重新泛化"><a href="#“Re-generalize”-重新泛化" class="headerlink" title="“Re-generalize” 重新泛化"></a>“Re-generalize” 重新泛化</h3><p>Noticed that in proofs using <code>nat_ind</code>, we need to keep <code>n</code> generailzed.<br>if we <code>intros</code> particular <code>n</code> first then <code>apply nat_ind</code>, it won’t works…</p>
<p>But we could <code>intros n. induction n.</code>, that’s <code>induction</code> tactic internally “re-generalize” the <code>n</code> we perform induction on.</p>
<h3 id="Automatic-intros-i-e-specialize-variables-before-the-variable-we-induction-on"><a href="#Automatic-intros-i-e-specialize-variables-before-the-variable-we-induction-on" class="headerlink" title="Automatic intros i.e. specialize variables before the variable we induction on"></a>Automatic <code>intros</code> i.e. specialize variables before the variable we induction on</h3><p>A canonical case is <code>induction n</code> vs <code>induction m</code> on theorem <code>plus_comm&#39;&#39; : ∀n m : nat, n + m = m + n.</code>.<br>to keep a var generial…we can either change variable order under <code>∀</code>, or using <code>generalize dependent</code>.</p>
<h2 id="Induction-Principles-in-Prop"><a href="#Induction-Principles-in-Prop" class="headerlink" title="Induction Principles in Prop"></a>Induction Principles in Prop</h2><h3 id="理解依赖类型的归纳假设-与-Coq-排除证据参数的原因"><a href="#理解依赖类型的归纳假设-与-Coq-排除证据参数的原因" class="headerlink" title="理解依赖类型的归纳假设 与 Coq 排除证据参数的原因"></a>理解依赖类型的归纳假设 与 Coq 排除证据参数的原因</h3><p>除了集合 <code>Set</code>，命题 <code>Prop</code> 也可以是归纳定义与 <code>induction</code> on 得.<br>难点在于：<em>Inductive Prop</em> 通常是 dependent type 的，这里会带来复杂度。</p>
<p>考虑命题 <code>even</code>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> even : nat → <span class="keyword">Prop</span> :=</span><br><span class="line"> | <span class="type">ev_0</span> : even <span class="number">0</span></span><br><span class="line"> | <span class="type">ev_SS</span> : ∀n : nat, even n → even (S (S n)).</span><br></pre></td></tr></table></figure>

<p>我们可以猜测一个最 general 的归纳假设：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ev_ind_max : ∀ P : (∀n : nat, even n → <span class="keyword">Prop</span>),</span><br><span class="line">  P O ev_0 →</span><br><span class="line">  (∀(m : nat) (E : even m), P m E → P (S (S m)) (ev_SS m E)) →</span><br><span class="line">  ∀(n : nat) (E : even n), P n E</span><br></pre></td></tr></table></figure>

<p>即:</p>
<pre><code>                                   P 0 ev_0                    -- base 
  ∀(m : nat) (E : even m), P m E → P (S (S m)) (ev_SS m E)     -- sub structure -&gt; structure
  --------------------------------------------------------
  ∀(n : nat) (E : even n),         P n E                       -- all structure
</code></pre>
<p>注意这里:</p>
<ol>
<li><code>even</code> is <em>indexed</em> by nat <code>n</code> (对比 <code>list</code> is <em>parametrized</em> by <code>X</code>)</li>
</ol>
<ul>
<li>从族的角度:  <code>even : nat -&gt; Prop</code>, a family of <code>Prop</code> indexed by <code>nat</code></li>
<li>从实体角度: 每个 <code>E : even n</code> 对象都是一个 evidence that <em>particular nat is even</em>.</li>
</ul>
<ol start="2">
<li>要证的性质 <code>P</code> is parametrized by <code>E : even n</code> 也因此连带着 by <code>n</code>. 也就是 <code>P : (∀n : nat, even n → Prop)</code>  (对比 <code>P : list X → Prop</code>)</li>
</ol>
<ul>
<li>所以其实关于 <code>even n</code> 的性质是同时关于数字 <code>n</code> 和证据 <code>even n</code> 这两件事的.</li>
</ul>
<p>因此 <code>sub structure -&gt; structure</code> 说得是：</p>
<blockquote>
<p>whenever <code>n</code> is an even number and <code>E</code> is an evidence of its evenness, if <code>P</code> holds of <code>n</code> and <code>E</code>, then it also holds of <code>S (S n)</code> and <code>ev_SS n E</code>.<br>对于任意数字 <code>n</code> 与证据 <code>E</code>，如果 <code>P</code> 对 <code>n</code> 和 <code>E</code> 成立，那么它也对 <code>S (S n)</code> 和 <code>ev_SS n E</code> 成立。</p>
</blockquote>
<p>然而，当我们 <code>induction (H : even n)</code> 时，我们通常想证的性质并不包括「证据」，而是「满足该性质的这 <code>Type</code> 东西」的性质,<br>比如:</p>
<ol>
<li><code>nat</code> 上的一元关系 (性质)    证明 <code>nat</code> 的性质          :  <code>ev_even : even n → ∃k, n = double k</code></li>
<li><code>nat</code> 上的二元关系           证明 <code>nat</code> 上的二元关系    :  <code>le_trans : ∀m n o, m ≤ n → n ≤ o → m ≤ o</code> </li>
<li>二元关系 <code>reg_exp × list T</code> 证明 二元关系 <code>reg_exp × T</code>:  <code>in_re_match : ∀T (s : list T) (x : T) (re : reg_exp), s =~ re → In x s → In x (re_chars re).</code><br>都是如此，</li>
</ol>
<p>因此我们也不希望生成的归纳假设是包括证据的…<br>原来的归纳假设：</p>
<pre><code>  ∀P : (∀n : nat, even n → Prop),
  ... →
  ∀(n : nat) (E : even n), P n E
  
</code></pre>
<p>可以被简化为只对 <code>nat</code> 参数化的归纳假设：</p>
<pre><code>  ∀P : nat → Prop,
  ... →
  ∀(n : nat) (E: even n), P n
  
</code></pre>
<p>因此 coq 生成的归纳原理也是不包括证据的。注意 <code>P</code> 丢弃了参数 <code>E</code>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">even_ind : ∀ P : nat -&gt; <span class="keyword">Prop</span>,</span><br><span class="line">  P <span class="number">0</span> →</span><br><span class="line">  (∀ n : nat, even n -&gt; P n -&gt; P (S (S n))) →</span><br><span class="line">  ∀ n : nat, even n -&gt; P n *)</span><br></pre></td></tr></table></figure>

<p>用人话说就是：</p>
<ol>
<li>P 对 0 成立，</li>
<li>对任意 n，如果 n 是偶数且 P 对 n 成立，那么 P 对 S (S n) 成立。<br>&#x3D;&gt; P 对所有偶数成立</li>
</ol>
<h3 id="“General-Parameter”"><a href="#“General-Parameter”" class="headerlink" title="“General Parameter”"></a>“General Parameter”</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> le : nat → nat → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">le_n</span> : ∀ n,               le n n</span><br><span class="line">  | <span class="type">le_S</span> : ∀ n m, (le n m) → (le n (S m)).</span><br></pre></td></tr></table></figure>

<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> le (n:nat) : nat → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">le_n</span>                : le n n</span><br><span class="line">  | <span class="type">le_S</span> m (H : le n m) : le n (S m).</span><br></pre></td></tr></table></figure>

<p>两者虽然等价，但是共同的 <code>∀ n</code> 可以被提升为 typecon 的参数, i.e. “General Parameter” to the whole definition.</p>
<p>其生成的归纳假设也会不同: (after renaming)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">le_ind : ∀ P : nat -&gt; nat -&gt; <span class="keyword">Prop</span>,</span><br><span class="line">  (∀ n : nat, P n n) -&gt;</span><br><span class="line">  (∀ n m : nat, le n m -&gt; P n m -&gt; P n (S m)) -&gt;</span><br><span class="line">  ∀ n m : nat, le n m -&gt; P n m </span><br></pre></td></tr></table></figure>

<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">le_ind : ∀ (n : nat) (P : nat -&gt; <span class="keyword">Prop</span>),</span><br><span class="line">  P n -&gt;</span><br><span class="line">  (∀ m : nat, n &lt;= m -&gt; P m -&gt; P (S m)) -&gt;</span><br><span class="line">  ∀ m : nat, n &lt;= m -&gt; P m </span><br></pre></td></tr></table></figure>

<p>The 1st one looks more symmetric but 2nd one is easier (for proving things).</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_lf/2019-01-11-sf-lf-11-rel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_lf/2019-01-11-sf-lf-11-rel/" class="post-title-link" itemprop="url">「SF-LC」11 Rel</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>relation 与injective&#x2F;surjective&#x2F;bijective function 等相关的知识在 <code>5. Tactics</code> 里，为了避免每次都要 <code>grep</code> 我在这里写一下。</p>
</blockquote>
<h2 id="Relations"><a href="#Relations" class="headerlink" title="Relations"></a>Relations</h2><h3 id="Recalling-Relation"><a href="#Recalling-Relation" class="headerlink" title="Recalling Relation"></a>Recalling <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Finitary_relation">Relation</a></h3><p>from FCT&#x2F;TAPL&#x2F;Wiki…</p>
<blockquote>
<p>a possible connection between the components of a k-tuple.</p>
</blockquote>
<p>I have been long confused with <em>Unary Relations vs. Binary Relation on the Same Set (homogeneous relation)</em><br>I thought they were same…but turns out they are totally different!</p>
<h4 id="Unary-1-place-relation-is-Predicate-or-Property"><a href="#Unary-1-place-relation-is-Predicate-or-Property" class="headerlink" title="Unary&#x2F;1-place relation is Predicate or Property!"></a>Unary&#x2F;1-place relation is <strong>Predicate</strong> or <strong>Property</strong>!</h4><p>Either defined via set <code>X ⊆ P</code> or <code>x ∈ P</code>,<br>or defined via function <code>P : X -&gt; Bool</code> or <code>P : X -&gt; &#123;⊥, ⊤&#125;</code>.<br>(usually used in Math. Logic)</p>
<p>Property &#x3D; Indicator Fn &#x3D; characteristic Fn &#x3D; Boolean Predicate Fn &#x3D; Predicate</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Property_(mathematics)">https://en.wikipedia.org/wiki/Property_(mathematics)</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Indicator_function">https://en.wikipedia.org/wiki/Indicator_function</a></li>
</ul>
<h4 id="Binary-Relation-2-place-relation"><a href="#Binary-Relation-2-place-relation" class="headerlink" title="Binary Relation&#x2F;2-place relation"></a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Binary_relation">Binary Relation&#x2F;2-place relation</a></h4><p>Defined via two sets : <code>R ⊆ X × Y</code> or <code>x, y ∈ R</code> or <code>xRy</code>.  (where <code>x ∈ X, y ∈ Y</code>.)<br>or via function <code>R: X × Y -&gt; Bool</code>.</p>
<h5 id="Homogeneous-Relation-同类（的）关系"><a href="#Homogeneous-Relation-同类（的）关系" class="headerlink" title="Homogeneous Relation 同类（的）关系"></a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Binary_relation#Homogeneous_relation">Homogeneous Relation 同类（的）关系</a></h5><p>Specifically! when <code>X = Y</code>, is called a <em>homogeneous relation</em>: </p>
<p>Noticed that we are still concerning relations of <strong>2 elements</strong>!!, but they are from the same Set!<br>(while 1-place relation concerning only 1 element.)</p>
<pre><code>R ⊆ X × X
xRy where x ∈ X, y ∈ X
</code></pre>
<p>it’s written&#x2F;spoken <em>Binary</em> relation <strong>on&#x2F;over</strong> Set <code>X</code>.<br>Properties e.g. <em>reflexive, symmetric, transitive</em>, are all properties of “Homogeneous Relation”!</p>
<h3 id="Back-to-Coq"><a href="#Back-to-Coq" class="headerlink" title="Back to Coq"></a>Back to Coq</h3><p>“relation” is a general idea. but in Coq standard lib it means “binary relation on <em>a</em> set X”</p>
<blockquote>
<p>Coq <code>identifier</code> relation will always refer to a binary relation between some set and itself.</p>
</blockquote>
<p>it’s defined as <em>a family of Prop parameterized by two elements of <code>X</code></em>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> relation (X: <span class="keyword">Type</span>) := X → X → <span class="keyword">Prop</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> le : nat -&gt; nat -&gt; <span class="keyword">Prop</span>.</span><br><span class="line"><span class="keyword">Check</span> le : relation nat.</span><br></pre></td></tr></table></figure>




<h2 id="Basic-Properties"><a href="#Basic-Properties" class="headerlink" title="Basic Properties"></a>Basic Properties</h2><blockquote>
<p>ways to classifying relations.<br>so theorems can be proved generically about certain sorts of relations</p>
</blockquote>
<p>It’s pretty fun to see all mathematical things defined in Coq!<br>(much more constructive)</p>
<h3 id="Partial-Function"><a href="#Partial-Function" class="headerlink" title="Partial Function"></a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Partial_function">Partial Function</a></h3><blockquote>
<p>function is defined as <em>a special kind of binary relation</em>. </p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> partial_function &#123;X: <span class="keyword">Type</span>&#125; (R: relation X) :=</span><br><span class="line">  ∀x y1 y2 : X, R x y1 → R x y2 → y1 = y2.</span><br></pre></td></tr></table></figure>

<p>meaning that foreach input <code>x ∈ X</code>, there is a <em>unique</em> <code>y ∈ Y</code> corresponded.</p>
<p>But this only establish a <em>partial function</em>.<br>because it doesn’t say anything about <em>totality</em>,<br>to define <em>total function</em>, we require <code>f</code> map every <code>x ∈ X</code>. </p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Connex_relation">Total “Relation”</a></p>
<p>  ∀x ∀y (x ∈ X ∧ y ∈ X) ⇒ (xRy ∨ yRx).</p>
</li>
</ul>
<p>totally different with <em>total function</em> but ask the binary relation holds between every pair.</p>
<h3 id="Reflexive"><a href="#Reflexive" class="headerlink" title="Reflexive"></a>Reflexive</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> transitive &#123;X: <span class="keyword">Type</span>&#125; (R: relation X) :=</span><br><span class="line">  ∀a b c : X, (R a b) → (R b c) → (R a c).</span><br></pre></td></tr></table></figure>

<h3 id="Transitive"><a href="#Transitive" class="headerlink" title="Transitive"></a>Transitive</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> transitive &#123;X: <span class="keyword">Type</span>&#125; (R: relation X) :=</span><br><span class="line">  ∀a b c : X, (R a b) → (R b c) → (R a c).</span><br></pre></td></tr></table></figure>

<h3 id="Symmetric-Antisymmetric"><a href="#Symmetric-Antisymmetric" class="headerlink" title="Symmetric &amp; Antisymmetric"></a>Symmetric &amp; Antisymmetric</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> symmetric &#123;X: <span class="keyword">Type</span>&#125; (R: relation X) :=</span><br><span class="line">  ∀a b : X, (R a b) → (R b a).</span><br><span class="line">  </span><br><span class="line"><span class="keyword">Definition</span> antisymmetric &#123;X: <span class="keyword">Type</span>&#125; (R: relation X) :=</span><br><span class="line">  ∀a b : X, (R a b) → (R b a) → a = b.</span><br></pre></td></tr></table></figure>

<h4 id="Antisymmetric-vs-Asymmetric-vs-Non-symmetric-反对称-vs-非对称-vs-不-对称"><a href="#Antisymmetric-vs-Asymmetric-vs-Non-symmetric-反对称-vs-非对称-vs-不-对称" class="headerlink" title="Antisymmetric vs Asymmetric vs Non-symmetric (反对称 vs. 非对称 vs. 不-对称)"></a>Antisymmetric vs Asymmetric vs Non-symmetric (反对称 vs. 非对称 vs. 不-对称)</h4><p>A relation is <strong>asymmetric</strong> if and only if it is both antisymmetric and irreflexive<br>e.g. <code>&lt;=</code> is neither symmetric nor asymmetric, but it’s antisymmetric…<br>反对称: 可以自反 (只能 reflexive 时对称) <code>&lt;=</code><br>非对称: 不能自反 <code>&lt;</code><br>不对称: 不是对称 </p>
<h3 id="Equivalence"><a href="#Equivalence" class="headerlink" title="Equivalence"></a>Equivalence</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> equivalence &#123;X:<span class="keyword">Type</span>&#125; (R: relation X) :=</span><br><span class="line">  (reflexive R) ∧ (symmetric R) ∧ (transitive R).</span><br></pre></td></tr></table></figure>


<h3 id="Partial-Orders"><a href="#Partial-Orders" class="headerlink" title="Partial Orders"></a>Partial Orders</h3><p>A partial order under which <em>every pair</em> of elements is <em>comparable</em> is called a <strong>total order</strong> or <strong>linear order</strong><br>In the Coq standard library it’s called just <code>order</code> for short:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> order &#123;X:<span class="keyword">Type</span>&#125; (R: relation X) :=</span><br><span class="line">  (reflexive R) ∧ (antisymmetric R) ∧ (transitive R).</span><br></pre></td></tr></table></figure>


<h3 id="Preorders"><a href="#Preorders" class="headerlink" title="Preorders"></a>Preorders</h3><p>a.k.a quasiorder</p>
<p>The <em>subtyping</em> relations are usually preorders.</p>
<blockquote>
<p>(TAPL p185) because of the record permutation rule…there are many pairs of distinct types where each is a subtype of the other.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> preorder &#123;X:<span class="keyword">Type</span>&#125; (R: relation X) :=</span><br><span class="line">  (reflexive R) ∧ (transitive R).</span><br></pre></td></tr></table></figure>





<h2 id="Reflexive-Transitive-Closure"><a href="#Reflexive-Transitive-Closure" class="headerlink" title="Reflexive, Transitive Closure"></a>Reflexive, Transitive Closure</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Closure_(mathematics)#Binary_relation_closures">Closure</a><br>Closure can be considered as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Binary_relation#Operations_on_binary_relations">Operations on bin-rel</a></p>
</blockquote>
<p>As properties such as <em>reflexive, transitive</em>,<br>the <strong>blah blah Closure</strong> are only talking about “homogeneous relations” i.e., Relation on a SINGLE set.</p>
<h3 id="Reflexive-Closure"><a href="#Reflexive-Closure" class="headerlink" title="Reflexive Closure"></a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reflexive_closure">Reflexive Closure</a></h3><p>Def. smallest reflexive relation on <code>X</code> containing <code>R</code>.</p>
<p>Operationally, as a <code>=</code> operator on a binary relation <code>R</code>:</p>
<pre><code>R⁼ = R ∪ &#123; (x, x) | x ∈ X &#125;
</code></pre>
<p>and this obviously satisfy <code>R⁼ ⊇ R</code>.</p>
<h3 id="Transitive-Closure"><a href="#Transitive-Closure" class="headerlink" title="Transitive Closure"></a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transitive_closure">Transitive Closure</a></h3><p>Def. smallest transitive relation on <code>X</code> containing <code>R</code>.</p>
<p>Operationally, as a <code>+</code> operator on a binary relation <code>R</code>:</p>
<pre><code>R+ = R ∪ &#123; (x1,xn) | n &gt; 1 ∧ (x1,x2), ..., (xn-1,xn) ∈ R &#125;
</code></pre>
<p>We can also constructively and inductively definition using <code>R^i</code> where <code>i = i-transitivity away</code>.</p>
<h3 id="Reflexive-Transitive-Closure-1"><a href="#Reflexive-Transitive-Closure-1" class="headerlink" title="Reflexive, Transitive Closure"></a>Reflexive, Transitive Closure</h3><pre><code>R* = R⁼ ∪ R+
</code></pre>
<h3 id="Why-is-it-useful"><a href="#Why-is-it-useful" class="headerlink" title="Why is it useful?"></a>Why is it useful?</h3><blockquote>
<p>The idea is that <em>a relation is extended</em> s.t.<br><em>the derived relation has the (reflexsive and) transitive property.</em> – Prof. Arthur</p>
</blockquote>
<blockquote>
<p>e.g.<br>the “descendant” relation is the transitive closure of the “child” relation,<br>the “derives-star (⇒⋆)” relation is the reflexive-transitive closure of the “derives (⇒)” relation.<br>the “ε-closure” relation is the reflexive-transitive closure of the “ε-transition” relation.<br>the “Kleene-star (Σ⋆)” relation is the reflexive-transitive closure of the “concatentation” relation.</p>
</blockquote>
<p>Another way is to think them as “set closed under some operation”.</p>
<h3 id="Back-to-Coq-1"><a href="#Back-to-Coq-1" class="headerlink" title="Back to Coq"></a>Back to Coq</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> clos_refl_trans &#123;A: <span class="keyword">Type</span>&#125; (R: relation A) : relation A :=</span><br><span class="line">  | <span class="type">rt_step</span> x y (H : R x y) : clos_refl_trans R x y        <span class="comment">(** original relation **)</span></span><br><span class="line">  | <span class="type">rt_refl</span> x : clos_refl_trans R x x                      <span class="comment">(** reflexive  xRx              **)</span></span><br><span class="line">  | <span class="type">rt_trans</span> x y z                                         <span class="comment">(** transitive xRy ∧ yRz → xRz  **)</span></span><br><span class="line">        (Hxy : clos_refl_trans R x y)</span><br><span class="line">        (Hyz : clos_refl_trans R y z) :</span><br><span class="line">        clos_refl_trans R x z.</span><br></pre></td></tr></table></figure>

<p>The above version will generate 2 IHs in <code>rt_trans</code> case. (since the proof tree has 2 branches).</p>
<p>Here is a better “linked-list”-ish one. (we will exclusively use this style)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> clos_refl_trans_1n &#123;A : <span class="keyword">Type</span>&#125; (R : relation A) (x : A) : A → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">rt1n_refl</span> : clos_refl_trans_1n R x x</span><br><span class="line">  | <span class="type">rt1n_trans</span> (y z : A)</span><br><span class="line">      (Hxy   : R x y) </span><br><span class="line">      (Hrest : clos_refl_trans_1n R y z) :</span><br><span class="line">      clos_refl_trans_1n R x z.</span><br></pre></td></tr></table></figure>

<p>In later chapter, we will define a decorator <code>multi</code> that can take any binary relation on a set and return its closure relation:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> multi (X : <span class="keyword">Type</span>) (R : relation X) : relation X :=</span><br><span class="line">  | <span class="type">multi_refl</span> : <span class="keyword">forall</span> x     : X,                         multi R x x</span><br><span class="line">  | <span class="type">multi_step</span> : <span class="keyword">forall</span> x y z : X, R x y -&gt; multi R y z -&gt; multi R x z</span><br></pre></td></tr></table></figure>

<p>We name it <code>step</code>, standing for <em>doing one step of this relation</em>, and then we still have the rest (sub-structure) satisfied the closure relation.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/17/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/19/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">vvbuys</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
