<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="baidu-site-verification" content="codeva-6wmKWl5hmx" />
<meta name="bytedance-verification-code" content="GcOf/MpQ8shZ5Hh/2hvr" />
<meta name="google-site-verification" content="wivqPhuFdISMEKkFZjOWHPYJGSvd716d9R7Bwy2Jj-A" />
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4636539228226058"
     crossorigin="anonymous"></script>
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.vvbuys.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Share some post and some issue for linux program">
<meta property="og:type" content="website">
<meta property="og:title" content="VVbugs Blog">
<meta property="og:url" content="https://www.vvbuys.com/page/24/index.html">
<meta property="og:site_name" content="VVbugs Blog">
<meta property="og:description" content="Share some post and some issue for linux program">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="vvbuys">
<meta property="article:tag" content="Linux hyprland Python Rust Golang javascript">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.vvbuys.com/page/24/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/24/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>VVbugs Blog - standalone Linux lover</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">VVbugs Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">standalone Linux lover</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">vvbuys</p>
  <div class="site-description" itemprop="description">Share some post and some issue for linux program</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">265</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2021-10-29-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-10-29-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">「算法刷题」贪心算法的相关经典题目</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-29T00:00:00+00:00">2021-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-02 01:00:55" itemprop="dateModified" datetime="2024-02-02T01:00:55+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>455</td>
<td>分发饼干（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ransom-note/">383. 赎金信 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>为了了满足更多的小孩，就不要造成饼干尺寸的浪费。</p>
<p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p>
<p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p>
<p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p>
<p>然后从后向前遍历小孩数组，用大饼干优先满足 </p>
<p><img src="C:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211029212703299.png" alt="image-20211029212703299"></p>
<p>这个例子可以看出饼干9只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 饼干数组的下标</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出我用了一个index来控制饼干数组的遍历，遍历饼干并没有再起一个for循环，而是采用自减的方式，这也是常用的技巧。</p>
<p>有的同学看到要遍历两个数组，就想到用两个for循环，那样逻辑其实就复杂了。</p>
<p><strong>也可以换一个思路，小饼干先喂饱小胃口</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; g.<span class="built_in">size</span>() &amp;&amp; g[index] &lt;= s[i])&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1005</td>
<td>K次取反后最大化的数组和（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>本题思路其实比较好想了，如何可以让数组和最大呢？</p>
<p>贪心的思路，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。</p>
<p>局部最优可以推出全局最优。</p>
<p>那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。</p>
<p>那么又是一个贪心：局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），全局最优：整个 数组和 达到最大。</p>
<p>虽然这道题目大家做的时候，可能都不会去想什么贪心算法，一鼓作气，就AC了。</p>
<p><strong>我这里其实是为了给大家展现出来 经常被大家忽略的贪心思路，这么一道简单题，就用了两次贪心！</strong></p>
<p>那么本题的解题步骤为：</p>
<ul>
<li>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li>
<li>第二步：从前向后遍历，遇到负数将其变为正数，同时K–</li>
<li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li>
<li>第四步：求和</li>
</ul>
<p>对应C++代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">static bool cmp(int a,int b)&#123;</span><br><span class="line">    return abs(a)&gt;abs(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int largestSumAfterKNegations(vector&lt;int&gt;&amp; A, int K) &#123;</span><br><span class="line">        //将数组按照绝对值大小，从大到小排列</span><br><span class="line">        sort(A.begin(),A.end(),cmp);</span><br><span class="line">        //如果数组中有负数，转为正数，同时k--</span><br><span class="line">        for(int i=0;i&lt;A.size()-1;i++)&#123;</span><br><span class="line">            if(A[i]&lt;0&amp;&amp;K&gt;0)&#123;</span><br><span class="line">                A[i]*=-1;</span><br><span class="line">                K--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果k不为0，把数组中最小的数反复乘以-1，直到k用完</span><br><span class="line">        //K%2==0的话，数组中的数还是原数</span><br><span class="line">        if(K%2==1)&#123;</span><br><span class="line">            A[A.size()-1]*=-1;</span><br><span class="line">        &#125;</span><br><span class="line">        //求和</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int a:A)&#123;</span><br><span class="line">            res+=a;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>860</td>
<td>柠檬水找零（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lemonade-change/">860. 柠檬水找零 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>本题只需维护三种金额的数量：5,10,20，</p>
<p>情况一：账单是5，直接收下。</p>
<p>情况二：账单是10，消耗一个5，增加一个10</p>
<p>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</p>
<p>（收款20时，局部最优：优先消耗10和5，完成本次找零。少消耗5，因为5可以给10和20找零。全局最优：完成全部账单的找零。</p>
<p>局部最优可以推出全局最优，且找不到反例，就可以尝试贪心算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five=<span class="number">0</span>,ten=<span class="number">0</span>,twenty=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> bill:bills)&#123;</span><br><span class="line">            <span class="comment">//收到5</span></span><br><span class="line">            <span class="keyword">if</span>(bill==<span class="number">5</span>)&#123;</span><br><span class="line">                five++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//收到10</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bill==<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(five&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ten++;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//收到20</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bill==<span class="number">20</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(five&gt;=<span class="number">1</span>&amp;&amp;ten&gt;=<span class="number">1</span>)&#123;<span class="comment">//优先用10来找零</span></span><br><span class="line">                    five--;</span><br><span class="line">                    ten--;</span><br><span class="line">                    twenty++;<span class="comment">//可以不记录20块钱的个数，不用20找零</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(five&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                    five-=<span class="number">3</span>;</span><br><span class="line">                    twenty++;<span class="comment">//可以不记录20块钱的个数，不用20找零</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>53</td>
<td>最大子序和（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p>
<p>全局最优：选取最大“连续和”</p>
<p>遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。</p>
<p>中间的最大和由result记录下来了。</p>
<p>题目中的答案有个示例【-2，-1】</p>
<p>if(result&lt;count)和if(count&lt;&#x3D;0)，写的时候我颠倒了，会改变了count的值，res就记录不到正确的最大值了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MIN;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            count+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(result&lt;count)&#123;</span><br><span class="line">                result=count;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(count&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>452</td>
<td>用最少数量的箭引爆气球（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少</p>
<p>试一下举反例，发现没有这种情况。</p>
<p>那么就试一试贪心吧！</p>
<p>局部最优：当气球出现重叠，一起射，所用弓箭最少。</p>
<p>全局最优：把所有气球射爆所用弓箭最少。</p>
<p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。用到sort函数</p>
<p>这里的排序不是简单的对整数排序，是按照数组的第一元素从小到大排序，不能简单地用sort(nums.begin(),nums.end()),</p>
<p>而是用sort(nums.begin(),nums.end(),cmp),cmp函数必须加上static，返回值是bool类型。例如：</p>
<p>static bool cmp(vector<int>&amp; a,vector<int>&amp; b){</p>
<p>​    return a[0]&lt;b[0];</p>
<p>  }</p>
<p>传入参数时，如果是数组，用引用&amp;不会另外开辟内存，而是直接用原数组的数进行运算。不用引用&amp;，会为参数另外开辟内存，每次用cmp函数都要花时间开辟内存，可能会运行超出时间限制。</p>
<p><strong>按照气球的起始位置排序，从前向后遍历气球数组</strong>，尽可能让气球重复，前两个区间：比较第一个的右边界&gt;&#x3D;第二个的左边界，则气球重叠。有两个已经重叠，再比较第三个时，要比较前两个区间的最小右边界和第三个区间的左边界。因为如果想三个都重叠，必须满足最小的右边界（画图可以看出）。</p>
<p>前两个重叠时，不用弓箭加一，因为刚开始默认弓箭为1（因为数组数&gt;&#x3D;1）.不重叠，那肯定需要再有一个弓箭射后面的气球，这时弓箭数加一。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*输入一个二维数组，输出一个整数*/</span></span><br><span class="line">        <span class="keyword">if</span>(points.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先将二维数组排序</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> result=<span class="number">1</span>;<span class="comment">// 需要几只箭</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;points.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 会发生重叠</span></span><br><span class="line">            <span class="keyword">if</span>(points[i<span class="number">-1</span>][<span class="number">1</span>]&gt;=points[i][<span class="number">0</span>])&#123;</span><br><span class="line">                points[i][<span class="number">1</span>]=<span class="built_in">min</span>(points[i][<span class="number">1</span>],points[i<span class="number">-1</span>][<span class="number">1</span>]);<span class="comment">// 更新当前气球的右边界</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有重叠</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>435</td>
<td>无重叠区间（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>本题与i452的区别：</p>
<p>移除重叠区间，按照右边界从小到大排序，如果前一个的右边界大于下一个的左边界，则算是重叠，然后保留重叠两个区间的右边界最小值（较大的可能会重叠更多区间，题目要求是移除区间的最小数量）</p>
<p>cmp两种都可以，第二种，考虑了如果两个元素相等，再怎么判断。但a[0]&lt;b[0];应该会对相等情况给一个结果应该。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<pre><code> static bool cmp(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;
    if(a[0]==b[0])&#123;
         return a[1]&lt;b[1];
    &#125;
    return a[0]&lt;b[0];
&#125;
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*输入一个二维数组，输出一个整数*/</span></span><br><span class="line">        <span class="keyword">if</span>(points.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先将二维数组排序</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> result=<span class="number">1</span>;<span class="comment">// 需要几只箭</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;points.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 会发生重叠</span></span><br><span class="line">            <span class="keyword">if</span>(points[i<span class="number">-1</span>][<span class="number">1</span>]&gt;=points[i][<span class="number">0</span>])&#123;</span><br><span class="line">                points[i][<span class="number">1</span>]=<span class="built_in">min</span>(points[i][<span class="number">1</span>],points[i<span class="number">-1</span>][<span class="number">1</span>]);<span class="comment">// 更新当前气球的右边界</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有重叠</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>56</td>
<td>合并区间（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="comment">/*输入一个二维数组，输出一个二维数组*/</span></span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对数组进行排序</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">// 标记最后一个区间有没有合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 当相邻区间重叠时，合并，当前区间i就是合并后的区间</span></span><br><span class="line">            <span class="type">int</span> start=intervals[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> end = intervals[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(i&lt;intervals.<span class="built_in">size</span>()&amp;&amp;end&gt;=intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                end = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>],end);</span><br><span class="line">                <span class="keyword">if</span> (i == intervals.<span class="built_in">size</span>() - <span class="number">1</span>) flag = <span class="literal">true</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123;start,end&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后一个区间没有和前一个区间重叠，将需单独加入result</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123;intervals[intervals.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>], intervals[intervals.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><em>LeetCode题目</em>*</th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>55</td>
<td>跳跃游戏（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/submissions/">55. 跳跃游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>该题判断是否能跳到终点。</p>
<p>刚看到本题一开始可能想：当前位置元素如果是3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？</p>
<p>其实跳几步无所谓，关键在于可跳的覆盖范围！不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。</p>
<p>这个范围内，别管是怎么跳的，反正一定可以跳过来。</p>
<p><strong>那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！</strong></p>
<p>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p>
<p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 只有一个元素，就是能达到</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cover; i++) &#123; <span class="comment">// 注意这里是小于等于cover</span></span><br><span class="line">            cover = <span class="built_in">max</span>(i + nums[i], cover);</span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 说明可以覆盖到终点了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>题目</th>
<th>相关链接</th>
</tr>
</thead>
<tbody><tr>
<td>763划分字母区间（中等难度）</td>
<td></td>
</tr>
</tbody></table>
<p>记录每个字符在数组中出现的最远距离，找到之前遍历过的所有字母的最远边界，这个边界点就是分割点。前面出现的所有字母最远就到这个边界。</p>
<p>分为两步：</p>
<p>1 统计每个字符出现的最远位置</p>
<p>2 从头遍历字符，更新字符出现的最远下表，如果找到字符最远出现位置下表和当前下标相等，则找到了分割点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 记录每个字符出现的最远下标</span></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">27</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hash[s[i]-<span class="string">&#x27;a&#x27;</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            right=<span class="built_in">max</span>(right,hash[s[i]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(i==right)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(right-left+<span class="number">1</span>);</span><br><span class="line">                left=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><em>LeetCode题目</em>*</th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>135</td>
<td>（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/submissions/">55. 跳跃游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼。</strong></p>
<p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p>
<p>此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p>
<p>2.再确定左孩子大于右孩子的情况（从后向前遍历）</p>
<p>遍历顺序这里有同学可能会有疑问，为什么不能从前向后遍历呢？</p>
<p>因为如果从前向后遍历，根据 ratings[i + 1] 来确定 ratings[i] 对应的糖果，那么每次都不能利用上前一次的比较结果了。</p>
<p>如果 ratings[i] &gt; ratings[i + 1]，此时candyVec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量），一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量）。</p>
<p>那么又要贪心了，局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量即大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p>
<p>整体代码：     </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyVec</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从前向后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从后向前</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) &#123;</span><br><span class="line">                candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计结果</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candyVec.<span class="built_in">size</span>(); i++) result += candyVec[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2021-10-29-%E3%80%90%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB%E3%80%91%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-10-29-%E3%80%90%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB%E3%80%91%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/" class="post-title-link" itemprop="url">「论文分享」自适应神经树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-29 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-29T00:00:00+00:00">2021-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-02 01:00:55" itemprop="dateModified" datetime="2024-02-02T01:00:55+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>​		《Adaptive Neural Trees》是来自英国伦敦的Ryutaro Tanno等人发表在ICML 2019（CCF推荐的A类会议）上的一篇论文，这里是<a target="_blank" rel="noopener" href="http://proceedings.mlr.press/v97/tanno19a/tanno19a.pdf">原文链接</a>和<a target="_blank" rel="noopener" href="https://github.com/rtanno21609/AdaptiveNeuralTrees">原文代码</a>。</p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>​		深层神经网络和决策树在很大程度上依赖于不同的范式；通常，前者使用 预先指定的体系结构进行表征学习，而后者通过使用数据驱动的体系结构学习预先指定的特征的层次结构来实现。本文通过自适应神经树（ANTs）将这两种方法结合起来，该算法将表征学习融入决策树的<strong>边缘</strong>（edges）、<strong>路由函数</strong>（routing functions）和<strong>叶节点</strong>（leaf nodes），以及基于反向传播的训练算法，该算法从原始模块（例如卷积层）自适应地增长体系结构。本文证明，ANTs不仅在实现分类和再分类数据集上具有竞争性能，而且具备如下好处：</p>
<p>（i）通过条件计算进行轻量级推理；</p>
<p>（ii）对任务有用的特征进行更高层次的分离，例如学习有意义的类关联，如分离自然和人造对象；</p>
<p>（iii）使体系结构适应训练数据集大小和复杂性的机制。</p>
<h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><p>​		神经网络（NNs）和决策树（DTs）都是强大的机器学习模型，在学术和商业应用中都取得了成功。然而，这两种方法通常具有相互排斥的优点和局限性。</p>
<table>
<thead>
<tr>
<th><strong>模型</strong></th>
<th><strong>优点</strong></th>
<th><strong>局限性</strong></th>
<th><strong>常见改进思路</strong></th>
</tr>
</thead>
<tbody><tr>
<td>神经网络（NN）</td>
<td>自动学习数据的分层表示，减少了对数据特征工程的需求；使用随机优化法进行训练，可以扩展到大型数据集；在现代硬件加持下可以在众多问题中取得前所未有的精度。</td>
<td>体系结构通常需要针对特定任务或数据集进行设计或修改；大型模型具备重量级推理，计算量很大</td>
<td>知识蒸馏、迁移学习</td>
</tr>
<tr>
<td>决策树（DT）</td>
<td>自动学习分层数据集群和如何分割输入空间，具备高度可解释性；体系结构可以根据训练数据进行优化；轻量级推理</td>
<td>需要手动设计好的数据特征，路径函数表达能力不如神经网络，无法直接使用神经网络的优化方法，</td>
<td>增加决策树数量的方法，如随机森林等</td>
</tr>
</tbody></table>
<p>​		该文的工作的目标是结合NNs和DTs，以获得这两种方法的互补优势。</p>
<p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;ANT的改进.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/ANT%E7%9A%84%E6%94%B9%E8%BF%9B.png"></p>
<p>​		根据该文介绍，ANTs从DTs和NNs继承了以下理想特性：</p>
<p>​	（1）表征学习：由于ANTs的每个根到叶路径都是一个神经网络，因此可通过基于梯度的优化进行端到端的特征学习。</p>
<p>​	（2）架构学习：通过逐渐增长的ANTs，架构适应数据集的可用性和复杂性，增长过程可以看作是对模型类具有硬约束的体系结构搜索。</p>
<p>​	（3）轻量级推理：在推理时，ANTs进行条件计算，在每个样本的基础上选择树上的单个根到叶路径，只激活模型参数的一个子集。</p>
<p>​		该文通过基于如下三个数据集的实验验证了ANTs在回归任务和分类任务的高性能表现：</p>
<table>
<thead>
<tr>
<th><strong>数据集</strong></th>
<th><strong>作者年份</strong></th>
<th><strong>论文题目</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MNIST分类数据集</td>
<td>LeCun等人，1998年</td>
<td>《Gradient-based learning applied to document recognition》</td>
</tr>
<tr>
<td>CIFAR-10分类数据集</td>
<td>Krizhevsky和Hinton，2009年</td>
<td>《Learning multiple layers of features from tiny images》</td>
</tr>
<tr>
<td>SARCOS多元回归数据集</td>
<td>Vijayakumar和Schaal，2000年</td>
<td>《Locally weighted projection regression: An o(n) algorithm for incremental real time learning in high dimensional space》</td>
</tr>
</tbody></table>
<p>​		实验结果显示，在SARCOS多元回归数据集上性能最好的方法都是基于树的，ANTs的在均方误差（MSE）指标上最小；ANT在图像分类方面远远优于最先进的深度随机森林RF（Zhou&amp;Feng，2017）和GBT（Ponomareva等人，2017）方法，其结构在MNIST上的准确率超过99%，在CIFAR-10上的准确率超过90%。</p>
<h1 id="2、相关工作"><a href="#2、相关工作" class="headerlink" title="2、相关工作"></a>2、相关工作</h1><p>​		决策树是机器学习中的一种预测模型，常应用于数据挖掘中。模糊决策树是传统决策树的一个扩充和完善，使决策树可以处理不确定性。</p>
<p>软决策树是模糊决策树中的一类，通过结合树的生长和修剪来确定软决策树的结构，并对树进行了修正来提高它的泛化能力。软决策树的决策准则是一个范围区间，而非一个特定的数值。相比较于标准决策树，软决策树的分类结果更准确。</p>
<p>​		决策树和神经网络结合的相关工作：</p>
<table>
<thead>
<tr>
<th><strong>作者年份</strong></th>
<th><strong>论文题目</strong></th>
<th><strong>主要贡献</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Jordan和Jacobs，1994</td>
<td>Hierarchical mixtures of experts and the em algorithm</td>
<td>提出了一种树结构的监督学习体系结构：分层混合专家（HME），其模型的学习被视为一个最大似然问题，然后使用一种期望最大化（EM）算法来调整结构的参数。该模型中树的分割不是硬决策（hard decision），而是由软概率（soft probabilistic）决定的，但是其树结构是固定的，路由器是简单的线性分类器。</td>
</tr>
<tr>
<td>Suarez和Lutsko ,1999</td>
<td>Globally optimal fuzzy decision  trees for classification and regression</td>
<td>提出了一种新颖的模糊决策树，其通过在CART决策树的骨架上叠加模糊结构将决策树转换为一种强大的函数逼近，并可以使用一种自动生成方法来处理分类和回归问题。</td>
</tr>
<tr>
<td>Irsoy等人，2012</td>
<td>Soft decision trees</td>
<td>提出了一种新的决策树结构，其既具备HME的软决策，又可以在需要时添加新节点，并使用梯度下降学习参数。</td>
</tr>
<tr>
<td>Irsoy等人，2014</td>
<td>Budding trees</td>
<td>提出了一种萌芽树BT，其中一个节点既可以是叶子，也可以是内部决策节点。每个花蕾节点从一个叶节点开始，然后可以生长子节点，但随后，如果必要，可以修剪其子节点。</td>
</tr>
<tr>
<td>Laptev和Buhmann, 2014.</td>
<td>Convolutional decision trees for feature learning and segmentation</td>
<td>提出了一种通用的分割算法ConvDT，在构建多元决策树的同时，将信息量最大、可解释性最强的特征提取为卷积核。该算法的训练速度比常规CNN快几个数量级，并在基准数据集的处理质量方面达到了最先进的水平。</td>
</tr>
<tr>
<td>Rota Bulo和Kontschieder, 2014</td>
<td>Neural decision forests for semantic image labelling</td>
<td>提出了神经决策森林NDT，用于分割语义图像；该文章通过引入随机多层感知器（rMLP）作为新的分割节点来弥补这一差距，该节点可以学习非线性、数据特定的表示，并通过为新出现的子节点找到最佳预测来利用它们。</td>
</tr>
<tr>
<td>Kontschieder等人，2015</td>
<td>Deep neural decision forests</td>
<td>提出了一种新的深度决策森林NDF，通过端到端的方式对分类树进行训练，将分类树与深度卷积网络中已知的表示学习功能统一起来。</td>
</tr>
<tr>
<td>Leon和Denoyer, 2016</td>
<td>Policy-gradient methods for decision trees.</td>
<td>提出了一种新的强化决策树（RDT），主要思想是将分类问题视为一个序贯决策过程，通过直接求解全局（可导）目标函数，而不使用基于启发式的贪婪技术来学习分类策略；</td>
</tr>
<tr>
<td>Ioannou等人，2016</td>
<td>Decision forests, convolutional networks and the models</td>
<td>将决策森林和卷积神经网络结合在一起，提出了条件网络（CNet）。</td>
</tr>
<tr>
<td>Frosst和Hinton，2017</td>
<td>Distilling a neural network into a soft decision tree</td>
<td>使用软决策树来从一个训练好的神经网络中提取知识，从而尝试解释神经网络的分类决策，其结果证明，这种软决策树比直接从训练数据中学习的软决策树具有更好的泛化能力。</td>
</tr>
<tr>
<td>Xiao ,2017</td>
<td>Neual decision tree towards fully functioned neural graph</td>
<td>提出了一种神经决策树的变体NDT，其在反向传播过程中，可以近似地计算出特定条件变量的梯度，从而生成一个功能完备的神经网络图。</td>
</tr>
</tbody></table>
<h1 id="3、自适应神经树"><a href="#3、自适应神经树" class="headerlink" title="3、自适应神经树"></a>3、自适应神经树</h1><p>​		ANT使用了自己的一套术语来定义其结构，其结构基本统一了许多现有的树结构模型。</p>
<p>​		首先ANT的学习仍然是一种监督学习，其训练数据简记为一组N个标记过的样本：$\left(\mathbf{x}^{(1)}, \mathbf{y}^{(1)}\right), \ldots,\left(\mathbf{x}^{(N)}, \mathbf{y}^{(N)}\right) \in \mathcal{X} \times \mathcal{Y}$，ANT的目标是从中学习一个条件分布 $p(\mathbf{y} \mid \mathbf{x})$。</p>
<p>​		该文将ANT定义为一个二元组 $(\mathbb{T}, \mathbb{O})$,其中$\mathbb{T}$表示模型的拓扑结构（本质是一个有限图结构），$\mathbb{O}$表示其拓扑结构上进行的操作集（本质是一系列非线性函数）。</p>
<h2 id="（1）拓扑结构-mathbb-T"><a href="#（1）拓扑结构-mathbb-T" class="headerlink" title="（1）拓扑结构$\mathbb{T}$"></a>（1）拓扑结构$\mathbb{T}$</h2><p>拓扑结构$\mathbb{T}$定义为$\mathbb{T}:&#x3D;{\mathcal{N}, \mathcal{E}}$，其中$\mathcal{N} $是所有节点的集合，$\mathcal{E}$是所有节点边的集合，</p>
<p>ANT的拓扑结构也是基于二叉树的图结构，除了顶部根节点外，每个节点都是一个父节点的子节点。</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>符号表示</th>
<th>定义和其他标准树对比</th>
</tr>
</thead>
<tbody><tr>
<td>内部节点</td>
<td>$j\in \mathcal{N}_{\text {int }}$</td>
<td>基本相同，每个内部节点$j\in \mathcal{N}_{\text {int }}$正好有两个子节点，由$\operatorname{left}(j)$和$\operatorname{right}(j)$表示。</td>
</tr>
<tr>
<td>叶子节点</td>
<td>$l \in \mathcal{N}_{\text {leaf }}$</td>
<td>基本相同，没有子节点的节点叫做叶节点$\mathcal{N}_{\text {leaf }}$</td>
</tr>
<tr>
<td>边</td>
<td>$e \in \mathcal{E}$</td>
<td>略有不同，$\mathcal{E}$包含输入数据$\mathbf{x}$到根节点的边。</td>
</tr>
</tbody></table>
<h2 id="（2）操作集-mathbb-O"><a href="#（2）操作集-mathbb-O" class="headerlink" title="（2）操作集$\mathbb{O}$"></a>（2）操作集$\mathbb{O}$</h2><p>操作集$\mathbb{O}$定义为一个三元组$\mathbb{O}&#x3D;(\mathcal{R}, \mathcal{T}, \mathcal{S})$，其所有操作都由三个可微模块构建：</p>
<table>
<thead>
<tr>
<th>可微模块</th>
<th>模块特点</th>
<th>内部计算</th>
</tr>
</thead>
<tbody><tr>
<td>路由器（Routers，$\mathcal{R}$）</td>
<td>每个内部节点$j\in \mathcal{N}_{\text {int }}$对应一个路由器模块，其负责将来自传入边的样本发送到左子节点或右子节点。</td>
<td>$r_{j}^{\theta}: \mathcal{X}<em>{j} \rightarrow[0,1] \in \mathcal{R} $、 由$\theta$参数化，其中$\mathcal{X}</em>{j}$表示节点j处的输入，对于每个$\mathbf{x}<em>{j} \in \mathcal{X}</em>{j}$，输入$r_{j}^{\boldsymbol{\theta}}$（可以是一个小的CNN），得到输出值$r_{j}^{\boldsymbol{\theta}}\left(\mathbf{x}<em>{j}\right)$求若干个$r</em>{j}^{\boldsymbol{\theta}}\left(\mathbf{x}_{j}\right)$的均值，然后构建一个伯努利分布，从分步中采样一个一个0或1的决策（左分支为1，右分支为0）</td>
</tr>
<tr>
<td>转换器（Transformers，$\mathcal{T}$）</td>
<td>每条边$e \in \mathcal{E}$对应一或多个转换器模块,每个转换器负责将前一个模块的样本转换为下一个模块的样本。</td>
<td>每个转换器$t_{e}^{\psi} \in \mathcal{T}$是一个非线性函数，由$\psi$参数化。其形式可以是一个卷积层和ReLU。和标准的决策树不同，其每条边允许通过添加更多转换器来“增长”。</td>
</tr>
<tr>
<td>求解器（Solvers，$\mathcal{S}$）</td>
<td>每个叶节点$l \in \mathcal{N}_{\text {leaf }}$对应一个求解器模块，其负责将输入数据转换为一个条件分布$p(\mathbf{y} \mid \mathbf{x})$的近似值。</td>
<td>$s_{l}^{\phi}: \mathcal{X}<em>{l} \rightarrow \mathcal{Y} \in \mathcal{S}$、 参数化为$\phi$，对于分类任务，$s^{\phi}$可以定义为特征空间$\mathcal{X}</em>{l}$上的线性分类器，该分类器输出类的分布。</td>
</tr>
</tbody></table>
<p>整个ANT树的结构由下图所示：</p>
<p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;ANT树的结构.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/ANT%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84.png"></p>
<p>在上图中，黑色圆圈表示边上的转换器，白色圆圈表示内部节点上的路由器，灰色圆圈表示叶子节点上的求解器。</p>
<p>以红色阴影路径为例，其计算如下</p>
<p>输入$\mathbf{x}$经历一系列转换器和路由器之后：$\mathbf{x} \rightarrow \mathbf{x}<em>{0}^{\psi}:&#x3D;   t</em>{0}^{\psi}(\mathbf{x}) \rightarrow \mathbf{x}<em>{1}^{\psi}:&#x3D;t</em>{1}^{\psi}\left(\mathbf{x}<em>{0}^{\psi}\right) \rightarrow \mathbf{x}</em>{4}^{\psi}:&#x3D;t_{4}^{\psi}\left(\mathbf{x}_{1}^{\psi}\right) $，</p>
<p>经过求解器模块产生预测分布：$p_{4}^{\phi, \dot{\psi}}(\mathbf{y}):&#x3D;s_{4}^{\phi}\left(\mathbf{x}_{4}^{\psi}\right)$。</p>
<p>选择这条路径的概率：$\pi_{2}^{\psi, \theta}(\mathbf{x}):&#x3D;   r_{0}^{\boldsymbol{\theta}}\left(\mathbf{x}<em>{0}^{\boldsymbol{\psi}}\right) \cdot\left(1-r</em>{1}^{\boldsymbol{\theta}}\left(\mathbf{x}_{1}^{\boldsymbol{\psi}}\right)\right)$。</p>
<h2 id="（3）概率模型"><a href="#（3）概率模型" class="headerlink" title="（3）概率模型"></a>（3）概率模型</h2><p>假设我们有L个叶节点，参数$ \Theta&#x3D;(\boldsymbol{\theta}, \boldsymbol{\psi}, \boldsymbol{\phi})$，其中$\boldsymbol{\theta}, \boldsymbol{\psi}, \boldsymbol{\phi}$分别表示树中路由器、转换器和解算器模块的参数，则完整的概率分布预测计算由叶子分配概率$\pi_{l}^{\theta, \psi} $和叶子预测概率$p_{l}^{\phi, \psi}$组成：</p>
<p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;全预测分布公式.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/%E5%85%A8%E9%A2%84%E6%B5%8B%E5%88%86%E5%B8%83%E5%85%AC%E5%BC%8F.png"></p>
<p>其中$\mathbf{z} \in{0,1}^{L}$是一个L维的二元潜在变量，并且满足$\sum_{l&#x3D;1}^{L} z_{l}&#x3D;1$，其用来描述叶节点的选择（例如，$z_{l}&#x3D;1$表示使用叶节点L）。</p>
<h3 id="A-叶子分配概率-pi-l-theta-psi-的计算"><a href="#A-叶子分配概率-pi-l-theta-psi-的计算" class="headerlink" title="A  叶子分配概率$\pi_{l}^{\theta, \psi} $的计算"></a>A  叶子分配概率$\pi_{l}^{\theta, \psi} $的计算</h3><p>$\pi_{l}^{\theta, \psi}(\mathbf{x}):&#x3D;p\left(z_{l}&#x3D;1 \mid \mathbf{x}, \boldsymbol{\psi}, \boldsymbol{\theta}\right)$量化了x被分配给叶l的概率，其由从根节点到叶节点$l$的唯一路径$P_{1}$上所有路由器模块的决策概率的乘积给出：</p>
<p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;某条路径的概率.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/%E6%9F%90%E6%9D%A1%E8%B7%AF%E5%BE%84%E7%9A%84%E6%A6%82%E7%8E%87.png"></p>
<p>其中$l \swarrow j$是表示叶子结点$l$是否在内部节点$j$的左子树中，$\mathbf{x}_{j}^{\psi}$是$\mathbf{x}$在节点$j$下的特征表示。</p>
<p>假设$\mathcal{T}<em>{j}&#x3D;\left{t</em>{e_{1}}^{\psi}, \ldots, t_{e_{n}}^{\psi}\right}$表示从根节点到节点j的路径上的n个转换器模块的有序集，特征向量$\mathbf{x}_{j}^{\psi}$计算如下：</p>
<p>$\mathbf{x}<em>{j}^{\psi}:&#x3D;\left(t</em>{e_{n}}^{\psi} \circ \ldots \circ t_{e_{2}}^{\psi} \circ t_{e_{1}}^{\psi}\right)(\mathbf{x})$</p>
<h3 id="B-叶子预测概率-p-l-phi-psi-的计算"><a href="#B-叶子预测概率-p-l-phi-psi-的计算" class="headerlink" title="B  叶子预测概率$p_{l}^{\phi, \psi}$的计算"></a>B  叶子预测概率$p_{l}^{\phi, \psi}$的计算</h3><p>叶子预测概率$p_{l}^{\phi, \psi}$的计算如下：</p>
<p>$p_{l}^{\phi, \boldsymbol{\psi}}(\mathbf{y}):&#x3D;p\left(\mathbf{y} \mid \mathbf{x}, z_{l}&#x3D;1, \boldsymbol{\phi}, \boldsymbol{\psi}\right)$</p>
<p>其预测了一个叶子节点l上的求解器$s_{l}^{\phi}\left(\mathbf{x}_{\text {parent }(l)}^{\psi}\right) $在目标$\mathbf{y}$上的近似值</p>
<h2 id="（4）推理方案"><a href="#（4）推理方案" class="headerlink" title="（4）推理方案"></a>（4）推理方案</h2><p>该文在准确率和计算力的权衡上考虑了两个推理方案，分别是多路径推理和和单路径推理。</p>
<table>
<thead>
<tr>
<th>推理方案</th>
<th>预测分布的计算方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>多路径推理</td>
<td>使用完整地概率预测分布，其需要平均所有叶节点上的分布，包括计算树的所有节点和边上的所有操作，</td>
<td>对于大型ANT来说是必要的</td>
</tr>
<tr>
<td>单路径推理</td>
<td>使用其中一条特殊路径的预测分布，该特殊路径通过贪婪地在路由器的最高置信度方向遍历树的决策而得到</td>
<td>将计算限制在一条路径上，从而实现更节省内存和时间的推理</td>
</tr>
</tbody></table>
<h1 id="4、优化"><a href="#4、优化" class="headerlink" title="4、优化"></a>4、优化</h1><p>ANT的训练分两个阶段进行：</p>
<p>1）生长阶段，局部优化学习模型架构；</p>
<p>2）细化阶段，全局优化调整模型参数。</p>
<p>其损失函数使用负对数似然（NLL）：</p>
<p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;ANT的损失函数.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/ANT%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png"></p>
<p>由于ANT的所有组件模块都是可微的，所以该方法可以使用基于梯度的优化。</p>
<h2 id="（1）生长阶段"><a href="#（1）生长阶段" class="headerlink" title="（1）生长阶段"></a>（1）生长阶段</h2><p>生长阶段的目的是局部优化模型的结构。</p>
<p>其方法是首先按广度优先顺序选择一个叶节点，对于选择的每个叶节点都可以使用如下3类评估：</p>
<p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;ANT的生长阶段.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/ANT%E7%9A%84%E7%94%9F%E9%95%BF%E9%98%B6%E6%AE%B5.png"></p>
<p>固定计算图的前一部分，局部优化新添加的（1）和（2）操作，然后计算各自损失值，如果损失值得到减少，则选择该类型的操作否则保留原来的模型。</p>
<h2 id="（2）细化阶段"><a href="#（2）细化阶段" class="headerlink" title="（2）细化阶段"></a>（2）细化阶段</h2><p>生长阶段确定了模型的拓扑结构后，然后继续执行全局优化来优化模型的整体参数。</p>
<h1 id="5、实验"><a href="#5、实验" class="headerlink" title="5、实验"></a>5、实验</h1><h2 id="（1）实验设置"><a href="#（1）实验设置" class="headerlink" title="（1）实验设置"></a>（1）实验设置</h2><p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;实验设置.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/%E5%AE%9E%E9%AA%8C%E8%AE%BE%E7%BD%AE.png"></p>
<h2 id="（2）消融实验"><a href="#（2）消融实验" class="headerlink" title="（2）消融实验"></a>（2）消融实验</h2><p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;ANT的消融实验.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/ANT%E7%9A%84%E6%B6%88%E8%9E%8D%E5%AE%9E%E9%AA%8C.png"></p>
<h2 id="（3）SARCOS多元回归实验的性能对比"><a href="#（3）SARCOS多元回归实验的性能对比" class="headerlink" title="（3）SARCOS多元回归实验的性能对比"></a>（3）SARCOS多元回归实验的性能对比</h2><p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;ANT的SARCOS回归实验.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/ANT%E7%9A%84SARCOS%E5%9B%9E%E5%BD%92%E5%AE%9E%E9%AA%8C.png"></p>
<h2 id="（4）MNIST数字分类实验的性能对比"><a href="#（4）MNIST数字分类实验的性能对比" class="headerlink" title="（4）MNIST数字分类实验的性能对比"></a>（4）MNIST数字分类实验的性能对比</h2><p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;ANT的MNIST实验.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/ANT%E7%9A%84MNIST%E5%AE%9E%E9%AA%8C.png"></p>
<h2 id="（5）CIFAR-10图像分类实验的性能对比"><a href="#（5）CIFAR-10图像分类实验的性能对比" class="headerlink" title="（5）CIFAR-10图像分类实验的性能对比"></a>（5）CIFAR-10图像分类实验的性能对比</h2><p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;ANT的CIFAR-10实验.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/ANT%E7%9A%84CIFAR-10%E5%AE%9E%E9%AA%8C.png"></p>
<h2 id="（6）模型的可解释性"><a href="#（6）模型的可解释性" class="headerlink" title="（6）模型的可解释性"></a>（6）模型的可解释性</h2><p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;ANT的可解释性.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/ANT%E7%9A%84%E5%8F%AF%E8%A7%A3%E9%87%8A%E6%80%A7.png"></p>
<h2 id="（7）细化阶段的影响"><a href="#（7）细化阶段的影响" class="headerlink" title="（7）细化阶段的影响"></a>（7）细化阶段的影响</h2><p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;ANT的细化阶段的影响.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/ANT%E7%9A%84%E7%BB%86%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E5%BD%B1%E5%93%8D.png"></p>
<h2 id="（8）自适应模型的复杂性"><a href="#（8）自适应模型的复杂性" class="headerlink" title="（8）自适应模型的复杂性"></a>（8）自适应模型的复杂性</h2><p>![](&#x2F;img-post&#x2F;论文分享&#x2F;2021-10-29-自适应神经树&#x2F;ANT的自适应模型复杂性.png)</p>
<p><img src="/../img-post/%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/2021-10-29-%E8%87%AA%E9%80%82%E5%BA%94%E7%A5%9E%E7%BB%8F%E6%A0%91/ANT%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E6%A8%A1%E5%9E%8B%E5%A4%8D%E6%9D%82%E6%80%A7.png"></p>
<h1 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h1><p>​		本文引入了自适应神经树（ANTs），将决策树（DTs）的体系结构学习、条件计算和层次聚类与深层神经网络（DNN）的层次表示学习和梯度下降优化相结合，结合本文提出的训练算法来渐进式增长和优化ANTs的参数和结构。<br>​       实验证明ANTs在回归（SARCOS数据集）和分类（MNIST和CIFAR10数据集）方面的优势，同时仍然实现了高性能。</p>
<p>​		ANT模型和shortcut connections的结合可能使ANT在图像分类上的性能进一步提升。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2021-10-28-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91c++%E4%B8%AD%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-10-28-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91c++%E4%B8%AD%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">「算法刷题」c++中栈、队列和字符串的基本操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-28 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-28T00:00:00+00:00">2021-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-02 01:00:55" itemprop="dateModified" datetime="2024-02-02T01:00:55+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="c-string的详细用法"><a href="#c-string的详细用法" class="headerlink" title="c++ string的详细用法"></a>c++ string的详细用法</h1><p>string a&#x3D;”123”;</p>
<h2 id="1-在字符串末尾添加一个字符"><a href="#1-在字符串末尾添加一个字符" class="headerlink" title="1.在字符串末尾添加一个字符"></a>1.在字符串末尾添加一个字符</h2><p>a.push_back(‘3’); &#x2F;&#x2F;结果为 a&#x3D;”1233”;</p>
<h2 id="2-在字符串末尾删除一个字符"><a href="#2-在字符串末尾删除一个字符" class="headerlink" title="2.在字符串末尾删除一个字符"></a>2.在字符串末尾删除一个字符</h2><p>a.pop_back(); &#x2F;&#x2F;结果为 a&#x3D;”12”;</p>
<h2 id="3-assign"><a href="#3-assign" class="headerlink" title="3.assign()"></a>3.assign()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//字符串变量</span><br><span class="line">string a=&quot;123&quot;;</span><br><span class="line">string b=&quot;456&quot;;</span><br><span class="line"></span><br><span class="line">1.字符串直接赋值</span><br><span class="line">a.assign(b); //等于a=b赋值，结果为 a=&quot;456&quot;</span><br><span class="line">a.assign(&quot;789&quot;);//结果为 a=&quot;789&quot;</span><br><span class="line"></span><br><span class="line">2.一个字符串的子串赋值给另一个字符串</span><br><span class="line">a.assign(b,begin,len);</span><br><span class="line">//从字符串b的第(begin)个字符开始向后数(len)个字符(包括begin)的字符串赋值给字符串a</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">a.assign(b,0,1); //结果为 a=&quot;4&quot;</span><br><span class="line">a.assign(b,1,1); //结果为 a=&quot;5&quot;</span><br><span class="line">a.assign(b,0,2); //结果为 a=&quot;45&quot;;</span><br><span class="line">a.assign(b,1,2); //结果为 a=&quot;56&quot;;</span><br><span class="line">a.assign(&quot;123456&quot;,1,3); //结果为 a=&quot;234&quot;;</span><br><span class="line">/*说明</span><br><span class="line"> *如果第三个参数大于字符串本身的长度，则赋值到该字符串末尾</span><br><span class="line"> *如：a.assign(b,1,4); 结果为 a=&quot;56&quot;;</span><br><span class="line"> *如果第二个参数大于字符串本身长度则赋值为空</span><br><span class="line"> *如：a.assign(b,3,4); 结果为 a=&quot;&quot;;</span><br><span class="line"> *第二个参数最大不能超过字符串长度加一，否则程序会运行错误。因为string字符串后面会有一个&quot;\n&quot;符号，这个符号虽然不算在字符串长度里面，但是会占一个字符的空间。所以超过字符串长度加一后会出现std::out_of_range的错误。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">3.从字符串的某一个字符串开始到结束赋值给另一个字符串</span><br><span class="line">a.assign(b,begin);</span><br><span class="line">//从字符串b的第begin字符串开始到字符串结束赋值给字符串a</span><br><span class="line"></span><br><span class="line">a.assign(b,0); //结果为 a=&quot;456&quot;;</span><br><span class="line">a.assign(b,1); //结果为 a=&quot;56&quot;;</span><br><span class="line">a.assign(b,4); //error 这样会运行错误（同2） vs2019</span><br><span class="line"></span><br><span class="line">4.从字符串开始到字符串的某一个字符赋值给另一个字符串</span><br><span class="line">a.assign(&quot;123456&quot;,2);//结果为 a=&quot;12&quot;</span><br><span class="line">string c=&quot;123456&quot;;</span><br><span class="line">a.assign(c,2);       //结果为 a=&quot;3456&quot;</span><br><span class="line">//根据vs2019运行情况来看，如过第一个参数是字符串常量则按从头到第n个字符赋值，如果第一个参数是字符串变量的话，则从第n个字符开始到字符串结尾赋值（不知道其他编译会是怎么样的,vs2019是调用不同的重载函数）</span><br><span class="line"></span><br><span class="line">5.用相同的n个字符给字符串赋值</span><br><span class="line">a.assign(10,&#x27;b&#x27;); //结果为 a=&quot;bbbbbbbbbb&quot;;</span><br><span class="line">a.assign(5,&#x27;c&#x27;);  //结果为 a=&quot;ccccc&quot;;</span><br><span class="line"></span><br><span class="line">6.template&lt;class inputIterator&gt; string&amp; assign(inputIterator first,inputIterator last);</span><br><span class="line">//使用这个函数需要引入#include&lt;iterator&gt;头文件 </span><br><span class="line">a.assign(istream_iterator&lt;char&gt;(cin), istream_iterator&lt;char&gt;());</span><br><span class="line">//键盘输入123abcd</span><br><span class="line">//结果为 a=&quot;123abcd&quot;;</span><br><span class="line">/*注意</span><br><span class="line"> *该函数不接收空格换行等符号，最后（windows系统）按ctrl+z结束输入</span><br><span class="line"> *如输入以下符号（既有空格也有换行）</span><br><span class="line"> 123abc    ABC  哈哈 !@#$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> defg)(-=&lt;&gt;-+/*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 123654</span><br><span class="line"> 最后结果为 a=&quot;123abcABC哈哈!@#$defg)(-=&lt;&gt;-+/*123654&quot;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">7.使用迭代器赋值</span><br><span class="line">a.assign(b.begin()+1,b.end()); //结果为 a=&quot;67&quot;;</span><br><span class="line">a.assign(a.begin(),a.end());   //结果为 a=&quot;123&quot;;</span><br><span class="line"></span><br><span class="line">## 4.append()</span><br></pre></td></tr></table></figure>

<h2 id="4-append"><a href="#4-append" class="headerlink" title="4.append()"></a>4.append()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">string a=&quot;1234&quot;;</span><br><span class="line">string b=&quot;5678&quot;;</span><br><span class="line"></span><br><span class="line">1.把两个string字符串相连接</span><br><span class="line">a.append(b); //结果为 a=&quot;12345678&quot;;</span><br><span class="line">a.append(&quot;56789&quot;);//结果 a=&quot;123456789&quot;;</span><br><span class="line"></span><br><span class="line">2.从string字符串b的某一个字符开始到结束连接在string字符串a后面</span><br><span class="line">a.append(b,1);//结果为 a=&quot;1234678&quot;;</span><br><span class="line">a.append(b,0);//结果为 a=&quot;12345678&quot;;</span><br><span class="line">a.append(b,3);//结果为 a=&quot;12348&quot;;</span><br><span class="line">//注意第二个参数不能大于字符串b的长度加一，否则会出错，至于为什么请看我的上一篇assign函数的用法</span><br><span class="line"></span><br><span class="line">3.从字符串b的某一个字符开始到结束连接在string字符串a后面</span><br><span class="line">a.append(&quot;5678&quot;,1);//结果为 a=&quot;12345&quot;;</span><br><span class="line">a.append(&quot;5678&quot;,2);//结果为 a=&quot;123456&quot;;</span><br><span class="line">a.append(&quot;5678&quot;,0);//结果为 a=&quot;1234&quot;;</span><br><span class="line">// 注意2，3的区别</span><br><span class="line"></span><br><span class="line">4.把string的子串连接到另一个string后面</span><br><span class="line">a.append(&quot;5678&quot;,0,1);</span><br><span class="line">a.append(b,0,1); //结果为 a=&quot;12345&quot;;</span><br><span class="line">a,append(&quot;5678&quot;,1,3);</span><br><span class="line">a,append(b,1,3); //结果为 a=&quot;1234678&quot;;</span><br><span class="line"></span><br><span class="line">5.在string字符串后面添加n个字符</span><br><span class="line">a.append(10,&#x27;&gt;&#x27;); //结果为 a=&quot;1234&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;;</span><br><span class="line"></span><br><span class="line">6.template&lt;class inputIterator&gt; string&amp; append(inputIterator first,inputIterator last);</span><br><span class="line">//需要引入头文件#include&lt;iterator&gt;</span><br><span class="line">a.append(istream_iterator&lt;char&gt;(cin),istream_iterator&lt;char&gt;());</span><br><span class="line">//从键盘输入abcd</span><br><span class="line">//结果为 a=&quot;1234abcd&quot;;</span><br><span class="line">/**注意</span><br><span class="line"> *该函数不接收空格换行等符号，最后（windows系统）按ctrl+z结束输入</span><br><span class="line"> *如输入以下符号（既有空格也有换行）</span><br><span class="line">  @#￥%………</span><br><span class="line"></span><br><span class="line">  按时到场  sdf   456</span><br><span class="line"></span><br><span class="line">  asd</span><br><span class="line"> 最后结果为 a=&quot;1234@#￥%……按时到场sdf456asd&quot;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">7.使用迭代器使string字符串相连接</span><br><span class="line">a.append(b.begin()+1,b.end());//结果为 a=&quot;1234678&quot;;</span><br><span class="line">a.append(a.begin(),a.end());  //结果为 a=&quot;12341234&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-at"><a href="#4-at" class="headerlink" title="4.at()"></a>4.at()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">string a=&quot;abcd&quot;;</span><br><span class="line"></span><br><span class="line">1.获取string字符串某一个字符</span><br><span class="line">auto s=a.at(1); //结果为 s=&#x27;b&#x27;;</span><br><span class="line">for (unsigned int i=0;i&lt;a.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; a.at(i) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">/* 结果为</span><br><span class="line"> a</span><br><span class="line"> b</span><br><span class="line"> c</span><br><span class="line"> d</span><br><span class="line"> */ </span><br><span class="line"> //等同于a[i],但是at()会有下标检查，如果超出则抛出out_of_range</span><br><span class="line"></span><br><span class="line">2.修改string字符串某一个字符</span><br><span class="line">a.at(2)=&#x27;1&#x27;; //结果为 a=&quot;ab1d&quot;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-front-与back"><a href="#5-front-与back" class="headerlink" title="5 front()与back()"></a>5 front()与back()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string a=&quot;abcd&quot;;</span><br><span class="line"></span><br><span class="line">1.获取字符串最后一个字符</span><br><span class="line">auto b=a.back(); //结果为 b=&#x27;d&#x27;;</span><br><span class="line"></span><br><span class="line">2.修改字符串最后一个字符</span><br><span class="line">a.back()=&#x27;!&#x27;; //结果为 a=&quot;abc!&quot;;</span><br><span class="line"></span><br><span class="line">3.获取字符串第一个字符</span><br><span class="line">auto b=a.front(); //结果为 b=&#x27;a&#x27;;</span><br><span class="line"></span><br><span class="line">4.修改字符串第一个字符</span><br><span class="line">a.front()=&#x27;!&#x27;; //结果为 a=&quot;!bcd&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-compare"><a href="#6-compare" class="headerlink" title="6.compare()"></a>6.compare()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">string a=&quot;abcd&quot;;</span><br><span class="line">string b=&quot;efgh&quot;;</span><br><span class="line">string c=&quot;1fgh&quot;;</span><br><span class="line">string d=&quot;fgh&quot;;</span><br><span class="line">string e=&quot;123efg&quot;;</span><br><span class="line"></span><br><span class="line">比较两个字符串的ASCII码，&gt;0返回1，&lt;0返回-1，相同，返回0</span><br><span class="line">ASCII码比较是字符串的字符从前往后比较，如果之前的比较完成则后面的字符无需比较</span><br><span class="line"></span><br><span class="line">1.直接比较两个字符串</span><br><span class="line">auto number = a.compare(b); //结果为 number=-1;</span><br><span class="line">auto number = b.compare(a); //结果为 number=1;</span><br><span class="line">auto number = b.compare(b); //结果为 number=0;</span><br><span class="line">auto number = a.compare(c); //结果为 number=1;</span><br><span class="line">auto number = a.compare(&quot;abc&quot;); //结果为 number=1;</span><br><span class="line"></span><br><span class="line">2.一个字符串的子串与另一个字符串比较</span><br><span class="line">auto number = b.compare(1,3,d); //结果为 number=0;</span><br><span class="line">//字符串b从下标为1的字符开始的三个字符与字符串d比较，显然都是fgh,所以相等，返回0</span><br><span class="line">auto number = b.compare(1,3,c); //结果为 number=1;</span><br><span class="line">auto number = b.compare(1,3,&quot;fgh&quot;); //结果为 number=0;</span><br><span class="line"></span><br><span class="line">3.一个字符串的子串与另一个字符串的子串比较</span><br><span class="line">auto number = b.compare(1,3,c,1,3); //结果为 number= 0;</span><br><span class="line">//字符串b从下标为1的地方开始的后3个字符是fgh，字符串c从下标为1的字符开始的后三个字符是fgh,所以相等</span><br><span class="line">auto number = b.compare(0,3,e,3,3); //结果为 number=0;</span><br><span class="line">//字符串b从下标为0的地方开始的后3个字符是efg，字符串e从下标为3的字符开始的后三个字符是efg,所以相等</span><br><span class="line">auto number = b.compare(0,4,&quot;1234efgh&quot;,4,4); //结果为 number=0;</span><br><span class="line">//字符串b从下标为0的地方开始的后四个字符是efgh，字符串&quot;1234efgh&quot;从下标为4的字符开始的后4个字符是efgh,所以相等</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-copy"><a href="#7-copy" class="headerlink" title="7.copy()"></a>7.copy()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">char *str = new char[64];</span><br><span class="line">string a=&quot;12345abcdefg6789&quot;;</span><br><span class="line"></span><br><span class="line">str[a.copy(str,7,5)]=&#x27;\0&#x27;;</span><br><span class="line">// 结果为 str=&quot;abcdefg&quot;;</span><br><span class="line"></span><br><span class="line">str[a.copy(str,7)]=&#x27;\0&#x27;;</span><br><span class="line">// 结果为 str=&quot;12345ab&quot;;</span><br><span class="line"></span><br><span class="line">delete[]str;</span><br><span class="line"></span><br><span class="line">/*注意</span><br><span class="line"> *copy的第2，3个参数不能大于字符串str所能容纳的最长字符串长度</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h2 id="8-data-与c-str-copy-的区别"><a href="#8-data-与c-str-copy-的区别" class="headerlink" title="8.data()与c_str() copy()的区别"></a>8.data()与c_str() copy()的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">string a=&quot;123456&quot;;</span><br><span class="line"></span><br><span class="line">1.c_str(),data()可以生成一个const char* 的指针，可以指向一个空字符终止的地址。</span><br><span class="line"></span><br><span class="line">const char* str=nullptr;</span><br><span class="line">str=a.c_str(); //结果为 str=&quot;123456&quot;;</span><br><span class="line">str=a.data(); //结果为 str=&quot;123456&quot;;</span><br><span class="line"></span><br><span class="line">但是如果改变string a的值,str的值随之改变</span><br><span class="line">a=&quot;abcedf&quot;;</span><br><span class="line">cout&lt;&lt;str&lt;&lt;endl; //结果为 str=&quot;abcdef&quot;;</span><br><span class="line"></span><br><span class="line">2.如果不想让其指针指向的值改变可以使用copy()函数(如果不知道copy()函数如何使用，请看我的上一篇copy()的使用方法)</span><br><span class="line">char* str = new char[64];</span><br><span class="line">str[a.copy(str, a.size(), 0)]=&#x27;\0&#x27;;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl; //结果为 str=&quot;123456&quot;;</span><br><span class="line"></span><br><span class="line">//改变string a的值</span><br><span class="line">a=&quot;abcd&quot;;</span><br><span class="line">cout&lt;&lt; str &lt;&lt;endl; //结果为 str=&quot;123456&quot;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9、erase（）"><a href="#9、erase（）" class="headerlink" title="9、erase（）"></a>9、erase（）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">string a=&quot;123456789&quot;;</span><br><span class="line"></span><br><span class="line">1.删除所有字符</span><br><span class="line">a.erase(); //结果为 a=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">2.从字符串的某一个位置开始删除</span><br><span class="line">a.erase(n) //从字符串的第n个字符开始删除</span><br><span class="line">a.erase(3); //结果为 a=&quot;123&quot;;</span><br><span class="line">a.erase(5); //结果为 a=&quot;12345&quot;;</span><br><span class="line">a.erase(0); //等同于a.erase() a=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">3.从字符串的某一个位置开始，向后删除m个字符</span><br><span class="line">a.erase(n,m); //从字符的第n个字符开始删除m个字符</span><br><span class="line">a.erase(2,3); //结果为 a=&quot;126789&quot;;</span><br><span class="line">a.erase(4,1); //结果为 a=&quot;12346789&quot;;</span><br><span class="line"></span><br><span class="line">4.删除迭代器位置处的字符，并返回下一个字符的迭代器</span><br><span class="line">auot iter=a.erase(a.begin()+1); //结果为 a=&quot;13456789&quot;;</span><br><span class="line">cout&lt;&lt;*iter&lt;&lt;endl; //结果为 *iter=3</span><br><span class="line"></span><br><span class="line">5.删除迭代器所指向的区间,并返回下一个字符的迭代器</span><br><span class="line">auto iter=a.erase(a.begin()+1,a.end()-2);//结果为 a=&quot;189&quot;;</span><br><span class="line">cout&lt;&lt;*iter&lt;,endl; //结果为 *iter=8;</span><br><span class="line"></span><br><span class="line">6.删除字符时常常与find()函数配合使用(find()函数的用法会在以后写出)</span><br><span class="line">a.erase(a.find(&quot;56&quot;),2); //结果为 a=&quot;1234789&quot;;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="c-栈的基本操作："><a href="#c-栈的基本操作：" class="headerlink" title="c++ 栈的基本操作："></a>c++ 栈的基本操作：</h1><p>​    一种可以实现“先进后出（后进先出）”的存储结构</p>
<p>s.empty();         &#x2F;&#x2F;如果栈为空则返回true, 否则返回false;<br>s.size();          &#x2F;&#x2F;返回栈中元素的个数<br>s.top();           &#x2F;&#x2F;返回栈顶元素, 但不删除该元素<br>s.pop();           &#x2F;&#x2F;弹出&#x2F;删除栈顶元素, 但不返回其值<br>s.push();          &#x2F;&#x2F;将元素压入栈顶</p>
<p> 在压栈的过程中，栈顶的位置一直在”向上“移动，而栈底是固定不变的。 </p>
<p><img src="C:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211027221030901.png" alt="image-20211027221030901"></p>
<p> 如果我们要把栈中的元素弹出来： 先入后出</p>
<p><img src="C:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211027221100703.png" alt="image-20211027221100703"></p>
<h1 id="c-queue-的基本操作"><a href="#c-queue-的基本操作" class="headerlink" title="c++ queue 的基本操作"></a>c++ queue 的基本操作</h1><p>入队，如例：q.push(x); 将x 接到队列的末端。<br>出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。<br>访问队首元素，如例：q.front()，即最早被压入队列的元素。<br>访问队尾元素，如例：q.back()，即最后被压入队列的元素。<br>判断队列空，如例：q.empty()，当队列空时，返回true。<br>访问队列中的元素个数，如例：q.size() </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2021-10-27-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91904%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-10-27-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91904%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/" class="post-title-link" itemprop="url">「算法刷题」904水果成篮</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-27 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-27T00:00:00+00:00">2021-10-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-02 01:00:55" itemprop="dateModified" datetime="2024-02-02T01:00:55+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41855420/article/details/92836075">https://blog.csdn.net/qq_41855420/article/details/92836075</a></p>
<table>
<thead>
<tr>
<th>题目</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>904水果成篮</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p> 构造一个虚拟的窗口[left, right)，当窗口tree[left, right)中的水果种数不多于2时，扩大右边界，此时窗口的大小就是可获取的水果种数，否则窗口中的水果种数超过2，则缩小左边界。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> treeSize = tree.<span class="built_in">size</span>(), maxRes = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, fruitOne, fruitTwo;<span class="comment">//窗口的左、右边界，以及窗口中的两种水果</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; treeSize)&#123;</span><br><span class="line">            <span class="type">int</span> tempRes = <span class="number">1</span>;<span class="comment">//窗口的大小</span></span><br><span class="line">            fruitOne = tree[left++];<span class="comment">//第一种水果</span></span><br><span class="line">            <span class="comment">//寻找到第二种水果的第一次出现的位置（并且更新下一次的窗口的left）</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; treeSize &amp;&amp; tree[left] == fruitOne)&#123;</span><br><span class="line">                ++left;</span><br><span class="line">                tempRes += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right = left;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; treeSize)&#123;<span class="comment">//第二种水果</span></span><br><span class="line">                fruitTwo = tree[right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当窗口tree[left, right)中的水果种数不多于2时，扩大右边界</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; treeSize)&#123;</span><br><span class="line">                <span class="keyword">if</span> (tree[right] == fruitOne || tree[right] == fruitTwo)&#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                    tempRes += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxRes = <span class="built_in">max</span>(maxRes, tempRes);<span class="comment">//更新最大的水果数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxRes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2021-10-28-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-10-28-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">「算法刷题」栈和队列的相关经典题目</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-27 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-27T00:00:00+00:00">2021-10-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-02 01:00:55" itemprop="dateModified" datetime="2024-02-02T01:00:55+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>232</td>
<td>用栈实现队列（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>在push数据的时候，只要数据放进输入栈就好，<strong>但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从输出栈弹出数据就可以了。</p>
<p>最后如何判断队列为空呢？<strong>如果进栈和出栈都为空的话，说明模拟的队列为空了。</strong></p>
<p>在代码实现的时候，会发现pop() 和 peek()两个函数功能类似，代码实现上也是类似的，可以思考一下如何把代码抽象一下。</p>
<p>输入栈的元素出栈再放到输出栈中，这样输出栈的输出顺序和队列顺序一样了（手画一下）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;sck1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;sck2;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        sck1.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把输入栈sck1中的元素放到输出栈sck2，清空sck1</span></span><br><span class="line">        <span class="comment">// 这样stk2的出栈顺序和输入的元素入stk1的顺序是一样的了</span></span><br><span class="line">        <span class="keyword">while</span>(!sck1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> num=sck1.<span class="built_in">top</span>();<span class="comment">// 获取栈顶元素，但不删除</span></span><br><span class="line">            sck1.<span class="built_in">pop</span>();<span class="comment">// 删除栈顶元素，但不返回</span></span><br><span class="line">            sck2.<span class="built_in">push</span>(num); <span class="comment">// 将元素压入栈顶</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val=sck2.<span class="built_in">top</span>();<span class="comment">// 返回栈顶元素</span></span><br><span class="line">        sck2.<span class="built_in">pop</span>();<span class="comment">// 删除栈顶元素</span></span><br><span class="line">        <span class="comment">// 清空输出栈sck2</span></span><br><span class="line">        <span class="keyword">while</span>(!sck2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            sck1.<span class="built_in">push</span>(sck2.<span class="built_in">top</span>());</span><br><span class="line">            sck2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回队列开头的元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 清空sck1，元素放入到sck2</span></span><br><span class="line">        <span class="keyword">while</span>(!sck1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            sck2.<span class="built_in">push</span>(sck1.<span class="built_in">top</span>());</span><br><span class="line">            sck1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到“队列”开头的元素</span></span><br><span class="line">        <span class="type">int</span> val=sck2.<span class="built_in">top</span>();</span><br><span class="line">        <span class="comment">// 清空sck2，元素放入到sck1</span></span><br><span class="line">        <span class="keyword">while</span>(!sck2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            sck1.<span class="built_in">push</span>(sck2.<span class="built_in">top</span>());</span><br><span class="line">            sck2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sck1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h1 id=""><a href="#" class="headerlink" title=""></a></h1><table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th>关键点</th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>225</td>
<td>用队列实现栈（简单难度）</td>
<td></td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;int&gt; que1;</span><br><span class="line">    queue&lt;int&gt; que2; // 辅助队列，用来备份</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 将元素 x 压入栈顶。 */</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        que1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 移除并返回栈顶元素。 */</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        int size=que1.size();</span><br><span class="line">        size--;</span><br><span class="line">        // 把que1元素放到que2，但保留最后一个</span><br><span class="line">        while(size--)&#123;</span><br><span class="line">            int num=que1.front();</span><br><span class="line">            que1.pop();</span><br><span class="line">            que2.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        int res=que1.front();</span><br><span class="line">        que1.pop();</span><br><span class="line">        que1=que2;</span><br><span class="line">        // 清空que2</span><br><span class="line">        while(!que2.empty())&#123;</span><br><span class="line">            que2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 返回栈顶元素。 */</span><br><span class="line">    int top() &#123;</span><br><span class="line">        return que1.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 如果栈是空的，返回 true ；否则，返回 false */</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return que1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyStack object will be instantiated and called as such:</span><br><span class="line"> * MyStack* obj = new MyStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th>关键点</th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>20</td>
<td>有效的括号（简单难度）</td>
<td></td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>括号匹配是使用栈解决的经典问题。</p>
<p>由于栈结构的特殊性，非常适合做对称匹配类的题目。</p>
<p>首先要弄清楚，字符串里的括号不匹配有几种情况。</p>
<p>先来分析一下 这里有三种不匹配的情况，</p>
<ol>
<li><p>第一种情况，字符串里左方向的括号多余了 ，所以不匹配。</p>
<p><img src="C:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211028151300438.png" alt="image-20211028151300438"></p>
<p>第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false</p>
</li>
</ol>
<p>2.第二种情况，括号没有多余，但是 括号的类型没有匹配上。</p>
<p><img src="C:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211028151315983.png" alt="image-20211028151315983"></p>
<p>​       第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false</p>
<p>3.第三种情况，字符串里右方向的括号多余了，所以不匹配。</p>
<p><img src="C:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211028151337388.png" alt="image-20211028151337388"></p>
<p>​       第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找   到对应的左括号return false</p>
<p>我们的代码只要覆盖了这三种不匹配的情况，就不会出问题，可以看出 动手之前分析好题目的重要性。</p>
<p>那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。</p>
<p>但还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 左括号入栈，保存对应的右括号，这样右括号来的时候，直接对比是否相等就行</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右括号出现</span></span><br><span class="line">            <span class="comment">// 右括号多余s.empty()</span></span><br><span class="line">            <span class="comment">// 左右不匹配</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st.<span class="built_in">empty</span>()||s[i]!=st.<span class="built_in">top</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();<span class="comment">//左右括号匹配，</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左括号多余，则s.empty()==false;</span></span><br><span class="line">        <span class="comment">//都匹配，就是true</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th>关键点</th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1047</td>
<td>删除字符串中的所有相邻重复项（简单难度）</td>
<td></td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>题目中有字符串的基本操作：</p>
<p>s.back();返回字符串最后一个元素</p>
<p>s.push_back(a);字符串末尾添加一个元素</p>
<p>s.pop_back();删除字符串末尾的元素</p>
<p>本题要删除相邻相同元素，其实也是匹配问题，相同左元素相当于左括号，相同右元素就是相当于右括号，匹配上了就删除。</p>
<p>那么再来看一下本题：可以把字符串顺序放到一个栈中，然后如果相同的话 栈就弹出，这样最后栈里剩下的元素都是相邻不相同的元素了。</p>
<p>拿字符串直接作为栈，这样省去了栈还要转为字符串的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string removeDuplicates(string S) &#123;</span><br><span class="line">        string res;</span><br><span class="line">        for(char s:S)&#123;</span><br><span class="line">            if(res.empty()||res.back()!=s)&#123;</span><br><span class="line">                res.push_back(s);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                res.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th>关键点</th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>150</td>
<td>逆波兰表达式求值（中等难度）</td>
<td></td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/submissions/">150. 逆波兰表达式求值 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>1、理解逆波兰表达式的求值方式</p>
<p>2、解题思路</p>
<p>遍历数组：</p>
<p>如果是运算符，弹出栈的两个栈顶元素num1，num2，进行相应运算，把结果放到栈中</p>
<p>如果是数字，把数字放到栈中</p>
<p>遍历结束：结果为栈中唯一的元素，返回结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        for(int i=0;i&lt;tokens.size();i++)&#123;</span><br><span class="line">            if(tokens[i]==&quot;+&quot;||tokens[i]==&quot;-&quot;||tokens[i]==&quot;*&quot;||tokens[i]==&quot;/&quot;)&#123;</span><br><span class="line">                int nums1=st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                int nums2=st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                if(tokens[i]==&quot;+&quot;)st.push(nums2+nums1);</span><br><span class="line">                if(tokens[i]==&quot;-&quot;)st.push(nums2-nums1);</span><br><span class="line">                if(tokens[i]==&quot;*&quot;)st.push(nums2*nums1);</span><br><span class="line">                if(tokens[i]==&quot;/&quot;)st.push(nums2/nums1);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                st.push(stoi(tokens[i]));//stoi()将字符串转为int型</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res=st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2021-10-26-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91KMP%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-10-26-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91KMP%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">「算法刷题」KMP相关题目</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-26 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-26T00:00:00+00:00">2021-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-02 01:00:55" itemprop="dateModified" datetime="2024-02-02T01:00:55+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>t替换空格（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></td>
</tr>
</tbody></table>
<p>题解链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/</a><br>来源：力扣（LeetCode）</p>
<p><strong>题解上有视频</strong></p>
<p>1、初始化：空格数量 count ，字符串 s 的长度 len ；</p>
<p>2、统计空格数量：遍历 s ，遇空格则 count++ ；<br>3、修改 s 长度：添加完 “%20” 后的字符串长度应为 len + 2 * count ；</p>
<p>4、倒序遍历修改：i 指向原字符串尾部元素， j 指向新字符串尾部元素；当 i &#x3D; j 时跳出（代表左方已没有空格，无需继续遍历）；<br>当 s[i] 不为空格时：执行 s[j] &#x3D; s[i] ；<br>当 s[i] 为空格时：将字符串闭区间 [j-2, j] 的元素修改为 “%20” ；由于修改了 3 个元素，因此需要 j -&#x3D; 2 ；<br>5、返回值：已修改的字符串 s ；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 统计空格数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改 s 长度</span></span><br><span class="line">        s.<span class="built_in">resize</span>(len + <span class="number">2</span> * count);<span class="comment">//多加两个空格数，因为字符串本身有一个，再加两个（才能放下%20）</span></span><br><span class="line">        <span class="comment">// 倒序遍历修改</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                s[j] = s[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s[j - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                s[j - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                j -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>剑指offer左旋转字符串（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string str1;</span><br><span class="line">        str1 =s.<span class="built_in">substr</span>(<span class="number">0</span>,n);</span><br><span class="line">        s.<span class="built_in">erase</span>(<span class="number">0</span>,n);<span class="comment">//即从给定起始位置0处开始删除, 要删除字符的长度为n, 返回值修改后的string对象引用</span></span><br><span class="line">        <span class="keyword">return</span> s+str1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            str+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            str+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2021-10-26-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-10-26-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE1/" class="post-title-link" itemprop="url">「算法刷题」字符串相关题目1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-26 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-26T00:00:00+00:00">2021-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-02 01:00:55" itemprop="dateModified" datetime="2024-02-02T01:00:55+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>t替换空格（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></td>
</tr>
</tbody></table>
<p>题解链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/</a><br>来源：力扣（LeetCode）</p>
<p><strong>题解上有视频</strong></p>
<p>1、初始化：空格数量 count ，字符串 s 的长度 len ；</p>
<p>2、统计空格数量：遍历 s ，遇空格则 count++ ；<br>3、修改 s 长度：添加完 “%20” 后的字符串长度应为 len + 2 * count ；</p>
<p>4、倒序遍历修改：i 指向原字符串尾部元素， j 指向新字符串尾部元素；当 i &#x3D; j 时跳出（代表左方已没有空格，无需继续遍历）；<br>当 s[i] 不为空格时：执行 s[j] &#x3D; s[i] ；<br>当 s[i] 为空格时：将字符串闭区间 [j-2, j] 的元素修改为 “%20” ；由于修改了 3 个元素，因此需要 j -&#x3D; 2 ；<br>5、返回值：已修改的字符串 s ；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 统计空格数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改 s 长度</span></span><br><span class="line">        s.<span class="built_in">resize</span>(len + <span class="number">2</span> * count);<span class="comment">//多加两个空格数，因为字符串本身有一个，再加两个（才能放下%20）</span></span><br><span class="line">        <span class="comment">// 倒序遍历修改</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                s[j] = s[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s[j - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                s[j - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                j -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>剑指offer左旋转字符串（简单难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string str1;</span><br><span class="line">        str1 =s.<span class="built_in">substr</span>(<span class="number">0</span>,n);</span><br><span class="line">        s.<span class="built_in">erase</span>(<span class="number">0</span>,n);<span class="comment">//即从给定起始位置0处开始删除, 要删除字符的长度为n, 返回值修改后的string对象引用</span></span><br><span class="line">        <span class="keyword">return</span> s+str1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            str+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            str+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>151</td>
<td>反转字符串里的单词（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 翻转字符串里的单词 - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 反转字符串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string &amp;s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=start;</span><br><span class="line">        <span class="type">int</span> j=end;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;j;i++,j--)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除冗余空格</span></span><br><span class="line">    <span class="comment">// 考虑字符串s前中后空格的位置和fast的大小是否符合循环要求</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraStr</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> fast=<span class="number">0</span>,slow=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//移除字符串前面多余的空格</span></span><br><span class="line">        <span class="keyword">while</span>(s[fast]==<span class="string">&#x27; &#x27;</span><span class="comment">//表示字符串前有空格</span></span><br><span class="line">        &amp;&amp;s.<span class="built_in">size</span>()&gt;<span class="number">0</span><span class="comment">//字符串s不为空</span></span><br><span class="line">        &amp;&amp;fast&lt;s.<span class="built_in">size</span>())<span class="comment">//fast不能指到s外</span></span><br><span class="line">        &#123;</span><br><span class="line">            fast++;<span class="comment">//结束循环后，fast指向第一个不是空格的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除字符串中间多余的空格</span></span><br><span class="line">        <span class="keyword">for</span>(;fast&lt;s.<span class="built_in">size</span>();fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast<span class="number">-1</span>&gt;<span class="number">0</span>&amp;&amp;</span><br><span class="line">            s[fast]==<span class="string">&#x27; &#x27;</span>&amp;&amp;</span><br><span class="line">            s[fast<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//连续两个空格不做操作</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//直到fast指向一个字符，前一个是空格，把fast指向的字符赋值给slow指向的位置</span></span><br><span class="line">                s[slow]=s[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除字符串后面多余的空格</span></span><br><span class="line">        <span class="keyword">if</span>(s[slow<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//fast指向空格，fast-1指向字符，这时候也执行了s[slow]=s[fast];所以多加了一个空格，如果指向反转字符串的操作，该空格在最前面</span></span><br><span class="line">            s.<span class="built_in">resize</span>(slow<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s.<span class="built_in">resize</span>(slow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 移除多余空格</span></span><br><span class="line">        <span class="built_in">removeExtraStr</span>(s);</span><br><span class="line">        <span class="comment">// 反转字符串</span></span><br><span class="line">        <span class="built_in">reverse</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//反转单个单词</span></span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>&amp;&amp;s[i<span class="number">-1</span>]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,start,i<span class="number">-1</span>);</span><br><span class="line">                start=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最后一个单词后没有空格的情况</span></span><br><span class="line">            <span class="keyword">if</span>((i == (s.<span class="built_in">size</span>() - <span class="number">1</span>) )&amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,start,i);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2021-10-26-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-10-26-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/" class="post-title-link" itemprop="url">「算法刷题」螺旋矩阵</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-26 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-26T00:00:00+00:00">2021-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-02 01:00:55" itemprop="dateModified" datetime="2024-02-02T01:00:55+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、螺旋矩阵"><a href="#一、螺旋矩阵" class="headerlink" title="一、螺旋矩阵"></a>一、螺旋矩阵</h1><table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>54</td>
<td>螺旋矩阵（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-linked-list/">https://leetcode-cn.com/problems/design-linked-list/</a></td>
</tr>
</tbody></table>
<p>题解链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix/solution/cxiang-xi-ti-jie-by-youlookdeliciousc-3/">https://leetcode-cn.com/problems/spiral-matrix/solution/cxiang-xi-ti-jie-by-youlookdeliciousc-3/</a></p>
<p>这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小</p>
<p>1、首先设定上下左右边界。</p>
<p>2、其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界。<br>3、判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案。</p>
<p>4、若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理<br>不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义结果数组</span></span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans; <span class="comment">//若数组为空，直接返回答案</span></span><br><span class="line">        <span class="comment">//赋值上下左右边界</span></span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> d = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">// 行的数目-1</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">// 列的数目-1</span></span><br><span class="line">        <span class="comment">// 右下左上 。。</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; ++i) ans.<span class="built_in">push_back</span>(matrix[u][i]); <span class="comment">//向右移动直到最右</span></span><br><span class="line">            <span class="keyword">if</span>(++ u &gt; d) <span class="keyword">break</span>; <span class="comment">//重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = u; i &lt;= d; ++i) ans.<span class="built_in">push_back</span>(matrix[i][r]); <span class="comment">//向下</span></span><br><span class="line">            <span class="keyword">if</span>(-- r &lt; l) <span class="keyword">break</span>; <span class="comment">//重新设定有边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = r; i &gt;= l; --i) ans.<span class="built_in">push_back</span>(matrix[d][i]); <span class="comment">//向左</span></span><br><span class="line">            <span class="keyword">if</span>(-- d &lt; u) <span class="keyword">break</span>; <span class="comment">//重新设定下边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = d; i &gt;= u; --i) ans.<span class="built_in">push_back</span>(matrix[i][l]); <span class="comment">//向上</span></span><br><span class="line">            <span class="keyword">if</span>(++ l &gt; r) <span class="keyword">break</span>; <span class="comment">//重新设定左边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="螺旋矩阵2"><a href="#螺旋矩阵2" class="headerlink" title="螺旋矩阵2"></a>螺旋矩阵2</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>5459</td>
<td>螺旋矩阵2（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));<span class="comment">// 定义一个二位数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop=n/<span class="number">2</span>;<span class="comment">//每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid=n/<span class="number">2</span>;<span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 每一圈循环，需要控制每一条边遍历的长度</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(loop--)&#123;</span><br><span class="line">            i= startx;</span><br><span class="line">            j= starty;</span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; starty + n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; startx + n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="comment">//,n为偶数不用</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>)&#123;</span><br><span class="line">            res[mid][mid]=count;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2021-10-25-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-10-25-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">「算法刷题」链表相关经典题目</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-25T00:00:00+00:00">2021-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-02 01:00:55" itemprop="dateModified" datetime="2024-02-02T01:00:55+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h1><p>顺序结构：这里主要指的是数组或字符串。</p>
<h1 id="一、链表的基本操作"><a href="#一、链表的基本操作" class="headerlink" title="一、链表的基本操作"></a>一、链表的基本操作</h1><table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>707</td>
<td>设计链表（中等难度）</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-linked-list/">https://leetcode-cn.com/problems/design-linked-list/</a></td>
</tr>
</tbody></table>
<h2 id="在链表中添加或删除元素时，记得修改链表长度；"><a href="#在链表中添加或删除元素时，记得修改链表长度；" class="headerlink" title="在链表中添加或删除元素时，记得修改链表长度；"></a>在链表中添加或删除元素时，记得修改链表长度；</h2><p>代码：csdn博客：力扣 707. 设计链表 链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 初始化数据结构 */</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>():<span class="built_in">head</span>(<span class="keyword">new</span> <span class="built_in">node</span>()),<span class="built_in">tail</span>(head),<span class="built_in">size</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 得到链表中第index个结点的值，index小于0或大于链表长度（链表的index从0开始），返回-1 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size||index&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index==size<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> tail-&gt;val;</span><br><span class="line">        </span><br><span class="line">        node *cur=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 添加新的头节点 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ++size;</span><br><span class="line">        node *tmp=<span class="keyword">new</span> <span class="built_in">node</span>(val);</span><br><span class="line">        tmp-&gt;next=head-&gt;next;</span><br><span class="line">        head-&gt;next=tmp;</span><br><span class="line">        <span class="comment">//注意更新尾节点</span></span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>)</span><br><span class="line">            tail=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 在链表最后添加一个结点. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ++size;</span><br><span class="line">        node *tmp=<span class="keyword">new</span> <span class="built_in">node</span>(val);</span><br><span class="line">        tail-&gt;next=tmp;</span><br><span class="line">        tail=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 在链表第index个结点前添加结点，</span></span><br><span class="line"><span class="comment">    如果index等于链表长度，则将结点添加到链表末尾。</span></span><br><span class="line"><span class="comment">    如果index大于链表长度，则不会插入结点</span></span><br><span class="line"><span class="comment">    如果index小于0，则在头部插入结点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">addAtHead</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index==size)</span><br><span class="line">            <span class="built_in">addAtTail</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index&lt;size)&#123;</span><br><span class="line">            node *cur=head;</span><br><span class="line">            <span class="keyword">while</span>(index--)</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            <span class="comment">// node *nxt=cur-&gt;next;</span></span><br><span class="line">            <span class="comment">// node *tmp=new node(val);</span></span><br><span class="line">            <span class="comment">// cur-&gt;next=tmp;</span></span><br><span class="line">            <span class="comment">// tmp-&gt;next=nxt;</span></span><br><span class="line">            node *tmp=<span class="keyword">new</span> <span class="built_in">node</span>(val);</span><br><span class="line">            <span class="comment">// cur指向第index个结点的前一个</span></span><br><span class="line">            tmp-&gt;next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=tmp;</span><br><span class="line">            ++size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 索引有效，则删除链表的第index个结点*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size||index&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        node *cur=head;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        node *tmp=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=tmp-&gt;next;</span><br><span class="line">        <span class="comment">//tmp指向最后一个结点时，注意更新尾节点，</span></span><br><span class="line">        <span class="keyword">if</span>(!tmp-&gt;next)</span><br><span class="line">            tail=cur;<span class="comment">// cur指向第index个的前一个结点</span></span><br><span class="line">        <span class="built_in">delete</span>(tmp);</span><br><span class="line">        --size;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        node *next;</span><br><span class="line">        <span class="built_in">node</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">        <span class="built_in">node</span>(<span class="type">int</span> v):<span class="built_in">val</span>(v),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node *head=<span class="literal">nullptr</span>;</span><br><span class="line">    node *tail=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="二、链表的相交"><a href="#二、链表的相交" class="headerlink" title="二、链表的相交"></a>二、链表的相交</h1><table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th>关键点</th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>面试题02.07.</td>
<td>链表相交（简单难度）</td>
<td>长链表的遍历节点先多走和短链表的长度差个节点，然后同时遍历两个节点比较是否存在相同节点</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/</a></td>
</tr>
</tbody></table>
<p>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/solution/dai-ma-sui-xiang-lu-dai-ni-gao-ding-lian-5ykc/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/solution/dai-ma-sui-xiang-lu-dai-ni-gao-ding-lian-5ykc/</a><br>来源：力扣（LeetCode）</p>
<p>交点不是数值相等，而是指针相等。</p>
<p> 看如下两个链表，目前curA指向链表A的头结点，curB指向链表B的头结点： </p>
<p>![](&#x2F;img-post&#x2F;算法刷题&#x2F;2021-10-25-【算法刷题】链表相关经典题目&#x2F;示例图1.png)</p>
<p><img src="/../img-post/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2021-10-25-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/%E7%A4%BA%E4%BE%8B%E5%9B%BE1.png"></p>
<p> 我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置，如图： </p>
<p>![](&#x2F;img-post&#x2F;算法刷题&#x2F;2021-10-25-【算法刷题】链表相关经典题目&#x2F;示例图2.png)</p>
<p><img src="/../img-post/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2021-10-25-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/%E7%A4%BA%E4%BE%8B%E5%9B%BE2.png"></p>
<p>此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA &#x3D;&#x3D; curB，则找到焦点。</p>
<p>否则循环退出返回空指针。</p>
<p>作者：carlsun-2<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/solution/dai-ma-sui-xiang-lu-dai-ni-gao-ding-lian-5ykc/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/solution/dai-ma-sui-xiang-lu-dai-ni-gao-ding-lian-5ykc/</a><br>来源：力扣（LeetCode）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *curA=headA;</span><br><span class="line">        ListNode *curB=headB;</span><br><span class="line">        <span class="type">int</span> lenA=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lenB=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算A长度</span></span><br><span class="line">        <span class="keyword">while</span>(curA)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA=curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算B长度</span></span><br><span class="line">        <span class="keyword">while</span>(curB)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB=curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA=headA;</span><br><span class="line">        curB=headB;</span><br><span class="line">        <span class="comment">// 让curA指向长的链表,lenA为其长度。</span></span><br><span class="line">        <span class="keyword">if</span>(lenB&gt;lenA)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(lenA,lenB);</span><br><span class="line">            <span class="built_in">swap</span>(curA,curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算两个链表的长度差；</span></span><br><span class="line">        <span class="type">int</span> gap=lenA-lenB;</span><br><span class="line">        <span class="comment">// curA指向链表的一个结点，使两个链表的末尾对齐</span></span><br><span class="line">        <span class="keyword">while</span>(gap--)&#123;</span><br><span class="line">            curA=curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同时遍历，相等则返回结点</span></span><br><span class="line">        <span class="keyword">while</span>(curA)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA==curB)&#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA=curA-&gt;next;</span><br><span class="line">            curB=curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不等，返回空。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th>关键点</th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>92</td>
<td>反转链表2（中等难度）</td>
<td>长链表的遍历节点先多走和短链表的长度差个节点，然后同时遍历两个节点比较是否存在相同节点</td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<p>解题思路：<br>1、我们定义两个指针，分别称之为 g(guard 守卫) 和 p(point)。<br>我们首先根据方法的参数 m 确定 g 和 p 的位置。将 g 移动到第一个要反转的节点的前面，将 p 移动到第一个要反转的节点的位置上。我们以 m&#x3D;2，n&#x3D;4为例。<br>2、将 p 后面的元素删除，然后添加到 g 的后面。也即头插法。<br>3、根据 m 和 n 重复步骤（2）<br>4、返回 dummyHead.next<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/java-shuang-zhi-zhen-tou-cha-fa-by-mu-yi-cheng-zho/">https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/java-shuang-zhi-zhen-tou-cha-fa-by-mu-yi-cheng-zho/</a></p>
<p>![](&#x2F;img-post&#x2F;算法刷题&#x2F;2021-10-25-【算法刷题】链表相关经典题目&#x2F;示例图3.png)</p>
<p><img src="/../img-post/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2021-10-25-%E3%80%90%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E3%80%91%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/%E7%A4%BA%E4%BE%8B%E5%9B%BE3.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个虚拟头结点， 方便处理</span></span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化指针</span></span><br><span class="line">        ListNode g = dummyHead;</span><br><span class="line">        ListNode p = dummyHead.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将指针移到相应的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> step = <span class="number">0</span>; step &lt; m - <span class="number">1</span>; step++) &#123;</span><br><span class="line">            g = g.next; p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 头插法插入节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">            ListNode removed = p.next;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line"></span><br><span class="line">            removed.next = g.next;</span><br><span class="line">            g.next = removed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>LeetCode题目</strong></th>
<th><strong>相关题目类型</strong></th>
<th>关键点</th>
<th><strong>相关链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td>142</td>
<td>环形链表2（中等难度）</td>
<td></td>
<td><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode） (leetcode-cn.com)</a></td>
</tr>
</tbody></table>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>主要考察两知识点：</p>
<ul>
<li><p>判断链表是否环</p>
</li>
<li><p>如果有环，如何找到这个环的入口</p>
</li>
<li><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><p>可以使用快慢指针法，  分别定义 fast 和 slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p>
<p>为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢</p>
</li>
</ul>
<p>首先第一点： <strong>fast指针一定先进入环中，如果fast 指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。</strong></p>
<p>那么来看一下，<strong>为什么fast指针和slow指针一定会相遇呢？</strong></p>
<p>可以画一个环，然后让 fast指针在任意一个节点开始追赶slow指针。</p>
<p>会发现最终都是这种情况， 如下图：</p>
<p><img src="C:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211031165431940.png" alt="image-20211031165431940"></p>
<p>ast和slow各自再走一步， fast和slow就相遇了</p>
<p>这是因为fast是走两步，slow是走一步，<strong>其实相对于slow来说，fast是一个节点一个节点的靠近slow的</strong>，所以fast一定可以和slow重合。</p>
<h3 id="如果有环，如何找到这个环的入口"><a href="#如果有环，如何找到这个环的入口" class="headerlink" title="如果有环，如何找到这个环的入口"></a>如果有环，如何找到这个环的入口</h3><p><strong>此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。</strong></p>
<p>假设从头结点到环形入口节点 的节点数为x。<br>环形入口节点到 fast指针与slow指针相遇节点 节点数为y。<br>从相遇节点  再到环形入口节点节点数为 z。 如图所示：</p>
<p><img src="C:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211031165706230.png" alt="image-20211031165706230"></p>
<p>那么相遇时：<br>slow指针走过的节点数为: <code>x + y</code>，<br>fast指针走过的节点数：<code> x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</p>
<p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 &#x3D; slow指针走过的节点数 * 2：</p>
<p><code>(x + y) * 2 = x + y + n (y + z)</code></p>
<p>两边消掉一个（x+y）: <code>x + y  = n (y + z) </code></p>
<p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p>
<p>以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p>
<p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z  </code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p>
<p>这个公式说明什么呢？</p>
<p>先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p>
<p>当 n为1的时候，公式就化解为 <code>x = z</code>，</p>
<p>这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p>
<p>也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。</p>
<p>让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p>
<p>那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。</p>
<p>其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span><br><span class="line">            if (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                while (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                return index2; // 返回环的入口</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2021-10-19-%E3%80%90%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0%E3%80%91%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-10-19-%E3%80%90%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0%E3%80%91%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/" class="post-title-link" itemprop="url">「科研笔记」离散小波变换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-19 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-19T00:00:00+00:00">2021-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-02-02 01:00:55" itemprop="dateModified" datetime="2024-02-02T01:00:55+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>参考链接：</strong></p>
<p> <a target="_blank" rel="noopener" href="http://www.360doc.com/content/13/0925/12/10724725_316957631.shtml">哈尔小波变换的原理及其实现(Haar) (360doc.com)</a> </p>
<p>csdn博客：Python 离散小波变换（DWT） pywt库</p>
<p><strong>基础概念：</strong></p>
<p> <strong>变换</strong>：不管是压缩、滤波还是图像处理，本质都是变换，就是基。例如傅里叶变换就是将信号用该空间的基的线性组合进行表示 • </p>
<p><strong>正交：</strong> 如果两个向量的内积为0，它们就是正交的；如果一个向量序列相互对偶正交，并且长度为1，它们就是正交归一化的。 </p>
<p>哈尔小波变换是，小波变换中最简单的一种变换，也是最早提出的小波变换。</p>
<h2 id="一维哈尔小波变换"><a href="#一维哈尔小波变换" class="headerlink" title="一维哈尔小波变换"></a>一维哈尔小波变换</h2><table>
<thead>
<tr>
<th>例：求只有4个像素[9 7 3 5]的图像的小波变换系数。 计算步骤如下：</th>
</tr>
</thead>
<tbody><tr>
<td>1、<strong>求均值</strong>(averaging)。计算相邻像素对的平均值，得到一幅分辨率比较低的新图像，新的图像的分辨率是原来的1&#x2F;2，相应的像素值为：[8 4]</td>
</tr>
<tr>
<td>2、<strong>求差值</strong>(differencing)。上面的均值存储了图像的整体信息，但很多细节被丢掉了。所以要记录图像的细节信息，这样在重构时能够恢复图像的全部信息。方法是使用这个像素对的差值除以2，结果为[8 4 1 -1]<br/>以上两步形成第一次分解的结果[8 4 1 -1]，包含了图像的整体信息和细节信息。</td>
</tr>
<tr>
<td>接下来重复1、2步，将整体信息再次分解，得到二级分解结果[6,2,1,-1]</td>
</tr>
</tbody></table>
<p>![](&#x2F;img-post&#x2F;科研笔记&#x2F;2021-10-19-【科研笔记】离散小波变换&#x2F;table1.png)</p>
<p><img src="/../img-post/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/2021-10-19-%E3%80%90%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0%E3%80%91%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/table1.png"></p>
<p>从这个例子中我们可以看到：<br>① 对这个给定的变换，我们可以从所记录的数据中重构出各种分辨率的图像。例如，在分辨率为1的图像基础上重构出分辨率为2的图像，在分辨率为2的图像基础上重构出分辨率为4的图像。<br>②变换过程中没有丢失信息，因为能够从所记录的数据中重构出原始图像。<br>③ 通过变换之后产生的细节系数的幅度值比较小，这就为图像压缩提供了一种途径，例如去掉一些微不足道的细节系数并不影响对重构图像的理解。</p>
<p>这个过程就叫做哈尔小波变换，也称哈尔小波分解，这个概念可以推广到使用其他小波基的变换。</p>
<h2 id="二维哈尔小波变换"><a href="#二维哈尔小波变换" class="headerlink" title="二维哈尔小波变换"></a>二维哈尔小波变换</h2><p>​        对于二维小波变换，通常一次分解形成了整体图像，水平细节，垂直细节，对角细节。首先我们按照一维小波分解的原理，按照行顺序对行进行处理，然后按照列顺序对行处理结果进行同样的处理。</p>
<p> 经过小波变换后图像会生成低频信息和高频信息。低频信息对应于求均值，高频信息对应于求差值。<br><code>均值是局部的平均值，变化缓慢，属于低频信息，存储图片的轮廓信息，近似信息</code><br><code>差值是局部的波动值，变化较快，属于高频信息，存储图片的细节信息，局部信息，另外含有噪音</code> </p>
<p>假设有一幅灰度图像，其中的一个图像块用矩阵A 表示：</p>
<p>![](&#x2F;img-post&#x2F;科研笔记&#x2F;2021-10-19-【科研笔记】离散小波变换&#x2F;matrix1.png)</p>
<p><img src="/../img-post/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/2021-10-19-%E3%80%90%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0%E3%80%91%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/matrix1.png"></p>
<p>​       一个图像块是一个二维矩阵，进行小波变换时可以对矩阵的每一行进行变换，然后对行变换后的每一列进行变换，最后对经过变换之后的图像矩阵进行编码。</p>
<p>第一步：在第一行上取每一对像素的平均值，并将结果放到第一行的前四个位置，其余4个数是第一行每一对像素的第一个数和对应的平均值之差（也可以是 这个像素对的差值除以2 ，计算结果是一样的。）将结果放到第一行的最后四个位置。</p>
<p>第二步：对第一行的前四个数使用与第一步相同的方法，得到两个平均值和两个差（系数），并依次放在第一行的前四个位置，其余四个细节系数位置不动。</p>
<p>第三步：用与第一步和第二步相同的方法，对剩下的一对平均值求均值和差值。</p>
<p>用求均值和差值的方法，对矩阵每一行进行计算，得到矩阵A‘。</p>
<p>![](&#x2F;img-post&#x2F;科研笔记&#x2F;2021-10-19-【科研笔记】离散小波变换&#x2F;matrix2.png)</p>
<p><img src="/../img-post/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/2021-10-19-%E3%80%90%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0%E3%80%91%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/matrix2.png"></p>
<p>每行的第一个元素是该行像素值的平均值，其余是这行的细节系数。用同样的方法，对A’的每一列进行计算，得到A’’</p>
<p>![](&#x2F;img-post&#x2F;科研笔记&#x2F;2021-10-19-【科研笔记】离散小波变换&#x2F;matrix3.png)</p>
<p><img src="/../img-post/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/2021-10-19-%E3%80%90%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0%E3%80%91%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/matrix3.png"></p>
<p>左上角的元素是整个图像块的像素值的平均值，其余是该图像块的细节系数，根据这个事实，如果从矩阵中去掉图像的某些细节系数，事实证明重构的图像质量仍然可以接受。</p>
<p>具体做法是设置一个阈值D，应该是像素值小于等于5的细节系数就把它当做0看待。这样变换后的矩阵为A‘’‘</p>
<p>![](&#x2F;img-post&#x2F;科研笔记&#x2F;2021-10-19-【科研笔记】离散小波变换&#x2F;matrix4.png)</p>
<p><img src="/../img-post/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/2021-10-19-%E3%80%90%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0%E3%80%91%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/matrix4.png"></p>
<p>’0‘的数目增加了18个，也就是去掉了18个细节系数，这样可以提高编码的效率。</p>
<h3 id="上面解释的图示："><a href="#上面解释的图示：" class="headerlink" title="上面解释的图示："></a>上面解释的图示：</h3><p>（来自csdn博客：）</p>
<p> <strong>经过小波变换后图像会生成低频信息和高频信息。</strong>低频信息对应于求均值，高频信息对应于求差值。<br><code>均值是局部的平均值，变化缓慢，属于低频信息，存储图片的轮廓信息，近似信息</code><br><code>差值是局部的波动值，变化较快，属于高频信息，存储图片的细节信息，局部信息，另外含有噪音</code> </p>
<p> 水平和竖直两个方向进行低通和高通滤波（水平和竖直先后不影响），用图像表述如下图所示： </p>
<p>![](&#x2F;img-post&#x2F;科研笔记&#x2F;2021-10-19-【科研笔记】离散小波变换&#x2F;image1.png)</p>
<p><img src="/../img-post/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/2021-10-19-%E3%80%90%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0%E3%80%91%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/image1.png"></p>
<p>其中：</p>
<ul>
<li>b: 原图信息</li>
<li>h1 :水平方向的细节（高频信息），</li>
<li>v1 表示竖直方向的细节（高频信息），</li>
<li>c1表示对角线方向的细节（高频信息）</li>
</ul>
<p>![](&#x2F;img-post&#x2F;科研笔记&#x2F;2021-10-19-【科研笔记】离散小波变换&#x2F;image2.png)</p>
<p><img src="/../img-post/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/2021-10-19-%E3%80%90%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0%E3%80%91%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/image2.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/23/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/25/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">vvbuys</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
