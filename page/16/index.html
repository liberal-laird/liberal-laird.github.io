<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="baidu-site-verification" content="codeva-6wmKWl5hmx" />
<meta name="bytedance-verification-code" content="GcOf/MpQ8shZ5Hh/2hvr" />
<meta name="google-site-verification" content="wivqPhuFdISMEKkFZjOWHPYJGSvd716d9R7Bwy2Jj-A" />
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4636539228226058"
     crossorigin="anonymous"></script>
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.vvbuys.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Share some post and some issue for linux program">
<meta property="og:type" content="website">
<meta property="og:title" content="VVbugs Blog">
<meta property="og:url" content="https://www.vvbuys.com/page/16/index.html">
<meta property="og:site_name" content="VVbugs Blog">
<meta property="og:description" content="Share some post and some issue for linux program">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="vvbuys">
<meta property="article:tag" content="Linux hyprland Python Rust Golang javascript">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.vvbuys.com/page/16/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/16/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>VVbugs Blog - standalone Linux lover</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">VVbugs Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">standalone Linux lover</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">vvbuys</p>
  <div class="site-description" itemprop="description">Share some post and some issue for linux program</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">265</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2012-06-17-windows-skills/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2012-06-17-windows-skills/" class="post-title-link" itemprop="url">Windows 实用技巧汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:06:28" itemprop="dateCreated datePublished" datetime="2024-02-02T01:06:28+00:00">2024-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>平时使用 Windows 时总结的一些实用的小技巧。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2012-06-17-windows-skills/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/2012-06-19-gecko-use-profile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2012-06-19-gecko-use-profile/" class="post-title-link" itemprop="url">为基于 xulrunner 的内嵌 Gecko 程序启用 Profile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:06:28" itemprop="dateCreated datePublished" datetime="2024-02-02T01:06:28+00:00">2024-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Gecko/" itemprop="url" rel="index"><span itemprop="name">Gecko</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>为基于 xulrunner 为内嵌 Gecko 程序启用 Profile</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2012-06-19-gecko-use-profile/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_lf/2019-01-16-sf-lf-16-auto/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_lf/2019-01-16-sf-lf-16-auto/" class="post-title-link" itemprop="url">「SF-LC」16 Auto</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><code>auto</code> - proof search</li>
<li><code>Ltac</code> - automated forward reasoning (hypothesis matching machinery)</li>
<li><code>eauto</code>, <code>eapply</code> - deferred instantiation of existentials</li>
</ul>
<h2 id="Ltac-macro"><a href="#Ltac-macro" class="headerlink" title="Ltac macro"></a><code>Ltac</code> macro</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Ltac</span> inv H := <span class="built_in">inversion</span> H; <span class="built_in">subst</span>; <span class="built_in">clear</span> H.</span><br><span class="line"></span><br><span class="line"><span class="comment">(** later in the proof... **)</span></span><br><span class="line">inv H5.</span><br></pre></td></tr></table></figure>



<h2 id="The-auto-Tactic"><a href="#The-auto-Tactic" class="headerlink" title="The auto Tactic"></a>The <code>auto</code> Tactic</h2><blockquote>
<p><code>auto</code> can free us by <em>searching</em> for a sequence of applications that will prove the goal:</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">intros</span> P Q R H1 H2 H3.</span><br><span class="line"><span class="built_in">apply</span> H2. <span class="built_in">apply</span> H1. <span class="built_in">assumption</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">(** can be replaced by... **)</span></span><br><span class="line"><span class="built_in">auto</span>.</span><br></pre></td></tr></table></figure>

<p><code>auto</code> solves goals that are solvable by <em>any combination</em> of </p>
<ul>
<li><code>intros</code></li>
<li><code>apply</code> (of hypotheses from the <em>local</em> context, by default)</li>
</ul>
<blockquote>
<p>使用 auto 一定是“安全”的，它不会失败，也不会改变当前证明的状态： auto 要么完全解决它，要么什么也不做。</p>
</blockquote>
<blockquote>
<p>Proof search could, in principle, take an arbitrarily long time,<br>so there are limits to how far auto will search by default.  (i.e. <code>5</code>)</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> auto_example_3 : ∀(P Q R S T U: <span class="keyword">Prop</span>),</span><br><span class="line">  (P → Q) →</span><br><span class="line">  (Q → R) →</span><br><span class="line">  (R → S) →</span><br><span class="line">  (S → T) →</span><br><span class="line">  (T → U) →</span><br><span class="line">  P →</span><br><span class="line">  U.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="comment">(* 当 auto 无法解决此目标时，它就什么也不做 *)</span></span><br><span class="line">  <span class="built_in">auto</span>.</span><br><span class="line">  <span class="comment">(* 可选的参数用来控制它的搜索深度（默认为 5）, 6 就刚好能解决了！ *)</span></span><br><span class="line">  <span class="built_in">auto</span> <span class="number">6.</span></span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>


<h3 id="Hint-Database-提示数据库"><a href="#Hint-Database-提示数据库" class="headerlink" title="Hint Database 提示数据库"></a>Hint Database 提示数据库</h3><blockquote>
<p><code>auto</code> auto considers a <strong>hint database</strong> of other lemmas and constructors.<br>common lemmas about <em>equality</em> and <em>logical operators</em> are installed by default.</p>
</blockquote>
<blockquote>
<p>just for the purposes of one application of <code>auto</code><br>我们可以为某次 <code>auto</code> 的调用扩展提示数据库，<code>auto using ...</code> </p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> auto_example_6 : ∀n m p : nat,</span><br><span class="line">  (n ≤ p → (n ≤ m ∧ m ≤ n)) →</span><br><span class="line">  n ≤ p →</span><br><span class="line">  n = m.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span>.</span><br><span class="line">  <span class="built_in">auto</span> <span class="built_in">using</span> le_antisym.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>


<h3 id="Global-Hint-Database-添加到全局提示数据库"><a href="#Global-Hint-Database-添加到全局提示数据库" class="headerlink" title="Global Hint Database 添加到全局提示数据库"></a>Global Hint Database 添加到全局提示数据库</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Hint</span> <span class="keyword">Resolve</span> T.          </span><br><span class="line"></span><br><span class="line"><span class="keyword">Hint</span> <span class="keyword">Constructors</span> c.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Hint</span> <span class="keyword">Unfold</span> d.</span><br></pre></td></tr></table></figure>


<h3 id="Proof-with-auto"><a href="#Proof-with-auto" class="headerlink" title="Proof with auto."></a><code>Proof with auto.</code></h3><p>Under <code>Proof with t</code>, <code>t1...</code> &#x3D;&#x3D; <code>t1; t</code>.</p>
<h2 id="Searching-For-Hypotheses"><a href="#Searching-For-Hypotheses" class="headerlink" title="Searching For Hypotheses"></a>Searching For Hypotheses</h2><p>对于很常见的一种矛盾情形：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H1: beval st b = false</span><br><span class="line">H2: beval st b = true</span><br></pre></td></tr></table></figure>

<p><code>contradiction</code> 并不能解决，必须 <code>rewrite H1 in H2; inversion H2</code>.</p>
<ol>
<li>宏：</li>
</ol>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Ltac</span> rwinv H1 H2 := <span class="built_in">rewrite</span> H1 <span class="built_in">in</span> H2; inv H2.</span><br><span class="line"></span><br><span class="line"><span class="comment">(** later in the proof... **)</span></span><br><span class="line">rwinv H H2.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>match goal</code> 调用宏</li>
</ol>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Ltac</span> find_rwinv :=</span><br><span class="line">  <span class="keyword">match</span> goal <span class="built_in">with</span></span><br><span class="line">    H1: ?E = true,</span><br><span class="line">    H2: ?E = false</span><br><span class="line">    ⊢ <span class="keyword">_</span> ⇒ rwinv H1 H2</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line">  </span><br><span class="line"><span class="comment">(** later in the proof... **)</span></span><br><span class="line"><span class="built_in">induction</span> E1; <span class="built_in">intros</span> st2 E2; inv E2; <span class="built_in">try</span> find_rwinv; <span class="built_in">auto</span>. <span class="comment">(** 直接解决所有矛盾 case **)</span></span><br><span class="line">- <span class="comment">(* E_Seq *)</span></span><br><span class="line">  <span class="built_in">rewrite</span> (IHE1_1 st&#x27;<span class="number">0</span> H1) <span class="built_in">in</span> *. <span class="built_in">auto</span>.</span><br><span class="line">- <span class="comment">(* E_WhileTrue *)</span></span><br><span class="line">  + <span class="comment">(* b 求值为 true *)</span></span><br><span class="line">    <span class="built_in">rewrite</span> (IHE1_1 st&#x27;<span class="number">0</span> H3) <span class="built_in">in</span> *. <span class="built_in">auto</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>可以看到最后只剩这种改写形式…我们也把他们自动化了：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Ltac</span> find_eqn :=</span><br><span class="line">  <span class="keyword">match</span> goal <span class="built_in">with</span></span><br><span class="line">    H1: ∀x, ?P x → ?L = ?R,</span><br><span class="line">    H2: ?P ?X</span><br><span class="line">    ⊢ <span class="keyword">_</span> ⇒ <span class="built_in">rewrite</span> (H1 X H2) <span class="built_in">in</span> *</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>配合上 <code>repeat</code>…我们可以 keep doing useful rewrites until only trivial ones are left.<br>最终效果：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> ceval_deterministic&#x27;&#x27;&#x27;&#x27;&#x27;: ∀c st st1 st2,</span><br><span class="line">    st =[ c ]⇒ st1 →</span><br><span class="line">    st =[ c ]⇒ st2 →</span><br><span class="line">    st1 = st2.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> c st st1 st2 E1 E2.</span><br><span class="line">  <span class="built_in">generalize</span> <span class="built_in">dependent</span> st2;</span><br><span class="line">  <span class="built_in">induction</span> E1; <span class="built_in">intros</span> st2 E2; inv E2; </span><br><span class="line">    <span class="built_in">try</span> find_rwinv;</span><br><span class="line">    <span class="built_in">repeat</span> find_eqn; <span class="built_in">auto</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>即使我们给 IMP 加上一个 <code>CRepeat</code>（其实就是 <code>DO c WHILE b</code>)，<br>会发现颠倒一下自动化的顺序就能 work 了</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">induction</span> E1; <span class="built_in">intros</span> st2 E2; inv E2; </span><br><span class="line">  <span class="built_in">repeat</span> find_eqn; </span><br><span class="line">  <span class="built_in">try</span> find_rwinv; <span class="built_in">auto</span>.</span><br></pre></td></tr></table></figure>

<p>当然，这种「超级自动化」(hyper-automation) 并不总是现实，也不好调试…</p>
<h3 id="The-eapply-and-eauto-variants"><a href="#The-eapply-and-eauto-variants" class="headerlink" title="The eapply and eauto variants"></a>The <code>eapply</code> and <code>eauto</code> variants</h3><blockquote>
<p>推迟量词的实例化</p>
</blockquote>
<p>比如对于</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> ceval_example1:</span><br><span class="line">  empty_st =[</span><br><span class="line">    X ::= <span class="number">2</span>;;</span><br><span class="line">    TEST X ≤ <span class="number">1</span></span><br><span class="line">      THEN Y ::= <span class="number">3</span></span><br><span class="line">      ELSE Z ::= <span class="number">4</span></span><br><span class="line">    FI</span><br><span class="line">  ]⇒ (Z !-&gt; <span class="number">4</span> ; X !-&gt; <span class="number">2</span>).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="comment">(* 我们补充了中间状态 st&#x27;... *)</span></span><br><span class="line">  <span class="built_in">apply</span> E_Seq <span class="built_in">with</span> (X !-&gt; <span class="number">2</span>).</span><br><span class="line">  - <span class="built_in">apply</span> E_Ass. <span class="built_in">reflexivity</span>.</span><br><span class="line">  - <span class="built_in">apply</span> E_IfFalse. <span class="built_in">reflexivity</span>. <span class="built_in">apply</span> E_Ass. <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>没有 <code>with</code> 就会 <code>Error: Unable to find an instance for the variable st&#39;</code></p>
<p>但其实 <code>st&#39;</code> 的取值在后面的步骤是很明显（很好 infer&#x2F;unify）的，所以 <code>eapply</code> works.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_plf/2019-03-01-sf-plf-01-equiv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_plf/2019-03-01-sf-plf-01-equiv/" class="post-title-link" itemprop="url">「SF-PLF」1 Equiv</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="issues-on-coqc-module-linking"><a href="#issues-on-coqc-module-linking" class="headerlink" title="issues on coqc module linking"></a>issues on <code>coqc</code> module linking</h3><p>Some module (e.g.<code>Map</code>) not found<br>either maunally <code>make map.vo</code> or proof general can solve that.</p>
<h2 id="Behavioral-Equivalence-行为等价"><a href="#Behavioral-Equivalence-行为等价" class="headerlink" title="Behavioral Equivalence 行为等价"></a>Behavioral Equivalence 行为等价</h2><blockquote>
<p>How to define <em>the correctness of program transformation</em>, e.g. <code>optimize_0plus</code> ?</p>
</blockquote>
<ul>
<li>in the setting w&#x2F;o var (imp w&#x2F;o var and state) : yield a program the evals to same number as original.</li>
<li>in the setting w&#x2F; var (full imp w&#x2F; assignment) : we need to consider the role of var and state.</li>
</ul>
<h3 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h3><blockquote>
<p>Two <code>aexps</code> or <code>bexps</code> are <em>behaviorally equivalent</em> if they evaluate to the same result <strong>in every state</strong>.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> aequiv (a1 a2 : aexp) : <span class="keyword">Prop</span> :=</span><br><span class="line">  ∀(st : state), aeval st a1 = aeval st a2.</span><br><span class="line"><span class="keyword">Definition</span> bequiv (b1 b2 : bexp) : <span class="keyword">Prop</span> :=</span><br><span class="line">  ∀(st : state), beval st b1 = beval st b2.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>For commands, We can’t simply say … if they evaluate to the same ending state<br><strong>some commands don’t terminate in any final state at all!</strong></p>
</blockquote>
<p>So to define, they either or…</p>
<ol>
<li>both diverge 都发散</li>
<li>both terminate in the same final state 都在同一个状态停机</li>
</ol>
<p>A compact way is </p>
<blockquote>
<p>“if the first one terminates in a particular state then so does the second, and vice versa.”</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> cequiv (c1 c2 : com) : <span class="keyword">Prop</span> :=</span><br><span class="line">  ∀(st st&#x27; : state),</span><br><span class="line">    (st =[ c1 ]⇒ st&#x27;) ↔ (st =[ c2 ]⇒ st&#x27;). </span><br></pre></td></tr></table></figure>

<h3 id="Example-1-Simple-but-demonstrated"><a href="#Example-1-Simple-but-demonstrated" class="headerlink" title="Example 1 - Simple (but demonstrated)"></a>Example 1 - Simple (but demonstrated)</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> skip_left : <span class="keyword">forall</span> c,</span><br><span class="line">  cequiv (SKIP;; c) c.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> c st st&#x27;. <span class="built_in">split</span>; <span class="built_in">intros</span> H.</span><br><span class="line">  - <span class="comment">(* -&gt; *)</span>         </span><br><span class="line">    <span class="built_in">inversion</span> H; <span class="built_in">subst</span>.  <span class="comment">(* inverse E_Seq   *)</span></span><br><span class="line">    <span class="built_in">inversion</span> H2. <span class="built_in">subst</span>. <span class="comment">(* inverse E_Skip  *)</span></span><br><span class="line">    <span class="built_in">assumption</span>.</span><br><span class="line">  - <span class="comment">(* &lt;- *)</span>             <span class="comment">(* reversely *)</span></span><br><span class="line">    <span class="built_in">apply</span> E_Seq <span class="built_in">with</span> st. <span class="comment">(* apply E_Seq *)</span></span><br><span class="line">    <span class="built_in">apply</span> E_Skip.        <span class="comment">(* apply E_Skip *)</span></span><br><span class="line">    <span class="built_in">assumption</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>Noticed that the <code>inversion</code> is like use the <em>inverse function</em> of constructors.</p>
<h3 id="Example-2-WHILE-true-non-terminating"><a href="#Example-2-WHILE-true-non-terminating" class="headerlink" title="Example 2 - WHILE true non-terminating"></a>Example 2 - WHILE true non-terminating</h3><p>one interesting theorem is that we can prove <code>WHILE &lt;things ⇓ true&gt;</code> is not terminating.<br>and is equivalent to <em>any other non-terminating program</em>, e.g. <code>WHILE BTrue DO SKIP END</code>: (因为我们的「等价」只要求同「发散」即可)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> WHILE_true : ∀b c,</span><br><span class="line">  bequiv b true →</span><br><span class="line">  cequiv</span><br><span class="line">    (WHILE b DO c END)</span><br><span class="line">    (WHILE true DO SKIP END).</span><br></pre></td></tr></table></figure>


<h3 id="Example-3-Loop-Unrolling"><a href="#Example-3-Loop-Unrolling" class="headerlink" title="Example 3 - Loop Unrolling"></a>Example 3 - Loop Unrolling</h3><blockquote>
<p><em>any number of copies of the body</em> can be “unrolled” without changing meaning</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> loop_unrolling : ∀b c,</span><br><span class="line">  cequiv</span><br><span class="line">    (WHILE b DO c END)         </span><br><span class="line">    (TEST b THEN (c ;; WHILE b DO c END) ELSE SKIP FI).    <span class="comment">(** 展开一层 **)</span></span><br></pre></td></tr></table></figure>


<h3 id="Example-4-Use-of-extenionality-外延性"><a href="#Example-4-Use-of-extenionality-外延性" class="headerlink" title="Example 4 - Use of extenionality 外延性"></a>Example 4 - Use of extenionality 外延性</h3><p><code>x !-&gt; m x ; x</code> is same map with <code>m</code> by extenionality!</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> identity_assignment : ∀x,</span><br><span class="line">  cequiv (x ::= x) SKIP.</span><br></pre></td></tr></table></figure>





<h2 id="Properties-of-Behavioral-Equivalence-行为等价的性质"><a href="#Properties-of-Behavioral-Equivalence-行为等价的性质" class="headerlink" title="Properties of Behavioral Equivalence 行为等价的性质"></a>Properties of Behavioral Equivalence 行为等价的性质</h2><h3 id="等价关系-Equivalence"><a href="#等价关系-Equivalence" class="headerlink" title="等价关系 (Equivalence)"></a>等价关系 (Equivalence)</h3><blockquote>
<p>自反性（reflexive）、对称性（symmetric）和传递性 （transitive）</p>
</blockquote>
<h3 id="同余关系（Congruence）"><a href="#同余关系（Congruence）" class="headerlink" title="同余关系（Congruence）"></a>同余关系（Congruence）</h3><blockquote>
<p>That is, the equivalence of two subprograms implies the equivalence of the larger programs in which they are <em>embedded</em><br>如果两个子程序等价，那么当二者所在的更大的程序中_只有二者不同_时， 这两个更大的程序也等价</p>
</blockquote>
<pre><code>          aequiv a1 a1&#39;
  -----------------------------
  cequiv (x ::= a1) (x ::= a1&#39;)

          cequiv c1 c1&#39;
          cequiv c2 c2&#39;
     --------------------------
     cequiv (c1;;c2) (c1&#39;;;c2&#39;)
</code></pre>
<blockquote>
<p>这个术语应该是来自抽象代数 : 能在运算下保持的等价关系<br>…in the sense that algebraic operations done with equivalent elements will yield equivalent elements.<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Congruence_relation">Congruence relation</a></p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> CAss_congruence : ∀x a1 a1&#x27;,     <span class="comment">(** cequiv 是集合 commands 上的等价关系 **)</span></span><br><span class="line">  aequiv a1 a1&#x27; →</span><br><span class="line">  cequiv (CAss x a1) (CAss x a1&#x27;).       <span class="comment">(** 在 `CAss` 这个 operation 下保持等价 =&gt; 同余 **)</span></span><br><span class="line">  cequiv (x ::= a1) (x ::= a1&#x27;).         <span class="comment">(** 或，在 `::=` 这个 command 下保持等价 =&gt; 同余 **)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 commands 上等价但不同余的关系?</p>
</blockquote>
<p>I guess…”both terminating” relation?<br>which is equivalence relation on commands, but the equivalence would not be maintained after, say <code>C_WHILE</code> operation.</p>
<h3 id="Example-Using-Congruence"><a href="#Example-Using-Congruence" class="headerlink" title="Example - Using Congruence"></a>Example - Using Congruence</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> congruence_example:</span><br><span class="line">  cequiv</span><br><span class="line">    <span class="comment">(* 程序 1： *)</span></span><br><span class="line">    (X ::= <span class="number">0</span>;;</span><br><span class="line">     TEST X = <span class="number">0</span></span><br><span class="line">     THEN</span><br><span class="line">       Y ::= <span class="number">0</span></span><br><span class="line">     ELSE</span><br><span class="line">       Y ::= <span class="number">42</span></span><br><span class="line">     FI)</span><br><span class="line">    <span class="comment">(* 程序 2： *)</span></span><br><span class="line">    (X ::= <span class="number">0</span>;;</span><br><span class="line">     TEST X = <span class="number">0</span></span><br><span class="line">     THEN</span><br><span class="line">       Y ::= X - X <span class="comment">(* &lt;--- 这里不同 *)</span></span><br><span class="line">     ELSE</span><br><span class="line">       Y ::= <span class="number">42</span></span><br><span class="line">     FI).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">apply</span> CSeq_congruence.</span><br><span class="line">  - <span class="built_in">apply</span> refl_cequiv.</span><br><span class="line">  - <span class="built_in">apply</span> CIf_congruence.</span><br><span class="line">    + <span class="built_in">apply</span> refl_bequiv.</span><br><span class="line">    + <span class="built_in">apply</span> CAss_congruence.     <span class="comment">(** &lt;--- 化简到只需要证明 aequiv 0 (X - X) **)</span> </span><br><span class="line">      <span class="built_in">unfold</span> aequiv. <span class="built_in">simpl</span>.</span><br><span class="line">      * <span class="built_in">symmetry</span>. <span class="built_in">apply</span> minus_diag.</span><br><span class="line">    + <span class="built_in">apply</span> refl_cequiv.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>





<h2 id="Program-Transformations-程序变换"><a href="#Program-Transformations-程序变换" class="headerlink" title="Program Transformations 程序变换"></a>Program Transformations 程序变换</h2><blockquote>
<p>A program transformation is <em>sound</em> if it preserves the behavior of the original program.<br>如果一个程序变换保留了其原始行为，那么它就是_可靠_的</p>
</blockquote>
<p>我们可以定义在不同集合 <code>aexp, bexp, com</code> 上的 sound 关系：<br>(有趣的是，<code>Inductive</code> 定义的非 <code>Prop</code> 的 <code>Type</code>, 确实就是 <code>Set</code>, 这是一种 PL 和数学的 Correspondence)</p>
<ul>
<li>当我们的 datatype 是 constructor 时 &#x3D;&gt; 不交并</li>
<li>当我们的 datatype 有 recursive   时 &#x3D;&gt; 集合的递归定义</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> atrans_sound (atrans : aexp → aexp) : <span class="keyword">Prop</span> :=</span><br><span class="line">  ∀(a : aexp), aequiv a (atrans a).</span><br><span class="line"><span class="keyword">Definition</span> btrans_sound (btrans : bexp → bexp) : <span class="keyword">Prop</span> :=</span><br><span class="line">  ∀(b : bexp), bequiv b (btrans b).</span><br><span class="line"><span class="keyword">Definition</span> ctrans_sound (ctrans : com → com) : <span class="keyword">Prop</span> :=</span><br><span class="line">  ∀(c : com), cequiv c (ctrans c).</span><br></pre></td></tr></table></figure>


<h3 id="Constant-Folding-常量折叠"><a href="#Constant-Folding-常量折叠" class="headerlink" title="Constant Folding 常量折叠"></a>Constant Folding 常量折叠</h3><blockquote>
<p>An expression is <em>constant</em> when it contains no variable references.<br>不引用变量的表达式为_常量_</p>
</blockquote>
<blockquote>
<p>Constant folding is an <em>optimization</em> that finds constant expressions and replaces them by their values.<br>常量折叠是一种找到常量表达式并把它们替换为其值的优化方法。</p>
</blockquote>
<h3 id="Soundness-of-Constant-Folding"><a href="#Soundness-of-Constant-Folding" class="headerlink" title="Soundness of Constant Folding"></a>Soundness of Constant Folding</h3><h4 id="aexp"><a href="#aexp" class="headerlink" title="aexp"></a><code>aexp</code></h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> fold_constants_aexp_sound :</span><br><span class="line">  atrans_sound fold_constants_aexp.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">unfold</span> atrans_sound. <span class="built_in">intros</span> a. <span class="built_in">unfold</span> aequiv. <span class="built_in">intros</span> st.</span><br><span class="line">  </span><br><span class="line"><span class="comment">(** 这个时候的状态：**)</span></span><br><span class="line"></span><br><span class="line">  a : aexp</span><br><span class="line">  st : state</span><br><span class="line">  ============================</span><br><span class="line">  aeval st a = aeval st (fold_constants_aexp a)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h4 id="bexp"><a href="#bexp" class="headerlink" title="bexp"></a><code>bexp</code></h4><p>证明 <code>btrans_sound fold_constants_bexp.</code> 要难一些，因为其中还用到了 <code>fold_constants_aexp</code>, 所以我们需要一些技巧</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** 如果不记住而是直接 destruct 的话，这部分信息就丢失了 **)</span></span><br><span class="line">    <span class="built_in">remember</span> (fold_constants_aexp a1) <span class="built_in">as</span> a1&#x27; eqn:Heqa1&#x27;.</span><br><span class="line">    <span class="built_in">remember</span> (fold_constants_aexp a2) <span class="built_in">as</span> a2&#x27; eqn:Heqa2&#x27;.</span><br><span class="line"></span><br><span class="line"><span class="comment">(** 保留了这部分信息的目的是，使用 aexp 的可靠性定理来建立 aexp 与 值 的关系 **)</span></span><br><span class="line">    <span class="built_in">replace</span> (aeval st a1) <span class="built_in">with</span> (aeval st a1&#x27;) <span class="built_in">by</span></span><br><span class="line">       (<span class="built_in">subst</span> a1&#x27;; <span class="built_in">rewrite</span> &lt;- fold_constants_aexp_sound; <span class="built_in">reflexivity</span>).</span><br><span class="line">    <span class="built_in">replace</span> (aeval st a2) <span class="built_in">with</span> (aeval st a2&#x27;) <span class="built_in">by</span></span><br><span class="line">       (<span class="built_in">subst</span> a2&#x27;; <span class="built_in">rewrite</span> &lt;- fold_constants_aexp_sound; <span class="built_in">reflexivity</span>).</span><br><span class="line"></span><br><span class="line"><span class="comment">(** 最后才分类讨论 **)</span></span><br><span class="line">    <span class="built_in">destruct</span> a1&#x27;; <span class="built_in">destruct</span> a2&#x27;; <span class="built_in">try</span> <span class="built_in">reflexivity</span>.</span><br></pre></td></tr></table></figure>

<h4 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a><code>cmd</code></h4><p>主要技巧在于配合使用 <code>Congruence</code> 与 <code>IH</code> 解决大部分 case，然后分类讨论 <code>fold_constants_bexp</code> 用 <code>sound</code> 做替换解决剩余 case.</p>
<h3 id="Soundness-of-0-n"><a href="#Soundness-of-0-n" class="headerlink" title="Soundness of (0 + n)"></a>Soundness of (0 + n)</h3><p>类似，但是接下来我们就可以证明先 <code> fold_constants</code> 再 <code>optimize_0plus</code> 也是 sound 的.<br>这里我更 general 得证明了 <code>ctrans</code> 关系的传递性：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> trans_ctrans_sound : <span class="keyword">forall</span> tr1 tr2,</span><br><span class="line">  ctrans_sound tr1 -&gt; </span><br><span class="line">  ctrans_sound tr2 -&gt; </span><br><span class="line">  ctrans_sound (<span class="keyword">fun</span> c =&gt; tr2 (tr1 c)).</span><br></pre></td></tr></table></figure>






<h2 id="Proving-Inequivalence-证明程序不等价"><a href="#Proving-Inequivalence-证明程序不等价" class="headerlink" title="Proving Inequivalence 证明程序不等价"></a>Proving Inequivalence 证明程序不等价</h2><p>在这个例子中，<code>subst_aexp</code> 是 sound 得，被称为 <em>Constant Propagation</em> (常量传播)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(**    [X := 42 + 53](Y + X)  =&gt;  Y + (42 + 53)    **)</span></span><br><span class="line"><span class="keyword">Example</span> subst_aexp_ex :</span><br><span class="line">  subst_aexp X (<span class="number">42</span> + <span class="number">53</span>) (Y + X)%imp = (Y + (<span class="number">42</span> + <span class="number">53</span>))%imp.</span><br><span class="line"><span class="keyword">Proof</span>. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>所以我们断言这么做是 always sound 得： </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> subst_equiv_property := ∀x1 x2 a1 a2,</span><br><span class="line">  cequiv (x1 ::= a1;; x2 ::= a2)</span><br><span class="line">         (x1 ::= a1;; x2 ::= subst_aexp x1 a1 a2).</span><br></pre></td></tr></table></figure>

<p>然而如果 <code>a1</code> 不是常量，副作用很容易让这个转换 unsound<br>那么怎么证明 <code>¬subst_equiv_property</code> (即该性质不成立)? 举一个反例就好</p>
<p>Informal proof</p>
<ul>
<li>provide a witness</li>
</ul>
<p>Formal</p>
<ul>
<li>give counterexamples via <code>remember</code>, then show <code>⊥</code>.</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** 给出一组反例，使用性质证明他们 cequiv **)</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">remember</span> (X ::= X + <span class="number">1</span>;;</span><br><span class="line">            Y ::= X)%imp     <span class="built_in">as</span> c1.</span><br><span class="line">  <span class="built_in">remember</span> (X ::= X + <span class="number">1</span>;;</span><br><span class="line">            Y ::= X + <span class="number">1</span>)%imp <span class="built_in">as</span> c2.</span><br><span class="line">  <span class="built_in">assert</span> (cequiv c1 c2) <span class="built_in">by</span> (<span class="built_in">subst</span>; <span class="built_in">apply</span> Contra).</span><br><span class="line">  </span><br><span class="line"><span class="comment">(* =&gt; *)</span>  Heqc1 : c1 = (X ::= X + <span class="number">1</span>;; Y ::= X)%imp</span><br><span class="line">          Heqc2 : c2 = (X ::= X + <span class="number">1</span>;; Y ::= X + <span class="number">1</span>)%imp</span><br><span class="line">          H : cequiv c1 c2</span><br><span class="line">          ============================</span><br><span class="line">          False</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">(** 给出他们将 eval 出不同的 heap **)</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">remember</span> (Y !-&gt; <span class="number">1</span> ; X !-&gt; <span class="number">1</span>) <span class="built_in">as</span> st1.</span><br><span class="line">  <span class="built_in">remember</span> (Y !-&gt; <span class="number">2</span> ; X !-&gt; <span class="number">1</span>) <span class="built_in">as</span> st2.</span><br><span class="line">  <span class="built_in">assert</span> (H1 : empty_st =[ c1 ]=&gt; st1);</span><br><span class="line">  <span class="built_in">assert</span> (H2 : empty_st =[ c2 ]=&gt; st2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">apply</span> H <span class="built_in">in</span> H1. <span class="comment">(** 使用 H : cequiv c1 c2 , 我们得到 **)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">(* =&gt; *)</span>  H1 : empty_st =[ c2 ]=&gt; st1</span><br><span class="line">          H2 : empty_st =[ c2 ]=&gt; st2</span><br><span class="line">          ============================</span><br><span class="line">          False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">(** 利用 ceval 的 deterministic **)</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span> (Hcontra : st1 = st2)</span><br><span class="line">    <span class="built_in">by</span> (<span class="built_in">apply</span> (ceval_deterministic c2 empty_st); <span class="built_in">assumption</span>).</span><br><span class="line">    </span><br><span class="line"><span class="comment">(* =&gt; *)</span>  Hcontra : st1 = st2</span><br><span class="line">          ============================</span><br><span class="line">          False</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">(** st1, st2 are map, which are actually function! </span></span><br><span class="line"><span class="comment">    这时我们可以反用 functional extenionality，直接 apply Y 然后 discrinminate **)</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span> (Hcontra&#x27; : st1 Y = st2 Y)</span><br><span class="line">    <span class="built_in">by</span> (<span class="built_in">rewrite</span> Hcontra; <span class="built_in">reflexivity</span>).</span><br><span class="line">  <span class="built_in">subst</span>. <span class="built_in">inversion</span> Hcontra&#x27;.  <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>




<h2 id="Extended-Exercise-Nondeterministic-Imp"><a href="#Extended-Exercise-Nondeterministic-Imp" class="headerlink" title="Extended Exercise: Nondeterministic Imp "></a>Extended Exercise: Nondeterministic Imp </h2><blockquote>
<p>HAVOC roughly corresponds to an <em>uninitialized variable</em> in a low-level language like C.<br>After the HAVOC, the variable holds a fixed but arbitrary number.</p>
</blockquote>
<p>我们增加一个 <code>HAVOC X</code> 语句（大灾难），会为 X 随机赋一个值…类似于「未初始化变量」</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> com : <span class="keyword">Type</span> :=</span><br><span class="line">  ...</span><br><span class="line">  | <span class="type">CHavoc</span> : string → com. <span class="comment">(* &lt;--- 新增 *)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;&#x27;HAVOC&#x27; l&quot;</span> :=</span><br><span class="line">  (CHavoc l) (<span class="built_in">at</span> level <span class="number">60</span>) : imp_scope.</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">Inductive</span> ceval : com -&gt; state -&gt; state -&gt; <span class="keyword">Prop</span> :=</span><br><span class="line">  ...</span><br><span class="line">  | <span class="type">E_Havoc</span> : <span class="keyword">forall</span> st (n : nat) x,</span><br><span class="line">      st =[ HAVOC x ]=&gt; (x !-&gt; n)        <span class="comment">(** can eval to arbitraty heap **)</span></span><br></pre></td></tr></table></figure>






<hr>
<h1 id="Small-Step"><a href="#Small-Step" class="headerlink" title="Small-Step"></a>Small-Step</h1><h2 id="deterministic"><a href="#deterministic" class="headerlink" title="deterministic"></a>deterministic</h2><p>also the def of partial function?</p>
<p><code>solve_by_inverts</code></p>
<p>in LTac. (used to generate proof)<br>LTac doesn’t have <em>termination check</em>. (might not be able to find…)</p>
<p><code>match</code> is back-tracking point.</p>
<p>number passing in &#x3D; depth of the iteration&#x2F;recursion</p>
<hr>
<p><code>ST_Plus2</code> need <code>value v1</code>. not redundant with <code>ST_Plus1</code><br>we might have things not <code>value</code> but cannot take step as well.</p>
<hr>
<p>Strong Progress</p>
<p>Normal form</p>
<p>&#x3D; no relation related to (so cannot step to)</p>
<p>vs Value…</p>
<p><code>destruct (apply t)</code>.<br>can we do that?</p>
<hr>
<p>Slide Q&amp;A.</p>
<p>value_not_sae_as normal_form</p>
<p>e.g (1+2) + 7<br>e.g. 3 + 7</p>
<hr>
<p>One-step</p>
<ul>
<li>plus</li>
<li>left  + 0</li>
<li>right + 0</li>
</ul>
<p>Inf-step -&gt; Inf terms</p>
<p>go from 3 to <code>3+0</code></p>
<hr>
<p>Stuck</p>
<p>No StepR</p>
<p>0 term can step into</p>
<hr>
<p>Multi-Step Reduction <code>-&gt;*</code></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> multi &#123;X : <span class="keyword">Type</span>&#125; (R : relation X) : relation X :=</span><br><span class="line">  | <span class="type">multi_refl</span> : ∀(x : X), multi R x x</span><br><span class="line">  | <span class="type">multi_step</span> : ∀(x y z : X),</span><br><span class="line">                    R x y →</span><br><span class="line">                    multi R y z →</span><br><span class="line">                    multi R x z.</span><br></pre></td></tr></table></figure>


<p>can be either defined as a “head + tail” style (or “tail + head” style), or “refl + trans” style (as in <code>Rel.v</code>).</p>
<p>the <code>trans</code> relation are underteministic  in terms of the transtive relation using. (you can throw infinitely many <code>trans</code> constructors in)</p>
<blockquote>
<p>having multiple form so we can jump back and forth to pick one easier for proof.</p>
</blockquote>
<hr>
<p>PLT PM lang</p>
<p>multiple smallstep relation can be markded deepner state.qjw<br>er state.</p>
<hr>
<p>IMP</p>
<p><code>astep</code> no need for &#96;value&#96;&#96;</p>
<p>for <code>If</code>, in PLT we have 2 rules for T&#x2F;F.<br>here we can compute…</p>
<hr>
<p>Par w&#x2F;o Concurrency is deterministic<br>(not vice versa)</p>
<p>suddenly <code>/ -&gt;* /</code> tuple</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_plf/2019-03-05-sf-plf-05-smallstep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_plf/2019-03-05-sf-plf-05-smallstep/" class="post-title-link" itemprop="url">「SF-PLF」5 Smallstep</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Recall-Big-step-Pros-Cons"><a href="#Recall-Big-step-Pros-Cons" class="headerlink" title="Recall Big-step Pros &amp; Cons"></a>Recall Big-step Pros &amp; Cons</h2><h2 id="Big-step"><a href="#Big-step" class="headerlink" title="Big-step"></a>Big-step</h2><blockquote>
<p>一步到位 :  <em>eval to its final value (plus final store)</em> </p>
</blockquote>
<h3 id="Pros-natural-so-called-natural-semantics-“all-in-one-big-step”"><a href="#Pros-natural-so-called-natural-semantics-“all-in-one-big-step”" class="headerlink" title="Pros - natural (so called natural semantics), “all in one big step”"></a>Pros - natural (so called <em>natural semantics</em>), “all in one big step”</h3><h3 id="Cons-not-catch-the-essence-of-how-program-behave"><a href="#Cons-not-catch-the-essence-of-how-program-behave" class="headerlink" title="Cons - not catch the essence of how program behave"></a>Cons - not catch the <em>essence of how program behave</em></h3><blockquote>
<p>大步语义只是一个 <code>程序 ↦ 结果</code> 这样的 pair 集合，而「如何一步步处理」才是程序「执行」的本质</p>
</blockquote>
<p>not just input state get mapped to output state.<br>but also <em>intermediate state</em> (which could be observed by <em>concurrent</em> code!)</p>
<h3 id="Cons-not-technically-expressive-enough-to-express-exception-crash-non-termination"><a href="#Cons-not-technically-expressive-enough-to-express-exception-crash-non-termination" class="headerlink" title="Cons - not technically expressive enough to express exception &#x2F; crash &#x2F; non-termination"></a>Cons - not technically expressive enough to express <em>exception &#x2F; crash &#x2F; non-termination</em></h3><blockquote>
<p>比如说，大步语义无法区分「不停机」与「卡住」<br>two quite different reasons of “fail to map a given state to any ending state”</p>
</blockquote>
<ol>
<li>不停机 nontermination - we want to allow this (infinite loop is the price paid for usability)</li>
<li>卡住 getting stuck &#x2F; undefiend behaviour 未定义行为  - we want to prevent (wrong)</li>
</ol>
<ul>
<li><code>WHILE_true_nonterm</code> 仅仅表达了「程序不能再 take step」，无法与「卡住」区分</li>
<li><code>WHILE_true</code> 更是直接让任何「无限循环」的程序都「等价」了…而忽略了中间状态和 effect (作用)</li>
</ul>
<blockquote>
<p>we need <em>a way of presenting semantics that distinguish</em> nontermination from erroneous “stuck states”</p>
</blockquote>
<h2 id="Small-step"><a href="#Small-step" class="headerlink" title="Small-step"></a>Small-step</h2><blockquote>
<p>更精细化 :  a <em>finer-grained</em> way of defining and reasoning about program behaviors.<br>原子步骤 :  <em>“atomic steps”</em> of computation are performed. </p>
</blockquote>
<h2 id="A-Toy-Language"><a href="#A-Toy-Language" class="headerlink" title="A Toy Language"></a>A Toy Language</h2><p>Only Constant and Plus</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> tm : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">C</span> : nat → tm <span class="comment">(* Constant *)</span></span><br><span class="line">  | <span class="type">P</span> : tm → tm → tm. <span class="comment">(* Plus *)</span></span><br></pre></td></tr></table></figure>
<h3 id="Big-Step"><a href="#Big-Step" class="headerlink" title="Big-Step"></a>Big-Step</h3><p><code>==&gt;</code> is really <code>⇓</code></p>
<pre><code>            ---------        (E_Const)
            C n ==&gt; n

            t1 ==&gt; n1
            t2 ==&gt; n2
        -------------------  (E_Plus)
        P t1 t2 ==&gt; n1 + n2
</code></pre>
<h3 id="Small-Step"><a href="#Small-Step" class="headerlink" title="Small-Step"></a>Small-Step</h3><blockquote>
<p>single reduction step<br>find leftmost redex</p>
</blockquote>
<pre><code>  -------------------------------   (ST_PlusConstConst)
  P (C n1) (C n2) --&gt; C (n1 + n2)

          t1 --&gt; t1&#39;
      --------------------          (ST_Plus1)
      P t1 t2 --&gt; P t1&#39; t2

          t2 --&gt; t2&#39;
  ----------------------------      (ST_Plus2)
  P (C n1) t2 --&gt; P (C n1) t2&#39;
</code></pre>
<h2 id="Relations"><a href="#Relations" class="headerlink" title="Relations"></a>Relations</h2><blockquote>
<p>Check notes of <code>rel</code> and <code>tactics</code> for more details about bi-relation.</p>
</blockquote>
<h3 id="Deterministic-确定性"><a href="#Deterministic-确定性" class="headerlink" title="Deterministic 确定性"></a>Deterministic 确定性</h3><blockquote>
<p>a.k.a Partial Function.<br>in terms of its <em>right uniqueness</em> under mathematical context, not its emphasise on <em>partial</em> under programming context)</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> deterministic &#123;X : <span class="keyword">Type</span>&#125; (R : relation X) :=</span><br><span class="line">  ∀x y1 y2 : X, R x y1 → R x y2 → y1 = y2.</span><br></pre></td></tr></table></figure>

<p><code>deterministic step</code> can be proved by induction on derivation <code>x --&gt; y1</code> </p>
<ul>
<li>use <code>generalize dependent y2</code>!</li>
<li>in informal proof, we usually just take <code>∀ y2</code> by default.</li>
</ul>
<h3 id="Ltac-solve-by-inverts-n"><a href="#Ltac-solve-by-inverts-n" class="headerlink" title="Ltac solve_by_inverts n"></a><code>Ltac solve_by_inverts n</code></h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Ltac</span> solve_by_inverts n :=</span><br><span class="line">  <span class="keyword">match</span> goal <span class="built_in">with</span> | <span class="type">H</span> : ?T ⊢ <span class="keyword">_</span> ⇒</span><br><span class="line">  <span class="keyword">match</span> type of T <span class="built_in">with</span> <span class="keyword">Prop</span> ⇒</span><br><span class="line">    <span class="built_in">solve</span> [</span><br><span class="line">      <span class="built_in">inversion</span> H;</span><br><span class="line">      <span class="keyword">match</span> n <span class="built_in">with</span> S (S (?n&#x27;)) ⇒ <span class="built_in">subst</span>; solve_by_inverts (S n&#x27;) <span class="keyword">end</span> ]</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>


<h3 id="Values-值"><a href="#Values-值" class="headerlink" title="Values 值"></a>Values 值</h3><h4 id="Abstract-Machine-抽象机"><a href="#Abstract-Machine-抽象机" class="headerlink" title="Abstract Machine 抽象机!"></a>Abstract Machine 抽象机!</h4><blockquote>
<p>think of the <code>--&gt;</code> relation as defining an <em>abstract machine</em>:</p>
</blockquote>
<ul>
<li>term &#x3D; <em>state</em> of machine 项 &#x3D; 机器状态</li>
<li>step &#x3D; atomic unit of computation (think as assembly opcode &#x2F; CPU instructrion)</li>
<li><em>halting state</em> &#x3D; no more computation. 停机状态</li>
</ul>
<blockquote>
<p>execute a term <code>t</code>:</p>
</blockquote>
<ul>
<li>starting state &#x3D; <code>t</code></li>
<li>repeatedly use <code>--&gt;</code> </li>
<li>when halt, <em>read out</em> the <em>final state</em> as result of execution</li>
</ul>
<blockquote>
<p>Intutively, we call such (final state) terms <em>values</em>.<br>Okay so the point is…this language is simple enough (no stuck state).<br>and in this lang, value can only be <code>C</code>onst:</p>
</blockquote>
<blockquote>
<p>在这个语言中，我们「规定」只有 <code>C</code>onst 是「值」:</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> value : tm → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">v_const</span> : ∀n, value (C n).</span><br></pre></td></tr></table></figure>

<blockquote>
<p>and we can write <code>ST_Plus2</code> more elegant:<br>well…in this lang, not really, since only one form of value to write out.<br>in cases we have multiple form of value, by doing this we don’t have to write out any cases.</p>
</blockquote>
<pre><code>         value v1
        t2 --&gt; t2&#39;
    --------------------  (ST_Plus2)
    P v1 t2 --&gt; P v1 t2&#39;
</code></pre>
<h3 id="Strong-Progress-and-Normal-Forms-强可进性和正规式"><a href="#Strong-Progress-and-Normal-Forms-强可进性和正规式" class="headerlink" title="Strong Progress and Normal Forms 强可进性和正规式"></a>Strong Progress and Normal Forms 强可进性和正规式</h3><blockquote>
<p><em>strong progress</em>: every term either is a value or can “make progress”</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> strong_progress : ∀t,</span><br><span class="line">  value t ∨ (∃t&#x27;, t --&gt; t&#x27;).</span><br></pre></td></tr></table></figure>


<blockquote>
<p>terms that cannot make progress.<br>for an arbitrary relation <code>R</code> over an arbitrary set <code>X</code></p>
</blockquote>
<blockquote>
<p><em>normal form</em>: term that cannot make progress (take a step)<br>其实我个人比较喜欢理解为「常态」或「无能量稳定态」</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> normal_form &#123;X : <span class="keyword">Type</span>&#125; (R : relation X) (t : X) : <span class="keyword">Prop</span> :=</span><br><span class="line">  ¬∃t&#x27;, R t t&#x27;.</span><br></pre></td></tr></table></figure>


<blockquote>
<p>theorem: <em>in this language</em>, normal forms and values are actually the same thing. </p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> value_is_nf : v, value v → normal_form step v.</span><br><span class="line"><span class="keyword">Lemma</span> nf_is_value : ∀t, normal_form step t → value t.</span><br><span class="line"><span class="keyword">Corollary</span> nf_same_as_value : ∀t, normal_form step t ↔ value t.</span><br></pre></td></tr></table></figure>


<h4 id="Value-Normal-Form-not-always"><a href="#Value-Normal-Form-not-always" class="headerlink" title="Value !&#x3D; Normal Form (not always)"></a>Value !&#x3D; Normal Form (not always)</h4><blockquote>
<p>value       is a <em>syntactic</em> concept : it is defined by looking at the form of a term<br>normal form is a <em>semantic</em>  one     : it is defined by looking at how the term steps.</p>
</blockquote>
<blockquote>
<p>E.g. we can defined term that can take a step as “value”:<br>添加一个不是 normal form 的 value</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> value : tm → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">v_const</span> : ∀n, value (C n)</span><br><span class="line">  | <span class="type">v_funny</span> : ∀t1 n2, value (P t1 (C n2)). <span class="comment">(* &lt;--- it can actually progress! *)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者更改 <code>step</code> 让 value 不是 normal form…</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> step : tm -&gt; tm -&gt; <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">ST_Funny</span> : <span class="keyword">forall</span> n,   </span><br><span class="line">      C n --&gt; P (C n) (C <span class="number">0</span>)                <span class="comment">(* &lt;--- or a weird  *)</span></span><br></pre></td></tr></table></figure>








<h2 id="Multi-Step-Reduction-多步规约"><a href="#Multi-Step-Reduction-多步规约" class="headerlink" title="Multi-Step Reduction --&gt;* 多步规约"></a>Multi-Step Reduction <code>--&gt;*</code> 多步规约</h2><blockquote>
<p>relation <code>multi R</code>: <em>multi-step closure of R</em><br>same as <code>clos_refl_trans_1n</code> in <code>Rel</code> chapter.</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> multi &#123;X : <span class="keyword">Type</span>&#125; (R : relation X) : relation X :=</span><br><span class="line">  | <span class="type">multi_refl</span> : ∀(x : X), multi R x x</span><br><span class="line">  | <span class="type">multi_step</span> : ∀(x y z : X),</span><br><span class="line">                    R x y →</span><br><span class="line">                    multi R y z →</span><br><span class="line">                    multi R x z.</span><br></pre></td></tr></table></figure>

<p>以上是一种方便的定义，而以下则给了我们两个 helper 定理：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> multi_R : ∀(X : <span class="keyword">Type</span>) (R : relation X) (x y : X),</span><br><span class="line">    R x y → </span><br><span class="line">    multi R x y.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Theorem</span> multi_trans : ∀(X : <span class="keyword">Type</span>) (R : relation X) (x y z : X),</span><br><span class="line">    multi R x y →</span><br><span class="line">    multi R y z →</span><br><span class="line">    multi R x z.</span><br></pre></td></tr></table></figure>


<h3 id="Normal-Forms-Again"><a href="#Normal-Forms-Again" class="headerlink" title="Normal Forms Again"></a>Normal Forms Again</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> step_normal_form := normal_form step.  <span class="comment">(** 这个是一个「性质」 Property : _ -&gt; Prop , 从 polymorphic 的 [normal_form] 以 [step] 实例化而来 **)</span> </span><br><span class="line"><span class="keyword">Definition</span> normal_form_of (t t&#x27; : tm) :=          <span class="comment">(** 是两个项之间的（i.e. 定义在 [tm] 集合上的) 二元关系, 即 t&#x27; 是 t 的正规式 **)</span></span><br><span class="line">  (t --&gt;* t&#x27; ∧ step_normal_form t&#x27;).</span><br><span class="line">  </span><br><span class="line"><span class="keyword">Theorem</span> normal_forms_unique:                      <span class="comment">(** single-step reduction is deterministic 可以推出 normal form is unique for a given term **)</span></span><br><span class="line">  deterministic normal_form_of.</span><br></pre></td></tr></table></figure>


<h3 id="Normalizing-总是可正规化得-–-“Evaluating-to-completion”"><a href="#Normalizing-总是可正规化得-–-“Evaluating-to-completion”" class="headerlink" title="Normalizing 总是可正规化得  – “Evaluating to completion”"></a>Normalizing 总是可正规化得  – “Evaluating to completion”</h3><blockquote>
<p>something stronger is true for this language (though not for all languages)<br>reduction of <em>any</em> term <code>t</code> will eventually reach a normal form (我们知道 STLC 也有这个特性)</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> normalizing &#123;X : <span class="keyword">Type</span>&#125; (R : relation X) :=</span><br><span class="line">  ∀t, ∃t&#x27;,</span><br><span class="line">    (multi R) t t&#x27; ∧ normal_form R t&#x27;.</span><br></pre></td></tr></table></figure>

<p>To prove this, we need lemma showing some <em>congruence</em> of <code>--&gt;*</code>:<br>同余关系，不过这次是定义在 <code>--&gt;*</code> 这个关系上，again，同余指的是「关系对于结构上的操作保持」</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> multistep_congr_1 : ∀t1 t1&#x27; t2,</span><br><span class="line">     t1 --&gt;* t1&#x27; → </span><br><span class="line">     P t1 t2 --&gt;* P t1&#x27; t2.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Lemma</span> multistep_congr_2 : ∀t1 t2 t2&#x27;,</span><br><span class="line">     value t1 →</span><br><span class="line">     t2 --&gt;* t2&#x27; →</span><br><span class="line">     P t1 t2 --&gt;* P t1 t2&#x27;.</span><br></pre></td></tr></table></figure>

<p>Then we can prove…</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> step_normalizing :</span><br><span class="line">  normalizing step.</span><br></pre></td></tr></table></figure>



<h3 id="Equivalence-of-Big-Step-and-Small-Step"><a href="#Equivalence-of-Big-Step-and-Small-Step" class="headerlink" title="Equivalence of Big-Step and Small-Step"></a>Equivalence of Big-Step and Small-Step</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> eval__multistep : ∀t n,</span><br><span class="line">  t ==&gt; n → t --&gt;* C n.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Theorem</span> multistep__eval : ∀t t&#x27;,</span><br><span class="line">  normal_form_of t t&#x27; → ∃n, t&#x27; = C n ∧ t ==&gt; n.    <span class="comment">(* might be better to say value here? *)</span></span><br></pre></td></tr></table></figure>




<h2 id="Additional-Combined-Language"><a href="#Additional-Combined-Language" class="headerlink" title="Additional: Combined Language"></a>Additional: Combined Language</h2><p>What if we combined the lang <code>Arith</code> and lang <code>Boolean</code>?<br>Would <code>step_deterministic</code> and <code>strong_progress</code> still holds?</p>
<p>Intuition:</p>
<ul>
<li><code>step_deterministic</code> should still hold</li>
<li>but <code>strong_progress</code> would definitely not!!<ul>
<li>now we mixed two <em>types</em> so we will have stuck terms e.g. <code>test 5</code> or <code>tru + 4</code>.</li>
<li>we will need type check and then we would be able to prove <code>progress</code> (which require well-typeness)</li>
</ul>
</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> strong_progress :</span><br><span class="line">  (<span class="keyword">forall</span> t, value t \/ (<span class="built_in">exists</span> t&#x27;, t --&gt; t&#x27;)) \/</span><br><span class="line">  ~ (<span class="keyword">forall</span> t, value t \/ (<span class="built_in">exists</span> t&#x27;, t --&gt; t&#x27;)).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">right</span>. <span class="built_in">intros</span> Hcontra.</span><br><span class="line">  <span class="built_in">remember</span> (P tru fls) <span class="built_in">as</span> stuck.   <span class="comment">(** 类似 disprove equiv = 举一个反例就好 **)</span></span><br><span class="line">  <span class="built_in">specialize</span> (Hcontra stuck).</span><br><span class="line">  <span class="built_in">destruct</span> Hcontra <span class="built_in">as</span> [Hcvalue | <span class="type">Hcprogress</span>]; <span class="built_in">subst</span>.</span><br><span class="line">  - <span class="built_in">inversion</span> Hcvalue; <span class="built_in">inversion</span> H.</span><br><span class="line">  - <span class="built_in">destruct</span> Hcprogress. <span class="built_in">inversion</span> H. <span class="built_in">inversion</span> H3. <span class="built_in">inversion</span> H4.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>





<h2 id="Small-Step-IMP"><a href="#Small-Step-IMP" class="headerlink" title="Small-Step IMP "></a>Small-Step IMP </h2><p>又到了老朋友 IMP……还好没练习……简单看一下</p>
<p>首先对于定义小步语义，我们需要定义 <code>value</code> 和 <code>--&gt;</code> (step)</p>
<h3 id="aexp-bexp"><a href="#aexp-bexp" class="headerlink" title="aexp, bexp"></a><code>aexp</code>, <code>bexp</code></h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> aval : aexp → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">av_num</span> : ∀n, aval (ANum n).</span><br></pre></td></tr></table></figure>

<p><code>bexp</code> 不需要 <code>value</code> 因为在这个语言里 <code>BTrue</code> 和 <code>BFalse</code> 的 step 总是 disjointed 得，所以并没有任何复用 <code>value</code> predicate 的时候</p>
<h3 id="a-b"><a href="#a-b" class="headerlink" title="--&gt;a, --&gt;b"></a><code>--&gt;a</code>, <code>--&gt;b</code></h3><p>这里，我们先为 <code>aexp</code>, <code>bexp</code> 定义了它们各自的小步语义，</p>
<blockquote>
<p>但是，其实 from PLT we know, 我们其实也可以直接复用 <code>aexp</code>, <code>bexp</code> 的大步语义！</p>
<ol>
<li>大步语义要短得多</li>
<li><code>aexp</code>, <code>bexp</code> 其实并不会出</li>
</ol>
<ul>
<li>「不停机」: 没有 jump 等控制流结构</li>
<li>「异常」&#x2F;「卡住」: 我们在 meta-language 的 AST 里就区分了 <code>aexp</code> 和 <code>bexp</code>，相当于主动约束了类型，所以不会出现 <code>5 || 3</code> 这样 type error 的 AST</li>
</ul>
</blockquote>
<h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd, --&gt;"></a><code>cmd</code>, <code>--&gt;</code></h3><blockquote>
<p>我们把 <code>SKIP</code> 当作一个「命令值（command value）」 i.e. 一个已经到达 normal form 的命令。</p>
<ul>
<li>赋值命令归约到 <code>SKIP</code> （和一个新的 state）。</li>
<li>顺序命令等待其左侧子命令归约到 <code>SKIP</code>，然后丢弃它，并继续对右侧子命令归约。</li>
</ul>
</blockquote>
<blockquote>
<p>对 <code>WHILE</code> 命令的归约是把 <code>WHILE</code> 命令变换为条件语句，其后紧跟同一个 <code>WHILE</code> 命令。</p>
</blockquote>
<blockquote>
<p>这些都与 PLT 是一致的</p>
</blockquote>
<h2 id="Concurrent-IMP"><a href="#Concurrent-IMP" class="headerlink" title="Concurrent IMP"></a>Concurrent IMP</h2><p>为了展示 小步语义 的能力，let’s enrich IMP with concurrency.</p>
<ul>
<li>unpredictable scheduling (subcommands may be <em>interleaved</em>)</li>
<li><em>share same memory</em></li>
</ul>
<p>It’s slightly confusing here to use <code>Par</code> (meaning <em>in parallel</em>)<br>I mean, concurrency <em>could</em> be in parallel but it doesn’t have to…</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> com : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">CPar</span> : com → com → com. <span class="comment">(* &lt;--- NEW *)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Inductive</span> cstep : (com * state) → (com * state) → <span class="keyword">Prop</span> :=</span><br><span class="line">  <span class="comment">(* New part: *)</span></span><br><span class="line">  | <span class="type">CS_Par1</span> : ∀st c1 c1&#x27; c2 st&#x27;,</span><br><span class="line">      c1 / st --&gt; c1&#x27; / st&#x27; →</span><br><span class="line">      (PAR c1 WITH c2 END) / st --&gt; (PAR c1&#x27; WITH c2 END) / st&#x27;</span><br><span class="line">  | <span class="type">CS_Par2</span> : ∀st c1 c2 c2&#x27; st&#x27;,</span><br><span class="line">      c2 / st --&gt; c2&#x27; / st&#x27; →</span><br><span class="line">      (PAR c1 WITH c2 END) / st --&gt; (PAR c1 WITH c2&#x27; END) / st&#x27;</span><br><span class="line">  | <span class="type">CS_ParDone</span> : ∀st,</span><br><span class="line">      (PAR SKIP WITH SKIP END) / st --&gt; SKIP / st</span><br></pre></td></tr></table></figure>








<h2 id="A-Small-Step-Stack-Machine-小步栈机"><a href="#A-Small-Step-Stack-Machine-小步栈机" class="headerlink" title="A Small-Step Stack Machine  小步栈机"></a>A Small-Step Stack Machine  小步栈机</h2><p>啊哈！IMP 章节 Stack Machine，我们之前仅仅定义了 <code>Fixpoint s_execute</code> 和 <code>Fixpoint s_compile</code>，这里给出其小步语义</p>
<blockquote>
<p>对于本身就与「小步语义」在精神上更统一的「抽象机」，我怀疑其语义都应该是足够「小」的（即大小步将是一致的？)</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> stack := list nat.</span><br><span class="line"><span class="keyword">Definition</span> prog  := list sinstr.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Inductive</span> stack_step : state -&gt; prog * stack -&gt; prog * stack -&gt; <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">SS_Push</span> : <span class="keyword">forall</span> st stk n p&#x27;,</span><br><span class="line">    stack_step st (SPush n :: p&#x27;, stk)      (p&#x27;, n :: stk)</span><br><span class="line">  | <span class="type">SS_Load</span> : <span class="keyword">forall</span> st stk i p&#x27;,</span><br><span class="line">    stack_step st (SLoad i :: p&#x27;, stk)      (p&#x27;, st i :: stk)</span><br><span class="line">  | <span class="type">SS_Plus</span> : <span class="keyword">forall</span> st stk n m p&#x27;,</span><br><span class="line">    stack_step st (SPlus :: p&#x27;, n::m::stk)  (p&#x27;, (m+n)::stk)</span><br><span class="line">  | <span class="type">SS_Minus</span> : <span class="keyword">forall</span> st stk n m p&#x27;,</span><br><span class="line">    stack_step st (SMinus :: p&#x27;, n::m::stk) (p&#x27;, (m-n)::stk)</span><br><span class="line">  | <span class="type">SS_Mult</span> : <span class="keyword">forall</span> st stk n m p&#x27;,</span><br><span class="line">    stack_step st (SMult :: p&#x27;, n::m::stk)  (p&#x27;, (m*n)::stk).</span><br><span class="line">    </span><br><span class="line"><span class="comment">(** closure of stack_step **)</span></span><br><span class="line"><span class="keyword">Definition</span> stack_multistep st := multi (stack_step st).</span><br></pre></td></tr></table></figure>

<h3 id="Compiler-Correctness"><a href="#Compiler-Correctness" class="headerlink" title="Compiler Correctness"></a>Compiler Correctness</h3><blockquote>
<p>「编译器的正确性」&#x3D; the notion of <em>semantics preservation</em> (in terms of observable behaviours)<br>  S  &#x3D; <code>e</code><br>  C  &#x3D; <code>s_compile e</code><br>B(S) &#x3D; <code>aeval st e</code><br>B(C) &#x3D; functional <code>s_execute</code><br>     | relational <code>stack_multistep</code> </p>
</blockquote>
<p>之前我们证明过 <em>functional&#x2F;computational</em> <code>Fixpoint</code> 的性质</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> s_compile_correct : <span class="keyword">forall</span> (st : state) (e : aexp),</span><br><span class="line">  s_execute st [] (s_compile e) = [ aeval st e ].</span><br><span class="line"></span><br><span class="line"><span class="comment">(** 重要的是这个更一般的「描述了 prog 如何与 stack 交互」的定理 **)</span></span><br><span class="line"><span class="keyword">Theorem</span> s_execute_theorem : <span class="keyword">forall</span> (st : state) (e : aexp) (stack : list nat) (prog : list sinstr),</span><br><span class="line">    s_execute st                  stack  (s_compile e ++ prog) </span><br><span class="line">  = s_execute st ((aeval st e) :: stack)                 prog.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在则是证明 <em>relational</em> <code>Inductive</code> 的性质，同样我们需要一个更一般的定理（然后原命题作为推论）</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> stack_step_theorem : <span class="keyword">forall</span> (st : state) (e : aexp) (stack : list nat) (prog : list sinstr),</span><br><span class="line">  stack_multistep st</span><br><span class="line">                  ((s_compile e ++ prog),                 stack) </span><br><span class="line">                  (                prog , (aeval st e) :: stack).      <span class="comment">(** 这里 prog 和 stack 的交互本质上和上面是一样的 **)</span></span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">unfold</span> stack_multistep.</span><br><span class="line">  <span class="built_in">induction</span> e; <span class="built_in">intros</span>; <span class="built_in">simpl</span> <span class="built_in">in</span> *;        <span class="comment">(** 证明 induction on aexp，然后利用 transivitiy、constructor 与 IH 即可，非常快 **)</span></span><br><span class="line">    <span class="built_in">try</span> (<span class="built_in">apply</span> multi_R; <span class="built_in">constructor</span>);</span><br><span class="line">    <span class="built_in">try</span> (</span><br><span class="line">        <span class="built_in">repeat</span> (<span class="built_in">rewrite</span> &lt;- app_assoc);</span><br><span class="line">        <span class="built_in">eapply</span> multi_trans; <span class="built_in">try</span> <span class="built_in">apply</span> IHe1;</span><br><span class="line">        <span class="built_in">eapply</span> multi_trans; <span class="built_in">try</span> <span class="built_in">apply</span> IHe2;</span><br><span class="line">        <span class="built_in">eapply</span> multi_R; <span class="built_in">constructor</span></span><br><span class="line">      ).</span><br><span class="line">      </span><br><span class="line"><span class="keyword">Definition</span> compiler_is_correct_statement : <span class="keyword">Prop</span> := <span class="keyword">forall</span> (st : state) (e : aexp),</span><br><span class="line">  stack_multistep st (s_compile e, []) ([], [aeval st e]).</span><br></pre></td></tr></table></figure>






<h2 id="Aside-A-normalize-Tactic"><a href="#Aside-A-normalize-Tactic" class="headerlink" title="Aside: A normalize Tactic"></a>Aside: A <code>normalize</code> Tactic</h2><p>Even with <code>eapply</code> and <code>auto</code>…manual normalization is tedious:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> step_example1&#x27; :</span><br><span class="line">  (P (C <span class="number">3</span>) (P (C <span class="number">3</span>) (C <span class="number">4</span>)))</span><br><span class="line">  --&gt;* (C <span class="number">10</span>).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">eapply</span> multi_step. <span class="built_in">auto</span>. <span class="built_in">simpl</span>.</span><br><span class="line">  <span class="built_in">eapply</span> multi_step. <span class="built_in">auto</span>. <span class="built_in">simpl</span>.</span><br><span class="line">  <span class="built_in">apply</span> multi_refl.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>We could write custom <code>Tactic Notation</code>…(i.e. tactic macros)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Tactic</span> <span class="keyword">Notation</span> <span class="string">&quot;print_goal&quot;</span> :=</span><br><span class="line">  <span class="keyword">match</span> goal <span class="built_in">with</span> ⊢ ?x ⇒ <span class="built_in">idtac</span> x <span class="keyword">end</span>.</span><br><span class="line">  </span><br><span class="line"><span class="keyword">Tactic</span> <span class="keyword">Notation</span> <span class="string">&quot;normalize&quot;</span> :=</span><br><span class="line">  <span class="built_in">repeat</span> (print_goal; <span class="built_in">eapply</span> multi_step ;</span><br><span class="line">            [ (<span class="built_in">eauto</span> <span class="number">10</span>; <span class="built_in">fail</span>) | <span class="type">(instantiate</span>; <span class="built_in">simpl</span>)]);</span><br><span class="line">  <span class="built_in">apply</span> multi_refl.</span><br></pre></td></tr></table></figure>

<p><code>instantiate</code> seems here for intros <code>∃</code>?</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> step_example1&#x27;&#x27;&#x27; : <span class="built_in">exists</span> e&#x27;,</span><br><span class="line">  (P (C <span class="number">3</span>) (P (C <span class="number">3</span>) (C <span class="number">4</span>)))</span><br><span class="line">  --&gt;* e&#x27;.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">eapply</span> ex_intro. normalize.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>But what surprise me is that we can <code>eapply ex_intro</code>, which leave the <code>∃</code> as a hole <code>?ex</code> (unification variable).</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_plf/2019-03-06-sf-plf-06-types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_plf/2019-03-06-sf-plf-06-types/" class="post-title-link" itemprop="url">「SF-PLF」6 Types</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>This chapter:</p>
<ul>
<li>typing relation                                             – 定型关系</li>
<li><code>type preservation</code> and <code>progress</code> (i.e. soundness proof)   – 类型保留，可进性</li>
</ul>
<h2 id="Typed-Arithmetic-Expressions-Toy-Typed-Language"><a href="#Typed-Arithmetic-Expressions-Toy-Typed-Language" class="headerlink" title="Typed Arithmetic Expressions (Toy Typed Language)"></a>Typed Arithmetic Expressions (Toy Typed Language)</h2><p>The toy lang from <code>SmallStep</code> is too “safe” to demonstrate any <strong>runtime (or dynamic) type errors</strong>.  – 运行时类型错误<br>So that’s add some operations (common church numeral ones), and <code>bool</code> type.</p>
<p>…same teaching order as TAPL. In PLT, we went directly to STLC.</p>
<h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t ::= tru | <span class="type">fls</span> | <span class="type">test</span> t <span class="keyword">then</span> t <span class="keyword">else</span> t | <span class="type">zro</span> | <span class="type">scc</span> t | <span class="type">prd</span> t | <span class="type">iszro</span> t</span><br></pre></td></tr></table></figure>

<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> tm : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">tru</span> : tm</span><br><span class="line">  | <span class="type">fls</span> : tm</span><br><span class="line">  | <span class="type">test</span> : tm → tm → tm → tm</span><br><span class="line">  | <span class="type">zro</span> : tm</span><br><span class="line">  | <span class="type">scc</span> : tm → tm</span><br><span class="line">  | <span class="type">prd</span> : tm → tm</span><br><span class="line">  | <span class="type">iszro</span> : tm → tm.</span><br><span class="line"></span><br><span class="line"><span class="comment">(* object language has its own bool / nat , 这里不使用 Coq (meta-language) 比较 pure 一些? *)</span></span><br><span class="line"><span class="keyword">Inductive</span> bvalue : tm → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">bv_tru</span> : bvalue tru</span><br><span class="line">  | <span class="type">bv_fls</span> : bvalue fls.</span><br><span class="line"><span class="keyword">Inductive</span> nvalue : tm → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">nv_zro</span> : nvalue zro</span><br><span class="line">  | <span class="type">nv_scc</span> : ∀t, nvalue t → nvalue (scc t).  <span class="comment">(** 注意这里 nv_scc 是描述所有 [scc t] 是 nvalue 的一个 constructor / tag **)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* [value?] predicate *)</span></span><br><span class="line"><span class="keyword">Definition</span> value (t : tm) := bvalue t ∨ nvalue t.</span><br></pre></td></tr></table></figure>


<h3 id="Automation"><a href="#Automation" class="headerlink" title="Automation"></a>Automation</h3><p><code>Hint</code> are added to database to help with <code>auto</code>.<br>More details on <code>auto. eapply. eauto.</code> were mentioned in <code>lf/Auto</code>.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Hint</span> <span class="keyword">Constructors</span> bvalue nvalue.</span><br><span class="line"><span class="keyword">Hint</span> <span class="keyword">Unfold</span> value.</span><br><span class="line"><span class="keyword">Hint</span> <span class="keyword">Unfold</span> update.</span><br></pre></td></tr></table></figure>


<h3 id="S-O-S"><a href="#S-O-S" class="headerlink" title="S.O.S"></a>S.O.S</h3><p>Small-step operational semantics…<br>can be made formally in Coq code:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Reserved</span> <span class="keyword">Notation</span> <span class="string">&quot;t1 &#x27;--&gt;&#x27; t2&quot;</span> (<span class="built_in">at</span> level <span class="number">40</span>).</span><br><span class="line"><span class="keyword">Inductive</span> step : tm → tm → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">ST_TestTru</span> : ∀t1 t2,</span><br><span class="line">      (test tru t1 t2) --&gt; t1</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>



<h3 id="“is-stuck”-vs-“can-get-stuck”-卡住的项-vs-将会卡住的项"><a href="#“is-stuck”-vs-“can-get-stuck”-卡住的项-vs-将会卡住的项" class="headerlink" title="“is stuck” vs. “can get stuck”  卡住的项 vs. 将会卡住的项"></a>“is stuck” vs. “can get stuck”  卡住的项 vs. 将会卡住的项</h3><p>Noticed that the small-step semantics doesn’t care about if some term would eventually get stuck.</p>
<h3 id="Normal-Forms-and-Values"><a href="#Normal-Forms-and-Values" class="headerlink" title="Normal Forms and Values"></a>Normal Forms and Values</h3><blockquote>
<p>因为这个语言有 stuck 的情况，所以 <code>value != normal form</code> (terms cannot make progress)<br><code>possible_results_of_reduction = value | stuck</code> </p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Notation</span> step_normal_form := (normal_form step).</span><br><span class="line"><span class="keyword">Definition</span> stuck (t : tm) : <span class="keyword">Prop</span> :=</span><br><span class="line">  step_normal_form t ∧ ¬value t.</span><br></pre></td></tr></table></figure>


<h3 id="Slide-Q-A-1"><a href="#Slide-Q-A-1" class="headerlink" title="Slide Q&amp;A 1"></a>Slide Q&amp;A 1</h3><ol>
<li>Yes</li>
<li>No   <code>scc zro</code> is a value</li>
<li>No   is a value</li>
</ol>
<h3 id="Typing"><a href="#Typing" class="headerlink" title="Typing"></a>Typing</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> ty : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">Bool</span> : ty</span><br><span class="line">  | <span class="type">Nat</span> : ty.</span><br></pre></td></tr></table></figure>

<p>Noticed that it’s just a non-dependently-typed ADT, but <code>: ty</code> is written explcitly here…they are the same!</p>
<h3 id="Typing-Relations"><a href="#Typing-Relations" class="headerlink" title="Typing Relations"></a>Typing Relations</h3><p>okay the funny thing…<br>it make sense to use <code>∈</code> here since <code>:</code> has been used by Coq.<br>but this notation is actually represented as <code>\in</code>.<br>We suddenly switch to LaTex mode…</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Reserved</span> <span class="keyword">Notation</span> <span class="string">&quot;&#x27;|-&#x27; t &#x27;\in&#x27; T&quot;</span> (<span class="built_in">at</span> level <span class="number">40</span>).</span><br></pre></td></tr></table></figure>

<p>Noticed the generic <code>T</code> here.<br>In PLT we sometimes treat them as “magic” <em>meta variable</em>, here we need to make the <code>T</code> explcit (we are in the meta-language).</p>
<pre><code>⊢ t1 ∈ Bool    ⊢ t2 ∈ T    ⊢ t3 ∈ T	
----------------------------------  (T_Test)
  ⊢ test t1 then t2 else t3 ∈ T
</code></pre>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| <span class="type">T_Test</span> : ∀t1 t2 t3 T,     <span class="comment">(** &lt;--- explicit ∀ T **)</span></span><br><span class="line">       ⊢ t1 ∈ Bool →</span><br><span class="line">       ⊢ t2 ∈ T →</span><br><span class="line">       ⊢ t3 ∈ T →</span><br><span class="line">       ⊢ test t1 t2 t3 ∈ T</span><br></pre></td></tr></table></figure>

<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> has_type_1 :</span><br><span class="line">  ⊢ test fls zro (scc zro) ∈ Nat.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">apply</span> T_Test.      <span class="comment">(** &lt;--- we already know [T] from the return type [Nat] **)</span></span><br><span class="line">    - <span class="built_in">apply</span> T_Fls.   <span class="comment">(** ⊢ _ ∈ Bool **)</span></span><br><span class="line">    - <span class="built_in">apply</span> T_Zro.   <span class="comment">(** ⊢ _ ∈ Nat  **)</span></span><br><span class="line">    - <span class="built_in">apply</span> T_Scc.   <span class="comment">(** ⊢ _ ∈ Nat  **)</span></span><br><span class="line">       + <span class="built_in">apply</span> T_Zro.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>(Since we’ve included all the constructors of the typing relation in the hint database, the <code>auto</code> tactic can actually find this proof automatically.)</p>
</blockquote>
<h4 id="typing-relation-is-a-conservative-or-static-approximation"><a href="#typing-relation-is-a-conservative-or-static-approximation" class="headerlink" title="typing relation is a conservative (or static) approximation"></a>typing relation is a conservative (or static) approximation</h4><blockquote>
<p>类型关系是一个保守的（或静态的）近似</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> has_type_not :</span><br><span class="line">  ¬( ⊢ test fls zro tru ∈ Bool ).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> Contra. solve_by_inverts <span class="number">2.</span> <span class="keyword">Qed</span>.   <span class="comment">(** 2-depth inversions **)</span></span><br></pre></td></tr></table></figure>


<h3 id="Lemma-Canonical-Forms-典范形式"><a href="#Lemma-Canonical-Forms-典范形式" class="headerlink" title="Lemma Canonical Forms 典范形式"></a><code>Lemma</code> Canonical Forms 典范形式</h3><p>As PLT. </p>
<h3 id="Progress-可进性"><a href="#Progress-可进性" class="headerlink" title="Progress (可进性)"></a>Progress (可进性)</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> <span class="built_in">progress</span> : ∀t T,</span><br><span class="line">  ⊢ t ∈ T →</span><br><span class="line">  value t ∨ ∃t&#x27;, t --&gt; t&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Progress vs Strong Progress?<br>Progress require the “well-typeness”! </p>
</blockquote>
<blockquote>
<p>Induction on typing relation.</p>
</blockquote>
<h3 id="Slide-Q-A"><a href="#Slide-Q-A" class="headerlink" title="Slide Q&amp;A"></a>Slide Q&amp;A</h3><ul>
<li>partial function yes</li>
<li>total function no <ul>
<li>thinking as our inference rules.</li>
<li>we could construct some terms that no inference rules can apply and get stucked.</li>
</ul>
</li>
</ul>
<h3 id="Type-Preservation-维型性"><a href="#Type-Preservation-维型性" class="headerlink" title="Type Preservation (维型性)"></a>Type Preservation (维型性)</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> preservation : ∀t t&#x27; T,</span><br><span class="line">  ⊢ t ∈ T →   <span class="comment">(** HT **)</span></span><br><span class="line">  t --&gt; t&#x27; →  <span class="comment">(** HE **)</span></span><br><span class="line">  ⊢ t&#x27; ∈ T.   <span class="comment">(** HT&#x27; **)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>按 PLT  的思路 Induction on HT，需要 inversion HE 去枚举所有情况拿到 t’ 之后证明 HT’<br>按 PFPL 的思路 Inudction on HE, 只需 inversion HT，因为 HT 是按 reduction 相反方向定义的! </p>
<ul>
<li>reduction 方向，AST top-down   e.g. (+ 5 5)   —–&gt;   10</li>
<li>typing    方向，AST bottom-up  e.g. |- ..:N   |—–   |- (+ 5 5):N</li>
</ul>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Proof</span> <span class="built_in">with</span> <span class="built_in">eauto</span>.</span><br><span class="line">  <span class="built_in">intros</span> t t&#x27; T HT HE.</span><br><span class="line">  <span class="built_in">generalize</span> <span class="built_in">dependent</span> T.</span><br><span class="line">  <span class="built_in">induction</span> HE; <span class="built_in">intros</span> T HT;</span><br><span class="line">    <span class="built_in">inversion</span> HT; <span class="built_in">subst</span>...</span><br><span class="line">  <span class="built_in">apply</span> nvalue_in_nat...  <span class="comment">(** 除了 ST_PrdScc 全部 inversion 解决... **)</span></span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The preservation theorem is often called <em>subject reduction</em>,  – 主语化简<br>想象 term 是主语，仅仅 term 在化简，而谓语宾语不变</p>
</blockquote>
<blockquote>
<p>one might wonder whether the opposity property — <em>subject expansion</em> — also holds. – 主语拓张<br>No, 我们可以很容易从 <code>(test tru zro fls)</code> 证明出 <code>|- fls \in Nat</code>. – 停机问题 (undecidable)</p>
</blockquote>
<h3 id="Type-Soundness-Type-Safety"><a href="#Type-Soundness-Type-Safety" class="headerlink" title="Type Soundness (Type Safety)"></a>Type Soundness (Type Safety)</h3><blockquote>
<p>a well-typed term never get stuck. </p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> multistep := (multi step).  <span class="comment">(** &lt;--- from SmallStep **)</span></span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;t1 &#x27;--&gt;*&#x27; t2&quot;</span> := (multistep t1 t2) (<span class="built_in">at</span> level <span class="number">40</span>).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Corollary</span> soundness : ∀t t&#x27; T,</span><br><span class="line">  ⊢ t ∈ T →</span><br><span class="line">  t --&gt;* t&#x27; →</span><br><span class="line">  ~(stuck t&#x27;).</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> t t&#x27; T HT P. <span class="built_in">induction</span> P; <span class="built_in">intros</span> [R S].</span><br><span class="line">  <span class="built_in">destruct</span> (<span class="built_in">progress</span> x T HT); <span class="built_in">auto</span>.</span><br><span class="line">  <span class="built_in">apply</span> IHP. <span class="built_in">apply</span> (preservation x y T HT H).</span><br><span class="line">  <span class="built_in">unfold</span> stuck. <span class="built_in">split</span>; <span class="built_in">auto</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>Induction on <code>--&gt;*</code>, the multi-step derivation. (i.e. the reflexive-transtive closure)</p>
<p>Noticed that in PLT, we explcitly write out what is “non-stuck”.<br>But here is <code>~(stuck t&#39;)</code><br>thus the proof becomes:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R : step_normal_form x    <span class="comment">(** normal form **)</span></span><br><span class="line">S : ~ value x             <span class="comment">(** and not value **)</span></span><br><span class="line">=======================</span><br><span class="line">False                     <span class="comment">(** prove this is False **)</span></span><br></pre></td></tr></table></figure>

<p>The proof is weird tho.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_plf/2019-03-07-sf-plf-07-STLC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_plf/2019-03-07-sf-plf-07-STLC/" class="post-title-link" itemprop="url">「SF-PLF」7 Stlc</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>this chapter:</p>
<ul>
<li>(change to new syntax…)</li>
<li>function abstraction</li>
<li>variable binding  – 变量绑定</li>
<li>substitution      – 替换</li>
</ul>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>“Base Types”, only <code>Bool</code> for now.   – 基类型<br>…again, exactly following TAPL.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">t ::= </span><br><span class="line">    | <span class="type">x</span>                         variable</span><br><span class="line">    | <span class="type">\x</span>:T1.t2                  abstraction       -- haskell-ish lambda</span><br><span class="line">    | <span class="type">t1</span> t2                     application</span><br><span class="line">    | <span class="type">tru</span>                       constant true</span><br><span class="line">    | <span class="type">fls</span>                       constant false</span><br><span class="line">    | <span class="type">test</span> t1 <span class="keyword">then</span> t2 <span class="keyword">else</span> t3   conditional</span><br><span class="line"></span><br><span class="line">T ::= </span><br><span class="line">    | <span class="type">Bool</span></span><br><span class="line">    | <span class="type">T</span> → T                     arrow type</span><br><span class="line"></span><br><span class="line">-- example</span><br><span class="line">\x:Bool. \y:Bool. x</span><br><span class="line">(\x:Bool. \y:Bool. x) fls tru</span><br><span class="line">\f:Bool→Bool. f (f tru)</span><br></pre></td></tr></table></figure>

<p>Some known λ-idioms:</p>
<blockquote>
<p>two-arg functions are higher-order one-arg fun, i.e. curried<br>no named functions yet, all “anonymous”  – 匿名函数</p>
</blockquote>
<h2 id="Slide-QA-1"><a href="#Slide-QA-1" class="headerlink" title="Slide QA 1"></a>Slide QA 1</h2><ol>
<li>2</li>
<li><code>Bool</code>, <code>fls</code></li>
</ol>
<h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><p>Formalize syntax.<br>things are, as usual, in the <code>Type</code> level, so we can “check” them w&#x2F; dependent type.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> ty : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">Bool</span> : ty</span><br><span class="line">  | <span class="type">Arrow</span> : ty → ty → ty.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Inductive</span> tm : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">var</span> : string → tm</span><br><span class="line">  | <span class="type">app</span> : tm → tm → tm</span><br><span class="line">  | <span class="type">abs</span> : string → ty → tm → tm</span><br><span class="line">  | <span class="type">tru</span> : tm</span><br><span class="line">  | <span class="type">fls</span> : tm</span><br><span class="line">  | <span class="type">test</span> : tm → tm → tm → tm.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Noted that, <code>\x:T.t</code> (formally, <code>abs x T t</code>), the argument type is explicitly annotated (not inferred.)</p>
</blockquote>
<p>另外，这里介绍了一个小 trick: 用 <code>Notation</code> (更接近 宏 ) 而非 <code>Defintion</code> 使得我们可以使用 <code>auto</code>…</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** idB = \x:Bool. x **)</span></span><br><span class="line"><span class="keyword">Notation</span> idB := (abs x Bool (var x)).</span><br></pre></td></tr></table></figure>






<h2 id="Operational-Semantics"><a href="#Operational-Semantics" class="headerlink" title="Operational Semantics"></a>Operational Semantics</h2><h3 id="Values-值"><a href="#Values-值" class="headerlink" title="Values 值"></a>Values 值</h3><ul>
<li><code>tru</code> and <code>fls</code> are values</li>
<li>what about function?<ol>
<li><code>\x:T. t</code> is value iff <code>t</code> value. – Coq </li>
<li><code>\x:T. t</code> is always value         – most FP lang, either CBV or CBN</li>
</ol>
</li>
</ul>
<p>Coq 这么做挺奇怪的，不过对 Coq 来说: </p>
<blockquote>
<p>terms can be considered equiv up to the computation VM (在其项化简可以做到的范围内都算相等)<br>this rich the notion of Coq’s value (所以 Coq 的值的概念是比一般要大的)</p>
</blockquote>
<p>Three ways to construct <code>value</code> (unary relation &#x3D; predicate)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> value : tm → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">v_abs</span> : ∀x T t, value (abs x T t)</span><br><span class="line">  | <span class="type">v_tru</span> : value tru</span><br><span class="line">  | <span class="type">v_fls</span> : value fls.</span><br></pre></td></tr></table></figure>


<h3 id="STLC-Programs-「程序」的概念也是要定义的"><a href="#STLC-Programs-「程序」的概念也是要定义的" class="headerlink" title="STLC Programs 「程序」的概念也是要定义的"></a>STLC Programs 「程序」的概念也是要定义的</h3><ul>
<li><em>closed</em>    &#x3D; term not refer any undefined var &#x3D; <strong>complete program</strong></li>
<li><em>open term</em> &#x3D; term with <em>free variable</em></li>
</ul>
<blockquote>
<p>Having made the choice not to reduce under abstractions, we don’t need to worry about whether variables are values, since we’ll always be reducing programs “from the outside in,” and that means the step relation will always be working with closed terms.</p>
</blockquote>
<p>if we could reduce under abstraction and variables are values… What’s the implication here? 始终不懂…</p>
<h3 id="Substitution-IMPORTANT-替换"><a href="#Substitution-IMPORTANT-替换" class="headerlink" title="Substitution (IMPORTANT!) 替换"></a>Substitution (IMPORTANT!) 替换</h3><blockquote>
<p><code>[x:=s]t</code> and pronounced “substitute s for x in t.”</p>
</blockquote>
<pre><code>(\x:Bool. test x then tru else x) fls   ==&gt;    test fls then tru else fls
</code></pre>
<p>Important <em>capture</em> example:</p>
<pre><code>[x:=tru] (\x:Bool. x)  ==&gt;  \x:Bool. x     -- x is bound, we need α-conversion here
                       !=&gt;  \x:Bool. tru
</code></pre>
<p>Informal definition…</p>
<pre><code>[x:=s]x               = s
[x:=s]y               = y                     if x ≠ y
[x:=s](\x:T11. t12)   = \x:T11. t12
[x:=s](\y:T11. t12)   = \y:T11. [x:=s]t12     if x ≠ y
[x:=s](t1 t2)         = ([x:=s]t1) ([x:=s]t2)
...
</code></pre>
<p>and formally:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Reserved</span> <span class="keyword">Notation</span> <span class="string">&quot;&#x27;[&#x27; x &#x27;:=&#x27; s &#x27;]&#x27; t&quot;</span> (<span class="built_in">at</span> level <span class="number">20</span>).</span><br><span class="line"><span class="keyword">Fixpoint</span> <span class="built_in">subst</span> (x : string) (s : tm) (t : tm) : tm :=</span><br><span class="line">  <span class="keyword">match</span> t <span class="built_in">with</span></span><br><span class="line">  | <span class="type">var</span> x&#x27; ⇒ <span class="keyword">if</span> eqb_string x x&#x27; <span class="keyword">then</span> s <span class="keyword">else</span> t    <span class="comment">(* &lt;-- computational eqb_string *)</span></span><br><span class="line">  | <span class="type">abs</span> x&#x27; T t1 ⇒ abs x&#x27; T (<span class="keyword">if</span> eqb_string x x&#x27; <span class="keyword">then</span> t1 <span class="keyword">else</span> ([x:=s] t1))</span><br><span class="line">  | <span class="type">app</span> t1 t2 ⇒ app ([x:=s] t1) ([x:=s] t2)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Computable <code>Fixpoint</code> means <em>meta-function</em>! (in metalanguage, Coq here)</p>
</blockquote>
<h3 id="如果我们考虑用于替换掉某个变量的项-s-其本身也含有自由变量，-那么定义替换将会变得困难一点。"><a href="#如果我们考虑用于替换掉某个变量的项-s-其本身也含有自由变量，-那么定义替换将会变得困难一点。" class="headerlink" title="如果我们考虑用于替换掉某个变量的项 s 其本身也含有自由变量， 那么定义替换将会变得困难一点。"></a>如果我们考虑用于替换掉某个变量的项 s 其本身也含有自由变量， 那么定义替换将会变得困难一点。</h3><p>Is <code>if x ≠ y</code> for function abstraction one sufficient?  – 在 PLT 中我们采取了更严格的定义</p>
<blockquote>
<p>Only safe if we only consider <code>s</code> is closed term. </p>
</blockquote>
<p>Prof.Mtf:</p>
<blockquote>
<p>here…it’s not really “<em>defining</em> on closed terms”. Technically, you can still write open terms.<br>if we want, we could define the real <code>closed_term</code>…more works to prove things tho.</p>
</blockquote>
<p>Prof.Mtf:</p>
<blockquote>
<p>In some more rigorous setting…we might define <code>well_typed_term</code><br>and the definition itself is the proof of <code>Preservation</code>! </p>
</blockquote>
<h3 id="Slide-QA-2"><a href="#Slide-QA-2" class="headerlink" title="Slide QA 2"></a>Slide QA 2</h3><ol>
<li>(3)</li>
</ol>
<h3 id="Reduction-（beta-reduction）-beta-归约"><a href="#Reduction-（beta-reduction）-beta-归约" class="headerlink" title="Reduction （beta-reduction） beta-归约"></a>Reduction （beta-reduction） beta-归约</h3><p>Should be familar</p>
<pre><code>                value v2
      ----------------------------                   (ST_AppAbs)   until value, i.e. function  (β-reduction)
      (\x:T.t12) v2 --&gt; [x:=v2]t12

                t1 --&gt; t1&#39;
            ----------------                           (ST_App1)   reduce lhs, Function side
            t1 t2 --&gt; t1&#39; t2

                value v1
                t2 --&gt; t2&#39;
            ----------------                           (ST_App2)   reduce rhs, Arg side 
            v1 t2 --&gt; v1 t2&#39;
</code></pre>
<p>Formally,<br>(I was expecting they invents some new syntax for this one…so we only have AST)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Reserved</span> <span class="keyword">Notation</span> <span class="string">&quot;t1 &#x27;--&gt;&#x27; t2&quot;</span> (<span class="built_in">at</span> level <span class="number">40</span>).</span><br><span class="line"><span class="keyword">Inductive</span> step : tm → tm → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">ST_AppAbs</span> : ∀x T t12 v2,</span><br><span class="line">         value v2 →</span><br><span class="line">         (app (abs x T t12) v2) --&gt; [x:=v2]t12</span><br><span class="line">  | <span class="type">ST_App1</span> : ∀t1 t1&#x27; t2,</span><br><span class="line">         t1 --&gt; t1&#x27; →</span><br><span class="line">         app t1 t2 --&gt; app t1&#x27; t2</span><br><span class="line">  | <span class="type">ST_App2</span> : ∀v1 t2 t2&#x27;,</span><br><span class="line">         value v1 →</span><br><span class="line">         t2 --&gt; t2&#x27; →</span><br><span class="line">         app v1 t2 --&gt; app v1 t2&#x27;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<h3 id="Slide-QA-3"><a href="#Slide-QA-3" class="headerlink" title="Slide QA 3"></a>Slide QA 3</h3><ol>
<li>(1)  <code>idBB idB -&gt; idB</code></li>
<li>(1)  <code>idBB (idBB idB) -&gt; idB</code></li>
<li>if () ill-typed <code>idBB (notB tru) -&gt; idBB fls ....</code><ul>
<li>we don’t type check in step</li>
</ul>
</li>
<li>(3)  <code>idB fls</code></li>
<li>NOT…ill-typed one &amp; open term</li>
</ol>
<h2 id="Typing"><a href="#Typing" class="headerlink" title="Typing"></a>Typing</h2><h3 id="Typing-Contexts-类型上下文"><a href="#Typing-Contexts-类型上下文" class="headerlink" title="Typing Contexts 类型上下文"></a>Typing Contexts 类型上下文</h3><p>we need something like environment but for Types.</p>
<blockquote>
<p>three-place typing judgment, informally written   – 三元类型断言</p>
</blockquote>
<pre><code>Gamma ⊢ t ∈ T
</code></pre>
<blockquote>
<p>“under the assumptions in Gamma, the term t has the type T.”</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Definition</span> context := partial_map ty.</span><br><span class="line">(X ⊢&gt; T11, Gamma) </span><br></pre></td></tr></table></figure>

<p>Why <code>partial_map</code> here?<br>IMP can use <code>total_map</code> because it gave default value for undefined var.</p>
<h3 id="Typing-Relations"><a href="#Typing-Relations" class="headerlink" title="Typing Relations"></a>Typing Relations</h3><pre><code>                          Gamma x = T
                        ----------------                            (T_Var)   look up
                        Gamma |- x \in T

               (x |-&gt; T11 ; Gamma) |- t12 \in T12
               ----------------------------------                   (T_Abs)   type check against context w/ arg
                Gamma |- \x:T11.t12 \in T11-&gt;T12

                    Gamma |- t1 \in T11-&gt;T12
                      Gamma |- t2 \in T11
                     ----------------------                         (T_App)
                     Gamma |- t1 t2 \in T12
</code></pre>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> typing_example_1 :</span><br><span class="line">  empty ⊢ abs x Bool (var x) ∈ Arrow Bool Bool.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">apply</span> T_Abs. <span class="built_in">apply</span> T_Var. <span class="built_in">reflexivity</span>. <span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>


<p><code>example_2</code></p>
<ul>
<li><code>eapply</code></li>
<li><code>A</code> ?? looks like need need another environment to look up <code>A</code>…</li>
</ul>
<h3 id="Typable-Deciable"><a href="#Typable-Deciable" class="headerlink" title="Typable &#x2F; Deciable"></a>Typable &#x2F; Deciable</h3><blockquote>
<p>decidable type system &#x3D; decide term if typable or not.<br>done by type checker…</p>
</blockquote>
<blockquote>
<p>can we prove…?<br><code>∀ Γ e, ∃ τ, (Γ ⊢ e : τ) ∨ ¬(Γ ⊢ e : τ)</code> – a type inference algorithm!</p>
</blockquote>
<blockquote>
<p>Provability in Coq witness decidabile operations.</p>
</blockquote>
<h3 id="show-term-is-“not-typeable”"><a href="#show-term-is-“not-typeable”" class="headerlink" title="show term is “not typeable”"></a>show term is “not typeable”</h3><p>Keep inversion till the contradiction.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_plf/2019-03-08-sf-plf-08-STLC-prop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_plf/2019-03-08-sf-plf-08-STLC-prop/" class="post-title-link" itemprop="url">「SF-PLF」8 StlcProp</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>基本的定理依赖关系 top-down: </p>
<p>Type Safety</p>
<ul>
<li>Progress<ul>
<li>Canonical Forms (one for each type of value)</li>
</ul>
</li>
<li>Preservation<ul>
<li>Substituion<ul>
<li>Context Invariance (in PLT, Exchange, and Weakening)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Canonical-Forms"><a href="#Canonical-Forms" class="headerlink" title="Canonical Forms"></a>Canonical Forms</h2><p>对于我们只有 <code>bool</code> 一个 base type 的 STLC，只需要 <code>bool</code> 和 <code>λ</code>:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> canonical_forms_bool : ∀t,</span><br><span class="line">  empty ⊢ t ∈ Bool →</span><br><span class="line">  value t →</span><br><span class="line">  (t = tru) ∨ (t = fls).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Lemma</span> canonical_forms_fun : ∀t T1 T2,</span><br><span class="line">  empty ⊢ t ∈ (Arrow T1 T2) →</span><br><span class="line">  value t →</span><br><span class="line">  ∃x u, t = abs x T1 u.</span><br></pre></td></tr></table></figure>



<h2 id="Progress"><a href="#Progress" class="headerlink" title="Progress"></a>Progress</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> <span class="built_in">progress</span> : ∀t T,</span><br><span class="line">  empty ⊢ t ∈ T →</span><br><span class="line">  value t ∨ ∃t&#x27;, t --&gt; t&#x27;.</span><br></pre></td></tr></table></figure>

<p>类似 <code>Types</code> 章节的 <code>progress</code> 和 PLT 中的 proof. </p>
<ol>
<li>induction on typing relation</li>
<li>induction on term</li>
</ol>
<p>这两个思路的证明基本一致，</p>
<ul>
<li><code>auto</code> 上来就用把 <code>tru</code>, <code>fls</code>, <code>abs</code> 三个 <code>value</code> 的 case 干掉了，</li>
<li>take step 的 case 则需要 witness 一个 <code>t&#39;</code>, 这时候 Canonical Form 就派上用场了</li>
</ul>
<h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><p><em>preservation theorem</em> </p>
<ul>
<li>induction on typing; prove it type-preserving after reduction&#x2F;evaluation (what about induction on reduction?)</li>
<li><code>ST_AppAbs</code> 比较麻烦，需要做 substitution，所以我们需要证明 substituion 本身是 type-preserving…<br><em>substitution lemma</em></li>
<li>induction on term; prove it type-preserving after a substitution</li>
<li>替换会将 bound var 加入 Context，所以我们需要证明 free var 对于新的 Context 仍然是 type-preserving…<ul>
<li>这里我们需要 the formal definition of <em>free var</em> as well.<br><em>context invariance</em></li>
</ul>
</li>
<li>exchange  : 交换顺序显然无影响</li>
<li>weakening : 如果不是 override 的话，添加新变量显然对于之前的 well-typeness 无影响</li>
</ul>
<h3 id="Free-Occurrences"><a href="#Free-Occurrences" class="headerlink" title="Free Occurrences"></a>Free Occurrences</h3><p>在 PLT&#x2F;TAPL 中，我们将 “free variables of an term” 定义为一个集合 <code>FV(t)</code>. (集合是一种 computational 的概念)</p>
<pre><code>    FV(x) = &#123;x&#125;
FV(λx.t1) = FV(t1) ∪ FV(t2)
FV(t1 t2) = FV(t1) \ &#123;x&#125; 
</code></pre>
<p>在这里，我们则将 “appears_free in” 定义为 var <code>x</code> 与 term <code>t</code> 上的二元关系: (读作 judgement 即可)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> appears_free_in : string → tm → <span class="keyword">Prop</span> :=</span><br><span class="line">  | <span class="type">afi_var</span> : ∀x,</span><br><span class="line">      appears_free_in x (var x)</span><br><span class="line">  | <span class="type">afi_app1</span> : ∀x t1 t2,</span><br><span class="line">      appears_free_in x t1 →</span><br><span class="line">      appears_free_in x (app t1 t2)</span><br><span class="line">  | <span class="type">afi_app2</span> : ∀x t1 t2,</span><br><span class="line">      appears_free_in x t2 →</span><br><span class="line">      appears_free_in x (app t1 t2)</span><br><span class="line">  | <span class="type">afi_abs</span> : ∀x y T11 t12,</span><br><span class="line">      y ≠ x →</span><br><span class="line">      appears_free_in x t12 →</span><br><span class="line">      appears_free_in x (abs y T11 t12)</span><br><span class="line">  <span class="comment">(** 省略 test **)</span></span><br><span class="line">  ... </span><br><span class="line"></span><br><span class="line"><span class="keyword">Hint</span> <span class="keyword">Constructors</span> appears_free_in.</span><br><span class="line"></span><br><span class="line"><span class="comment">(** a term with no free vars. 等价于 ¬(∃x,  appears_free_in x t). **)</span> </span><br><span class="line"><span class="keyword">Definition</span> closed (t:tm) :=           ∀x, ¬appears_free_in x t.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>An <em>open term</em> is one that <em>may</em> contain free variables.<br>“Open” precisely means “possibly containing free variables.”</p>
</blockquote>
<blockquote>
<p>the closed terms are a subset of the open ones.<br>closed 是 open 的子集…这样定义吗（</p>
</blockquote>
<h3 id="Free-Vars-is-in-Context"><a href="#Free-Vars-is-in-Context" class="headerlink" title="Free Vars is in Context"></a>Free Vars is in Context</h3><p>首先我们需要一个「free var 都是 well-typed 」的 lemma</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> free_in_context : ∀x t T Gamma,   <span class="comment">(** 名字有一点 misleading，意思是 &quot;free vars is in context&quot; 而不是 &quot;var is free in context&quot;... **)</span></span><br><span class="line">   appears_free_in x t →</span><br><span class="line">   Gamma ⊢ t ∈ T →</span><br><span class="line">   ∃T&#x27;, Gamma x = Some T&#x27;.</span><br></pre></td></tr></table></figure>

<p>由此我们可以推论 所有在 empty context 下 well typed 的 term 都是 closed 得：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Corollary</span> typable_empty__closed : ∀t T,</span><br><span class="line">    empty ⊢ t ∈ T →</span><br><span class="line">    closed t.</span><br></pre></td></tr></table></figure>


<h3 id="Context-Invariance-上下文的一些「不变式」"><a href="#Context-Invariance-上下文的一些「不变式」" class="headerlink" title="Context Invariance 上下文的一些「不变式」"></a>Context Invariance 上下文的一些「不变式」</h3><p>PLT 的 Weaking 和 Exchanging 其实就对应了 Gamma 作为 <code>partial_map</code> 的 <code>neq</code> 和 <code>permute</code><br>这里，我们直接进一步地证明 「term 的 well-typeness 在『free var 的值不变的 context 变化下』是 preserving 得」: </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> context_invariance : ∀Gamma Gamma&#x27; t T,</span><br><span class="line">    Gamma ⊢ t ∈ T →</span><br><span class="line">    (∀x, appears_free_in x t → Gamma x = Gamma&#x27; x) →    <span class="comment">(** &lt;-- 这句的意思是：对于 freevar，我们有其值不变。（如果没有括号就变成所有值都不变了……）**)</span></span><br><span class="line">    Gamma&#x27; ⊢ t ∈ T.</span><br></pre></td></tr></table></figure>


<h3 id="Substitution"><a href="#Substitution" class="headerlink" title="Substitution!"></a>Substitution!</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> substitution_preserves_typing : ∀Gamma x U t v T,</span><br><span class="line">  (x ⊢&gt; U ; Gamma) ⊢ t ∈ T →</span><br><span class="line">  empty ⊢ v ∈ U →              <span class="comment">(** 这里我们其实 assume 被替换进来的项，即「参数」，是 closed 得。这是一个简化的版本 **)</span></span><br><span class="line">  Gamma ⊢ [x:=v]t ∈ T.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以被看做一种交换律 (“commutation property”)<br>即先 type check 再 substitution 和 先 substition 再 type check 是等价的</p>
</blockquote>
<p>Proof by induction on term <strong>不好证，挺麻烦的</strong></p>
<h3 id="Finally-Preservation"><a href="#Finally-Preservation" class="headerlink" title="Finally, Preservation"></a>Finally, Preservation</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> preservation : ∀t t&#x27; T,</span><br><span class="line">  empty ⊢ t ∈ T →</span><br><span class="line">  t --&gt; t&#x27; →</span><br><span class="line">  empty ⊢ t&#x27; ∈ T.</span><br></pre></td></tr></table></figure>


<h3 id="Not-subject-expansion"><a href="#Not-subject-expansion" class="headerlink" title="Not subject expansion"></a>Not subject expansion</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> not_subject_expansion:</span><br><span class="line">  ~(<span class="keyword">forall</span> t t&#x27; T, t --&gt; t&#x27; /\ empty |<span class="type">- t</span>&#x27; \<span class="built_in">in</span> T -&gt; empty |<span class="type">- t</span> \<span class="built_in">in</span> T).</span><br></pre></td></tr></table></figure>

<pre><code>(app (abs x (Arrow Bool Bool) tru) tru)  -- 考虑 term 

(λx:Bool-&gt;Bool . tru) tru   --&gt;   tru    -- 可以 step
                    empty   |-   Bool    -- step 后 well-typed

empty |-/-  (λx:Bool-&gt;Bool . tru) tru    -- 但是原 term 显然 ill-typed
</code></pre>
<h2 id="Type-Soundness"><a href="#Type-Soundness" class="headerlink" title="Type Soundness"></a>Type Soundness</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** stuck 即在不是 value 的时候无法 step **)</span></span><br><span class="line"><span class="keyword">Definition</span> stuck (t:tm) : <span class="keyword">Prop</span> :=</span><br><span class="line">  (normal_form step) t ∧ ¬value t.</span><br><span class="line"></span><br><span class="line"><span class="comment">(** well-typed term never get stuck! **)</span></span><br><span class="line"><span class="keyword">Corollary</span> soundness : ∀t t&#x27; T,</span><br><span class="line">  empty ⊢ t ∈ T →</span><br><span class="line">  t --&gt;* t&#x27; →</span><br><span class="line">  ~(stuck t&#x27;).</span><br></pre></td></tr></table></figure>



<h2 id="Uniqueness-of-Types"><a href="#Uniqueness-of-Types" class="headerlink" title="Uniqueness of Types"></a>Uniqueness of Types</h2><blockquote>
<p>这里的 Uniqueness 与 Right-unique &#x2F; deterministic &#x2F; functional 其实都是相同的内涵</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> unique_types : ∀Gamma e T T&#x27;,</span><br><span class="line">  Gamma ⊢ e ∈ T →</span><br><span class="line">  Gamma ⊢ e ∈ T&#x27; →</span><br><span class="line">  T = T&#x27;.</span><br></pre></td></tr></table></figure>





<h2 id="Additional-Exercises"><a href="#Additional-Exercises" class="headerlink" title="Additional Exercises"></a>Additional Exercises</h2><h3 id="STLC-with-Arithmetic"><a href="#STLC-with-Arithmetic" class="headerlink" title="STLC with Arithmetic"></a>STLC with Arithmetic</h3><blockquote>
<p>only <code>Nat</code>…这样就不用管 the interaction between <code>Bool</code> and <code>Nat</code> </p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> ty : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">Arrow</span> : ty → ty → ty</span><br><span class="line">  | <span class="type">Nat</span> : ty.            <span class="comment">(** &lt;-- the only concrete base type **)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Inductive</span> tm : <span class="keyword">Type</span> :=</span><br><span class="line">  | <span class="type">var</span> : string → tm</span><br><span class="line">  | <span class="type">app</span> : tm → tm → tm</span><br><span class="line">  | <span class="type">abs</span> : string → ty → tm → tm</span><br><span class="line">  | <span class="type">const</span> : nat → tm     <span class="comment">(** &lt;-- 居然用 metalang 的 nat 而非 zro **)</span></span><br><span class="line">  | <span class="type">scc</span> : tm → tm</span><br><span class="line">  | <span class="type">prd</span> : tm → tm</span><br><span class="line">  | <span class="type">mlt</span> : tm → tm → tm</span><br><span class="line">  | <span class="type">test0</span> : tm → tm → tm → tm.</span><br></pre></td></tr></table></figure>

<p>更多拓展见下一章 <code>MoreStlc.v</code> </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_plf/2019-03-09-sf-plf-09-more-STLC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_plf/2019-03-09-sf-plf-09-more-STLC/" class="post-title-link" itemprop="url">「SF-PLF」9 MoreStlc</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>make the STLC into a PL!</p>
</blockquote>
<h2 id="Simple-Extensions-to-STLC"><a href="#Simple-Extensions-to-STLC" class="headerlink" title="Simple Extensions to STLC"></a>Simple Extensions to STLC</h2><blockquote>
<p>其实这一部分我好像没有任何必要做笔记……</p>
</blockquote>
<h3 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h3><p>See <code>StlcProp.v</code> exercise <code>stlc_arith</code>.</p>
<h3 id="Let-Bindings"><a href="#Let-Bindings" class="headerlink" title="Let Bindings"></a>Let Bindings</h3><ul>
<li>In PLT slide, we treat <code>let x   = t1 in e</code> as a derived form of <code>(λx   . e) t1</code>.</li>
<li>In PLT langF, we treat <code>let x:T = t1 in e</code> as a derived form of <code>(λx:T . e) t1</code>. (both require explicit type annotation)</li>
</ul>
<p>SF here, same as TaPL, treat it <em>less derived</em> by _compute the type <code>T1</code> from <code>t1</code>. </p>
<ul>
<li>but TaPL treat it by desugar to <code>λ</code> later on, here we directly “execute” it via substituion.</li>
</ul>
<p>我想这里有一个原因是， <code>λ</code> 必须要可以独立被 typed，但是这时候我们还没有 <code>t1</code>，无法计算出 <code>T1</code>。而 <code>let</code> 的形式中包括了 <code>t1</code>，所以可以直接计算:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t ::=                Terms</span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | let</span> x=t <span class="built_in">in</span> t      <span class="keyword">let</span>-binding</span><br></pre></td></tr></table></figure>

<pre><code>Reduction:

                             t1 --&gt; t1&#39;
                 ----------------------------------               (ST_Let1)
                 let x=t1 in t2 --&gt; let x=t1&#39; in t2

                    ----------------------------              (ST_LetValue)  &lt;-- substitute as λ
                    let x=v1 in t2 --&gt; [x:=v1]t2

Typing:

         Gamma |- t1 \in T1      x|-&gt;T1; Gamma |- t2 \in T2
         --------------------------------------------------        (T_Let)
                    Gamma |- let x=t1 in t2 \in T2
</code></pre>
<h3 id="Pairs-Product-Type"><a href="#Pairs-Product-Type" class="headerlink" title="Pairs (Product Type)"></a>Pairs (Product Type)</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t ::=                Terms</span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | (t</span>,t)             pair</span><br><span class="line">    | <span class="type">t</span>.fst             <span class="built_in">first</span> projection</span><br><span class="line">    | <span class="type">t</span>.snd             second projection</span><br><span class="line"></span><br><span class="line">v ::=                Values</span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | (v</span>,v)             pair value</span><br><span class="line"></span><br><span class="line">T ::=                <span class="keyword">Types</span></span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | T</span> * T             product type</span><br></pre></td></tr></table></figure>

<pre><code>Reduction:

                          t1 --&gt; t1&#39;
                     --------------------                        (ST_Pair1)
                     (t1,t2) --&gt; (t1&#39;,t2)

                          t2 --&gt; t2&#39;
                     --------------------                        (ST_Pair2)
                     (v1,t2) --&gt; (v1,t2&#39;)

                          t1 --&gt; t1&#39;
                      ------------------                          (ST_Fst1)
                      t1.fst --&gt; t1&#39;.fst

                      ------------------                       (ST_FstPair)
                      (v1,v2).fst --&gt; v1

                          t1 --&gt; t1&#39;
                      ------------------                          (ST_Snd1)
                      t1.snd --&gt; t1&#39;.snd

                      ------------------                       (ST_SndPair)
                      (v1,v2).snd --&gt; v2


Typing:

           Gamma |- t1 \in T1     Gamma |- t2 \in T2
           -----------------------------------------               (T_Pair)
                   Gamma |- (t1,t2) \in T1*T2

                    Gamma |- t \in T1*T2
                    ---------------------                          (T_Fst)
                    Gamma |- t.fst \in T1

                    Gamma |- t \in T1*T2
                    ---------------------                          (T_Snd)
                    Gamma |- t.snd \in T2
</code></pre>
<h3 id="Unit-Singleton-Type-单元类型"><a href="#Unit-Singleton-Type-单元类型" class="headerlink" title="Unit (Singleton Type) 单元类型"></a>Unit (Singleton Type) 单元类型</h3><p><code>unit</code> is the only value&#x2F;normal form of type <code>Unit</code>, but not the only term (also any terms that would reduce to <code>unit</code>)</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t ::=                Terms</span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | unit</span>              unit              -- often written `()` <span class="built_in">as</span> well</span><br><span class="line"></span><br><span class="line">v ::=                Values</span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | unit</span>              unit value</span><br><span class="line"></span><br><span class="line">T ::=                <span class="keyword">Types</span></span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | Unit</span>              unit type         -- Haskell even write this `()`</span><br></pre></td></tr></table></figure>

<pre><code>No reduction rule!

Typing:

                     ----------------------                        (T_Unit)
                     Gamma |- unit \in Unit
</code></pre>
<blockquote>
<p>wouldn’t every computation <em>living in</em> such a type be trivial?<br>难道不是每个计算都不会在这样的类型中_居留_吗？</p>
</blockquote>
<blockquote>
<p>Where Unit really comes in handy is in richer languages with side effects<br>在更丰富的语言中，使用 Unit 类型来处理副作用（side effect） 会很方便</p>
</blockquote>
<h3 id="Sum-Type-Disjointed-Union"><a href="#Sum-Type-Disjointed-Union" class="headerlink" title="Sum Type (Disjointed Union)"></a>Sum Type (Disjointed Union)</h3><blockquote>
<p>deal with values that can take two distinct forms – binary sum type<br>两个截然不同的 … “二元和”类型</p>
</blockquote>
<blockquote>
<p>We create elements of these types by <em>tagging</em> elements of the component types<br>我们在创建这些类型的值时，会为值_标记_上其”成分”类型</p>
</blockquote>
<p>标签 <code>inl</code>, <code>inr</code> 可以看做为函数，即 <em>Data Constructor</em></p>
<pre><code>inl : Nat  -&gt; Nat + Bool
inr : Bool -&gt; Nat + Bool
</code></pre>
<blockquote>
<p>that <em>“inject”</em> (注入) elements of <code>Nat</code> or <code>Bool</code> into the left and right components of the sum type <code>Nat+Bool</code></p>
</blockquote>
<p>不过这里并没有把他们作为 function 来形式化，而是把 <code>inl</code> <code>inr</code> 作为关键字，把 <code>inl t</code> <code>inr t</code> 作为 primitive syntactic form…</p>
<ul>
<li>In PLT slide, we use <code>L          (e)</code> and say the <code>T2</code> would be “guessed” to produce <code>T1 + T2</code>, as <em>TaPL option 1</em></li>
<li>In PLT langF, we use <code>L [T1 +T2] (e)</code> i.e. provide a explicit type annotation for the sum type, as <em>TaPL option 3</em> (ascription)</li>
</ul>
<p>SF here, use something in the middle: </p>
<ul>
<li>you provide only <code>T2</code> to <code>L(t1)</code> and <code>T1</code> would be computed from <code>t1</code> to form the <code>T1 + T2</code>.</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">t ::=                Terms</span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | inl</span> T t           tagging (<span class="built_in">left</span>)</span><br><span class="line">    | <span class="type">inr</span> T t           tagging (<span class="built_in">right</span>)</span><br><span class="line">    | <span class="type">case</span> t of         <span class="built_in">case</span></span><br><span class="line">        inl x =&gt; t</span><br><span class="line">      | <span class="type">inr</span> x =&gt; t</span><br><span class="line"></span><br><span class="line">v ::=                Values</span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | inl</span> T v           tagged value (<span class="built_in">left</span>)</span><br><span class="line">    | <span class="type">inr</span> T v           tagged value (<span class="built_in">right</span>)</span><br><span class="line"></span><br><span class="line">T ::=                <span class="keyword">Types</span></span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | T</span> + T             <span class="built_in">sum</span> type</span><br></pre></td></tr></table></figure>

<pre><code>Reduction:

                           t1 --&gt; t1&#39;
                    ------------------------                       (ST_Inl)
                    inl T2 t1 --&gt; inl T2 t1&#39;

                           t2 --&gt; t2&#39;
                    ------------------------                       (ST_Inr)
                    inr T1 t2 --&gt; inr T1 t2&#39;

                           t0 --&gt; t0&#39;
           -------------------------------------------            (ST_Case)
            case t0 of inl x1 =&gt; t1 | inr x2 =&gt; t2 --&gt;
           case t0&#39; of inl x1 =&gt; t1 | inr x2 =&gt; t2

        -----------------------------------------------        (ST_CaseInl)
        case (inl T2 v1) of inl x1 =&gt; t1 | inr x2 =&gt; t2
                       --&gt;  [x1:=v1]t1

        -----------------------------------------------        (ST_CaseInr)
        case (inr T1 v2) of inl x1 =&gt; t1 | inr x2 =&gt; t2
                       --&gt;  [x2:=v1]t2

Typing:

                      Gamma |- t1 \in T1
               ------------------------------                       (T_Inl)
               Gamma |- inl T2 t1 \in T1 + T2

                      Gamma |- t2 \in T2
               -------------------------------                      (T_Inr)
                Gamma |- inr T1 t2 \in T1 + T2

                    Gamma |- t \in T1+T2
                 x1|-&gt;T1; Gamma |- t1 \in T
                 x2|-&gt;T2; Gamma |- t2 \in T
     ----------------------------------------------------          (T_Case)
     Gamma |- case t of inl x1 =&gt; t1 | inr x2 =&gt; t2 \in T
</code></pre>
<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><blockquote>
<p>The typing features we have seen can be classified into </p>
<ul>
<li>基本类型   <em>base types</em> like <code>Bool</code>, and</li>
<li>类型构造子 <em>type constructors</em> like <code>→</code> and <code>*</code> that build new types from old ones.</li>
</ul>
</blockquote>
<blockquote>
<p>In principle, we could encode lists using pairs, sums and <em>recursive types</em>. (and <em>type operator</em> to give the type a name in SystemFω)</p>
</blockquote>
<blockquote>
<p>但是 recursive type 太 non-trivial 了……于是我们直接处理为一个特殊的类型吧</p>
</blockquote>
<ul>
<li><p>in PLT slide, again, we omit the type and simply write <code>nil : List T</code></p>
<ul>
<li>有趣的是, Prof.Mtf 并不满意这个，因为会有 <code>hd nil</code> 这样 stuck 的可能，所以额外给了一个用 <code>unlist</code> (unempty list) 的 def</li>
</ul>
</li>
<li><p>in PLT langF, we did use pairs + sums + recursive types: </p>
<ul>
<li>langF <code>nil : all(&#39;a . rec(&#39;b . unit + (&#39;a * &#39;b)))</code></li>
<li>StlcE <code>nil : ∀α     . µβ     . unit + (α ∗ β)</code></li>
</ul>
</li>
<li><p>in TaPL ch11, we manually provide <code>T</code> to all term (data constructor)</p>
<ul>
<li>but actually, only <code>nil</code> need it! (others can be inferred by argument)</li>
</ul>
</li>
</ul>
<p>and that’s we did for SF here! </p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">t ::=                Terms</span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | nil</span> T                          -- nil need explicit type annotation</span><br><span class="line">    | <span class="type">cons</span> t t</span><br><span class="line">    | <span class="type">lcase</span> t of nil  =&gt; t           -- a special <span class="built_in">case</span> <span class="keyword">for</span> list</span><br><span class="line">               | <span class="type">x</span>::x =&gt; t</span><br><span class="line"></span><br><span class="line">v ::=                Values</span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | nil</span> T             nil value</span><br><span class="line">    | <span class="type">cons</span> v v          cons value</span><br><span class="line"></span><br><span class="line">T ::=                <span class="keyword">Types</span></span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | List</span> T            list of Ts</span><br></pre></td></tr></table></figure>

<pre><code>Reduction:

                            t1 --&gt; t1&#39;
                   --------------------------                    (ST_Cons1)
                   cons t1 t2 --&gt; cons t1&#39; t2

                            t2 --&gt; t2&#39;
                   --------------------------                    (ST_Cons2)
                   cons v1 t2 --&gt; cons v1 t2&#39;

                          t1 --&gt; t1&#39;
            -------------------------------------------         (ST_Lcase1)
             (lcase t1 of nil =&gt; t2 | xh::xt =&gt; t3) --&gt;
            (lcase t1&#39; of nil =&gt; t2 | xh::xt =&gt; t3)

           -----------------------------------------          (ST_LcaseNil)
           (lcase nil T of nil =&gt; t2 | xh::xt =&gt; t3)
                            --&gt; t2

        ------------------------------------------------     (ST_LcaseCons)
        (lcase (cons vh vt) of nil =&gt; t2 | xh::xt =&gt; t3)
                      --&gt; [xh:=vh,xt:=vt]t3                  -- multiple substi


Typing:

                    -------------------------                       (T_Nil)
                    Gamma |- nil T \in List T

         Gamma |- t1 \in T      Gamma |- t2 \in List T
         ---------------------------------------------             (T_Cons)
                Gamma |- cons t1 t2 \in List T

                    Gamma |- t1 \in List T1
                    Gamma |- t2 \in T
            (h|-&gt;T1; t|-&gt;List T1; Gamma) |- t3 \in T
      ---------------------------------------------------         (T_Lcase)
      Gamma |- (lcase t1 of nil =&gt; t2 | h::t =&gt; t3) \in T
</code></pre>
<h3 id="General-Recursion-Fixpoint"><a href="#General-Recursion-Fixpoint" class="headerlink" title="General Recursion (Fixpoint)"></a>General Recursion (Fixpoint)</h3><p>通用的递归，而非 primitive recursion (PFPL)</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fact</span> = \x:<span class="type">Nat</span> . <span class="keyword">if</span> x=<span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> x * (fact (pred x)))</span><br></pre></td></tr></table></figure>

<p>这个在 Stlc 中不被允许，因为我们在定义 <code>fact</code> 的过程中发现了一个 free 的 <code>fact</code>，要么未定义，要么不是自己。<br>所以我们需要 <code>Fixpoint</code> </p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fact</span> = fix (\fact:<span class="type">Nat</span>-&gt;<span class="type">Nat</span>. </span><br><span class="line">       \x:<span class="type">Nat</span> . <span class="keyword">if</span> x=<span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> x * (fact (pred x)))</span><br></pre></td></tr></table></figure>


<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t ::=                Terms</span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | fix</span> t             fixed-point operator</span><br></pre></td></tr></table></figure>

<p>   Reduction:</p>
<pre><code>                            t1 --&gt; t1&#39;
                        ------------------                        (ST_Fix1)
                        fix t1 --&gt; fix t1&#39;

           --------------------------------------------         (ST_FixAbs)
           fix (\xf:T1.t2) --&gt; [xf:=fix (\xf:T1.t2)] t2         -- fix f = f (fix f)
</code></pre>
<p>   Typing:</p>
<pre><code>                       Gamma |- t1 \in T1-&gt;T1
                       ----------------------                       (T_Fix)
                       Gamma |- fix t1 \in T1
</code></pre>
<h3 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h3><p>这里的定义非常 informal:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t ::=                          Terms</span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | &#123;i1</span>=t1, ..., <span class="built_in">in</span>=tn&#125;         <span class="built_in">record</span></span><br><span class="line">    | <span class="type">t</span>.i                         projection</span><br><span class="line"></span><br><span class="line">v ::=                          Values</span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | &#123;i1</span>=v1, ..., <span class="built_in">in</span>=vn&#125;         <span class="built_in">record</span> value</span><br><span class="line"></span><br><span class="line">T ::=                          <span class="keyword">Types</span></span><br><span class="line">    | <span class="type">...</span></span><br><span class="line"><span class="type">    | &#123;i1</span>:T1, ..., <span class="built_in">in</span>:Tn&#125;         <span class="built_in">record</span> type</span><br></pre></td></tr></table></figure>

<pre><code>Reduction:

                          ti --&gt; ti&#39;
             ------------------------------------                  (ST_Rcd)
                 &#123;i1=v1, ..., im=vm, in=ti , ...&#125;
             --&gt; &#123;i1=v1, ..., im=vm, in=ti&#39;, ...&#125;

                          t1 --&gt; t1&#39;
                        --------------                           (ST_Proj1)
                        t1.i --&gt; t1&#39;.i

                  -------------------------                    (ST_ProjRcd)
                  &#123;..., i=vi, ...&#125;.i --&gt; vi

Typing:

        Gamma |- t1 \in T1     ...     Gamma |- tn \in Tn
      ----------------------------------------------------          (T_Rcd)
      Gamma |- &#123;i1=t1, ..., in=tn&#125; \in &#123;i1:T1, ..., in:Tn&#125;

                Gamma |- t \in &#123;..., i:Ti, ...&#125;
                -------------------------------                    (T_Proj)
                      Gamma |- t.i \in Ti
</code></pre>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>提了一嘴 </p>
<ul>
<li>Variant </li>
<li>Recursive type <code>μ</code></li>
</ul>
<p>加起来就可以 </p>
<blockquote>
<p>give us enough mechanism to build <em>arbitrary inductive data types</em> like lists and trees from scratch </p>
</blockquote>
<p>Basically </p>
<p>ADT &#x3D; Unit + Product + Sum (Variant) + Function (Expo)</p>
<p>但是 Coq 的 <code>Inductive</code> 还需要进一步的 Pi (Dependent Product), Sigma (Dependent Sum).</p>
<h2 id="Exercise-Formalizing-the-Extensions"><a href="#Exercise-Formalizing-the-Extensions" class="headerlink" title="Exercise: Formalizing the Extensions"></a>Exercise: Formalizing the Extensions</h2><h3 id="STLCE-definitions"><a href="#STLCE-definitions" class="headerlink" title="STLCE definitions"></a>STLCE definitions</h3><p>基本上就是把上面的 rule 用 AST 写进来</p>
<h3 id="STLCE-examples"><a href="#STLCE-examples" class="headerlink" title="STLCE examples"></a>STLCE examples</h3><blockquote>
<p>a bit of Coq hackery to automate searching for typing derivation</p>
</blockquote>
<p>基本上就是自动化的 pattern matching + tactics</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Hint</span> <span class="keyword">Extern</span> <span class="number">2</span> (has_type <span class="keyword">_</span> (app <span class="keyword">_</span> <span class="keyword">_</span>) <span class="keyword">_</span>) =&gt;</span><br><span class="line">  <span class="built_in">eapply</span> T_App; <span class="built_in">auto</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Hint</span> <span class="keyword">Extern</span> <span class="number">2</span> (has_type <span class="keyword">_</span> (tlcase <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span>) <span class="keyword">_</span>) =&gt;</span><br><span class="line">  <span class="built_in">eapply</span> T_Lcase; <span class="built_in">auto</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Hint</span> <span class="keyword">Extern</span> <span class="number">2</span> (<span class="keyword">_</span> = <span class="keyword">_</span>) =&gt; <span class="built_in">compute</span>; <span class="built_in">reflexivity</span>.</span><br></pre></td></tr></table></figure>


<p>效果非常酷：typecheck 只需要 <code>eauto</code>，reduction 只需要 <code>normalize</code>.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.vvbuys.com/read_sf_plf/2019-03-10-sf-plf-10-subtyping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vvbuys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VVbugs Blog">
      <meta itemprop="description" content="Share some post and some issue for linux program">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VVbugs Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/read_sf_plf/2019-03-10-sf-plf-10-subtyping/" class="post-title-link" itemprop="url">「SF-PLF」10 Sub</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-02 01:05:07" itemprop="dateCreated datePublished" datetime="2024-02-02T01:05:07+00:00">2024-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><h3 id="The-Subsumption-Rule"><a href="#The-Subsumption-Rule" class="headerlink" title="The Subsumption Rule"></a>The Subsumption Rule</h3><h3 id="The-Subtype-Relation"><a href="#The-Subtype-Relation" class="headerlink" title="The Subtype Relation"></a>The Subtype Relation</h3><h3 id="Slide-QA1"><a href="#Slide-QA1" class="headerlink" title="Slide QA1"></a>Slide QA1</h3><p>Record Subtyping… </p>
<p>row type</p>
<p>index? record impl as list</p>
<p>width&#x2F;depth&#x2F;permulation</p>
<ul>
<li>multiple step rules</li>
</ul>
<hr>
<p>Java</p>
<ol>
<li>class - no index (thinking about offset)</li>
</ol>
<p>having both width&#x2F;permulation subtyping make impl slow</p>
<ul>
<li>OOP - hmm</li>
<li>ML has no permulation - for perf reason (static structure) as C</li>
</ul>
<p>ML has depth?</p>
<ul>
<li>a little bit by equality</li>
</ul>
<p>OCaml objection has all three</p>
<h3 id="Slide-QA2"><a href="#Slide-QA2" class="headerlink" title="Slide QA2"></a>Slide QA2</h3><p>Looking at Contravariant!</p>
<ol>
<li><p>(2) <code>&#123;i1:S,i2:T&#125;→U &lt;: &#123;i1:S,i2:T,i3:V&#125;→U</code></p>
</li>
<li><p>(4) <code>&#123;i1:T,i2:V,i3:V&#125; &lt;: &#123;i1:S,i2:U&#125; * &#123;i3:V&#125;</code> is interesting:</p>
</li>
</ol>
<p>the interesting thing is, why don’t we make some subtyping rules for that as well?</p>
<ul>
<li>there are definitely <em>code</em> can do that</li>
<li>their <em>runtime</em> semantics are different tho they carry same information</li>
<li><strong>coercion</strong> can used for that</li>
</ul>
<p>3 and 4. (5) …</p>
<p>A &lt;: Top   &#x3D;&gt;   Top -&gt; A &lt;: A -&gt; A  – contravariant</p>
<p>if we only care <code>(A*T)</code>, can use <code>T:Top</code></p>
<p>but to type the whole thing <code>: A</code></p>
<p><code>Top -&gt; A</code>?<br>but noticed that we said <code>\z:A.z</code></p>
<p>can we pass <code>A -&gt; A</code> into <code>Top -&gt; A</code>?<br>      more specific        more general</p>
<p>smallest -&gt; most specific -&gt; <code>A -&gt; A</code><br>largest  -&gt; most specific -&gt; <code>Top -&gt; A</code></p>
<p>5.<br>“The type Bool has no proper subtypes.” (I.e., the only type smaller than Bool is Bool itself.)<br>Ture unless we have Bottom</p>
<p>hmm seems like <code>Bottom</code> in subtyping is different with Empty&#x2F;Void, which is closer to logical <code>Bottom ⊥</code> since Bottom here is subtyping of everything..<br>OH they are the same: (nice)</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bottom_type">https://en.wikipedia.org/wiki/Bottom_type</a></p>
</blockquote>
<ol start="6">
<li>True</li>
</ol>
<h3 id="Inversion-Lemmas-for-Subtyping"><a href="#Inversion-Lemmas-for-Subtyping" class="headerlink" title="Inversion Lemmas for Subtyping"></a>Inversion Lemmas for Subtyping</h3><p><code>inversion</code> doesn’t lose information, <code>induction</code> does.</p>
<p>auto rememeber?? — dependent induction<br>hetergeous equaltiy</p>
<p>In soundness proof</p>
<ul>
<li>subtyping only affects Canonical Forms + T_Sub case in induction</li>
</ul>
<blockquote>
<p>Lemma: If Gamma ⊢ \x:S1.t2 ∈ T, then there is a type S2 such that x⊢&gt;S1; Gamma ⊢ t2 ∈ S2 and S1 → S2 &lt;: T.</p>
</blockquote>
<p>why <code>T</code> not arrow? Top…</p>
<p>if including Bottom…many proof becomes hard, canonical form need to say…might be Bottom?</p>
<blockquote>
<p>no, no value has type Bottom (Void)…</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/15/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/17/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">vvbuys</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
